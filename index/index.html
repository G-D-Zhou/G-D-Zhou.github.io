<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo-32X32.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo-32X32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo-32X32.png">
  <link rel="mask-icon" href="/images/logo-32X32.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"g-d-zhou.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="格物轩">
<meta property="og:url" content="https://g-d-zhou.github.io/index/index.html">
<meta property="og:site_name" content="格物轩">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Dr. Zhou">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://g-d-zhou.github.io/index/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>格物轩</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">格物轩</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学习、笔记与分享</p>
      <img class="custom-logo-image" src="/images/logo.png" alt="格物轩">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dr. Zhou"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Dr. Zhou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://g-d-zhou.github.io/year/07/15/crystalStructure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Dr. Zhou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="格物轩">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 格物轩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/year/07/15/crystalStructure/" class="post-title-link" itemprop="url">晶体学简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-15 13:41:21" itemprop="dateCreated datePublished" datetime="2024-07-15T13:41:21+08:00">2024-07-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-20 11:32:02" itemprop="dateModified" datetime="2024-07-20T11:32:02+08:00">2024-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E4%B8%8E%E5%87%9D%E8%81%9A%E6%80%81%E7%89%A9%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">量子力学与凝聚态物理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>“Introductory Solid State Physics with MATLAB Applications”
一书的学习笔记。</p>
<h2 id="晶体结构基础">晶体结构基础</h2>
<p>理想晶体被理解为结构单元在空间中的无限重复。</p>
<h3 id="晶格与基元">晶格与基元</h3>
<p>所有晶体的结构都可以用<strong>晶格</strong>来描述，每个格点上都存在<strong>原子群</strong>。我们做出如下定义：晶格在某一维度上是无限延伸的点阵列，其中每个点都被它近邻的点以相同的方式包围。
从定义上来看，晶格是一种数学抽象，每个格点被称为构成该晶格的点。
原子群被称为<strong>基元</strong>。基元可以是一个、两个、或多个原子。当基元在空间中按照晶格几何重复排列时，就形成了晶体。</p>
<h3 id="晶格平移矢量">晶格平移矢量</h3>
<p>在数学上，根据晶格平移矢量构建晶格。晶体中的一般矢量写为: <span
class="math display">\[\begin{equation}\label{equ-1-2-1}
    \vec{r}^{\prime}=\vec{r}+\vec{T}
\end{equation}\]</span> 以使得从<span
class="math inline">\(\vec{r}^{\prime}\)</span>看原子排列与从<span
class="math inline">\(\vec{r}\)</span>看时原子排列相同。 此处，<span
class="math inline">\(\vec{T}\)</span>是。</p>
<p><span class="math display">\[\begin{equation}\label{equ-1-2-2}
    \vec{T}=u_1 \vec{a}_1+u_2 \vec{a}_2+u_3 \vec{a}_3
\end{equation}\]</span> 或<strong>晶格平移矢量</strong>。其中，<span
class="math inline">\(u_1\)</span>、<span
class="math inline">\(u_2\)</span>、<span
class="math inline">\(u_3\)</span>是任意整数。而<span
class="math inline">\(\vec{a}_1\)</span>、<span
class="math inline">\(\vec{a}_2\)</span>、<span
class="math inline">\(\vec{a}_3\)</span>则是基本平移矢量。
我们将在下面讨论基本平移矢量的一个例子：基(平移)矢(量)。</p>
<h3 id="基矢">基矢</h3>
<p>考虑晶体中原子排列看起来相同的两个点<span
class="math inline">\(\vec{r}\)</span>和<span
class="math inline">\(\vec{r}^{\prime}\)</span>， 选择合适的<span
class="math inline">\(u_1\)</span>、<span
class="math inline">\(u_2\)</span>、<span
class="math inline">\(u_3\)</span> (整数)以满足方程<span
class="math inline">\(\ref{equ-1-2-1}\)</span>，则<span
class="math inline">\(\vec{a}_1\)</span>、<span
class="math inline">\(\vec{a}_2\)</span>、<span
class="math inline">\(\vec{a}_3\)</span> (由此创建晶胞)是基元。
这也意味着<span
class="math inline">\(\vec{T}\)</span>是真正的晶格平移矢量。
显然除基矢以外，存在任意矢量集使得方程<span
class="math inline">\(\ref{equ-1-2-1}\)</span>也成立。然而，基矢是空间中可以重复形成晶体结构的最小体积。
这里我们使用基矢所定义的基元晶轴来取代笛卡尔坐标，例如它们不必是正交的。
有时物理学家使用非基矢晶轴，当它们与晶体结构的对称性有更简单的关系时。
非基矢晶轴也可以构成晶体，但这些轴所围成的体积不一定是重复形成晶体结构的最小体积。</p>
<p>综上所述，为了描述一个晶体结构，我们需要以下几个方面：</p>
<ul>
<li>什么是晶格？</li>
<li>确定<span class="math inline">\(\vec{a}_1\)</span>、<span
class="math inline">\(\vec{a}_2\)</span>、<span
class="math inline">\(\vec{a}_3\)</span>的最优选择，无论它们是否是基矢。</li>
<li>什么是基元？</li>
</ul>
<p>上述的平移操作<span
class="math inline">\(\vec{T}\)</span>属于对称操作。有几种对称性操作：(a)平移，(b)转动，(c)反映，以及(d)其中两个或多个的复合操作。
对称性操作是重要的，因为对晶体结构进行这些操作之后，晶格保持不变。</p>
<h3
id="关于基元和晶体结构的进一步介绍">关于基元和晶体结构的进一步介绍</h3>
<p>如前所述，每个格点上都存在原子基元，每个基元在组成、排列和取向上都相同。
让我们考虑略有不同的矩形晶格。</p>
<p>正如我们所看到的，基元中的原子数可能不止一个。基元的中心原子<span
class="math inline">\(j\)</span>相对于相应格点的位置为： <span
class="math display">\[\begin{equation}\label{equ-1-2-3}
    \vec{r}_j=x_j \vec{a}_1+y_j \vec{a}_2+z_j \vec{a}_3
\end{equation}\]</span> 其中，<span
class="math inline">\(j=1,2,...\)</span>是基元中原子的个数。与方程<span
class="math inline">\(\ref{equ-1-2-2}\)</span>中的<span
class="math inline">\(u_1\)</span>、<span
class="math inline">\(u_2\)</span>以及<span
class="math inline">\(u_3\)</span>不同，<span
class="math inline">\(x_j\)</span>、<span
class="math inline">\(y_j\)</span>和<span
class="math inline">\(z_j\)</span>可能是非整数。</p>
<h3 id="原胞">原胞</h3>
<p>原胞是由基矢构成的最小体积(或二维中的体积，一维中的长度)。它是一种晶胞或单胞。一个晶胞可以通过合适的晶体对称性操作，进行自身的重复来填充所有空间。</p>
<p>选择基矢和原胞的方法有很多种。虽然原胞中的原子数可以不止一个，但对于给定的晶体结构，原胞中的原子数总是相同的。
由基矢定义的面积或体积是相等的，因为它们都定义了构建晶体的单元格。</p>
<p>在三维空间，平行六面体的体积为： <span
class="math display">\[\begin{equation}\label{equ-1-2-5}
    V=\left|\left(\vec{a}_1 \times \vec{a}_2\right) \cdot
\vec{a}_3\right|
\end{equation}\]</span>
为了数值计算，Python附录中描述了在该环境下进行<span
class="math inline">\(\times\)</span>和点乘操作的方法。</p>
<h3 id="维格纳-塞茨原胞">维格纳-塞茨原胞</h3>
<p>维格纳-塞茨方法是一种非常精确获取原胞(维格纳-塞茨原胞)的方法。具体方法如下：</p>
<ul>
<li>通过画线将给定格点与附近所有格点连接；</li>
<li>在这些直线的中点和法线处，画出新的直线(二维)或平面(三维)；</li>
<li>这样围成的最小面积(二维)或体积(三维)就是维格纳-赛茨原胞。</li>
</ul>
<h2 id="基本晶格类型">基本晶格类型</h2>
<p>晶格可以通过晶格对称操作与其自身重合。常见的操作是关于格点的旋转。可以发现晶格有一重(360
度)、二重(180 度)、三重(120 度)、四重(90 度)和六重(60
度)旋转，对应的旋转为<span class="math inline">\(2m\pi
/n\)</span>，其中<span
class="math inline">\(n\)</span>分别为1、2、3、4和6，<span
class="math inline">\(m\)</span>为整数。旋转轴用指数<span
class="math inline">\(n\)</span>表示。</p>
<p>格点群是对称操作的集合。将其应用于格点后晶体与其自身重合。我们有：</p>
<ul>
<li>关于轴的可能旋转( <span class="math inline">\(2\pi / n\)</span>
,其中<span class="math inline">\(n = 1 , 2 , 3 , 6\)</span>)，记作<span
class="math inline">\(C_n\)</span>旋转(C是cyclic的首字母)旋转；</li>
<li>关于通过一个格点的平面的镜面反映。此处，垂直于镜面的轴线符号发生变化(例如当镜面垂直于<span
class="math inline">\(z\)</span>轴时，<span class="math inline">\(z\to -
z\)</span>)。该操作被称为<span class="math inline">\(m\)</span>或<span
class="math inline">\(\sigma\)</span>操作(如(b)所示)；</li>
<li>反演，先旋转<span
class="math inline">\(\pi\)</span>后再关于垂直于旋转轴的平面反映(此处，若旋转轴为<span
class="math inline">\(z\)</span>轴，旋转导致<span
class="math inline">\(x\)</span>和<span
class="math inline">\(y\)</span>轴都发生了变号，反映又使得<span
class="math inline">\(z\)</span>轴变号)，总的效果是<span
class="math inline">\(\vec{r}\to -\vec{r}\)</span>。用<span
class="math inline">\(i\)</span> (反演)或<span
class="math inline">\(s_4\)</span>表示(以用于组合运算)；</li>
</ul>
<h3 id="笛卡尔坐标系下的晶体">笛卡尔坐标系下的晶体</h3>
<p>考虑<span class="math inline">\(x\)</span>-<span
class="math inline">\(y\)</span>-<span
class="math inline">\(z\)</span>正交坐标系，令矢量<span
class="math inline">\(\vec{a}\)</span>沿<span
class="math inline">\(x\)</span>方向，使得： <span
class="math display">\[\begin{equation}\label{equ-1-3-6}
\vec{a} = a \hat{x}
\end{equation}\]</span> 另外，令<span
class="math inline">\(\vec{b}\)</span>位于<span
class="math inline">\(x\)</span>-<span
class="math inline">\(y\)</span>平面上。</p>
<p>我们可将<span class="math inline">\(\vec{b}\)</span>写成如下形式：
<span class="math display">\[\begin{equation}\label{equ-1-3-7}
    \vec{b}=b_1 \hat{x}+b_2 \hat{y}=b \cos \gamma \hat{x}+b \sin \gamma
\hat{y}
\end{equation}\]</span> 接下令<span
class="math inline">\(\vec{c}\)</span>在任意方向，也就是： <span
class="math display">\[\begin{equation}\label{equ-1-3-8}
    \vec{c}=c_1 \hat{x}+c_2 \hat{y}+c_3 \hat{z}=c \cos \beta \hat{x}+c_2
\hat{y}+c_3 \hat{z}
\end{equation}\]</span> 因此，<span
class="math inline">\(\vec{a}\cdot\vec{c}=ac\cos\beta=a\hat{x}\cdot(c_1\hat{x}+c_2\hat{y}+c_3\hat{z})=ac_1\)</span>，
也就是， <span class="math display">\[\begin{equation}\label{equ-1-3-9}
c_1=c\cos\beta
\end{equation}\]</span> 类似的，我们有<span
class="math inline">\(\vec{b}\cdot\vec{c}=bc\cos\alpha=(b\cos\gamma\hat{x}+b\sin\gamma\hat{y})\cdot(c_1\hat{x}+c_2\hat{y}+c_3\hat{z})=bc_1\cos\gamma+bc_2\sin\gamma\)</span>。
利用方程<span class="math inline">\(\ref{equ-1-3-9}\)</span>可得： <span
class="math display">\[\begin{equation}\label{equ-1-3-10}
    \vec{b}\cdot\vec{c}=bc\cos\alpha=bc\cos\beta\cos\gamma+bc_2\sin\gamma
\end{equation}\]</span> 或 <span
class="math display">\[\begin{equation}\label{equ-1-3-11}
    c_2=\frac{c(\cos\alpha-\cos\beta\cos\gamma)}{\sin\gamma}
\end{equation}\]</span> 最后， <span
class="math display">\[\begin{equation}\label{equ-1-3-12-a}
    |\vec{c}|^2=c^2=c_1^2+c_2^2+c_3^2
\end{equation}\]</span> 利用方程<span
class="math inline">\(\ref{equ-1-3-9}\)</span>和方程<span
class="math inline">\(\ref{equ-1-3-11}\)</span>，我们有： <span
class="math display">\[\begin{equation}\label{equ-1-3-12-b}
    c_3=\sqrt{c^2-c_2^2-c_3^2}=c\sqrt{1-\cos^2\beta-(\frac{\cos\alpha-\cos\beta\cos\gamma}{\cos\gamma})}
\end{equation}\]</span> 注意到，我们可将方程<span
class="math inline">\(\ref{equ-1-3-6}\)</span>到方程<span
class="math inline">\(\ref{equ-1-3-8}\)</span>写成如下形式： <span
class="math display">\[\begin{equation}\label{equ-1-3-13-a}
    \left(
    \begin{array}{ccc}
        \vec{a} &amp; \vec{b} &amp; \vec{c}
    \end{array}
    \right) = \left(
                    \begin{array}{ccc}
                        \hat{x}&amp;\hat{y}&amp;\hat{z}
                    \end{array}
                    \right)  \left(
                                    \begin{array}{ccc}
                                        a&amp;b\cos\gamma&amp;c_1\\
                                        0&amp;b\sin\gamma&amp;c_2\\
                                        0&amp;0&amp;c_3
                                    \end{array}
                                    \right) = \left(
                                                    \begin{array}{ccc}
                                                        \hat{x}&amp;\hat{y}&amp;\hat{z}
                                                    \end{array}
                                                \right) C
\end{equation}\]</span> 其中，</p>
<p><span class="math display">\[\begin{equation}\label{equ-1-3-13-b}
    C\equiv\left(\begin{array}{ccc}a&amp;b\cos\gamma&amp;c_1\\
0&amp;b\sin\gamma&amp;c_2\\ 0&amp;0&amp;c_3\end{array}\right)
\end{equation}\]</span></p>
<p><span class="math inline">\(c_1\)</span>、<span
class="math inline">\(c_2\)</span>以及<span
class="math inline">\(c_3\)</span>则由方程<span
class="math inline">\(\ref{equ-1-3-9}\)</span>至<span
class="math inline">\(\ref{equ-1-3-12-a}\)</span>给出。</p>
<p>接下来，考虑给出晶体坐标中原子位置的矢量<span
class="math inline">\(\vec{t}\)</span>，如： <span
class="math display">\[\begin{equation}
    \vec{t}=u\vec{a}+\nu\vec{b}+w\vec{c}
\end{equation}\]</span></p>
<p>其中，<span class="math inline">\(u\)</span>、<span
class="math inline">\(v\)</span>和<span
class="math inline">\(w\)</span>是整数。问题出现了，这个原子相对于原点的笛卡尔坐标是什么？
重写<span class="math inline">\(\vec{t}\)</span>则可给出答案： <span
class="math display">\[\begin{equation}
    \vec{t}=x\hat{x}+y\hat{y}+z\hat{z}=u\vec{a}+\nu\vec{b}+w\vec{c}.
\end{equation}\]</span></p>
<p>借助方程<span
class="math inline">\(\ref{equ-1-3-13-a}\)</span>中行矢量<span
class="math inline">\((\begin{array}{ccc}\vec{a}&amp;\vec{b}&amp;\vec{c}\end{array})\)</span>的帮助，
上式变成： <span class="math display">\[\begin{equation}
    \vec{t}=(\begin{array}{ccc}\widehat{x}&amp;\widehat{y}&amp;\widehat{z}\end{array})\left(\begin{array}{c}x\\y\\z\end{array}\right)=(\begin{array}{ccc}\hat{x}&amp;\hat{y}&amp;\hat{z}\end{array})\boldsymbol{C}\left(\begin{array}{c}u\\\nu\\w\end{array}\right)
\end{equation}\]</span> 或者 <span
class="math display">\[\begin{equation}
    \left.\left(\begin{array}{c}x\\y\\z\end{array}\right.\right)=C\left(\begin{array}{c}u\\\nu\\w\end{array}\right)
\end{equation}\]</span>
这些是根据晶体轴的大小寻求的笛卡尔坐标大小。在这里，矩阵C被称为转换矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> cos, sin, sqrt, array, pi, shape, dot</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">angle2Radian</span>(<span class="params">angle</span>):</span><br><span class="line">    <span class="keyword">return</span> angle*pi/<span class="number">180</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">crystalAxes2Cartesian</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b, c, alpha, beta, gamma</span>):</span><br><span class="line">        self.a = a  <span class="comment"># 坐标轴单位为angstroms</span></span><br><span class="line">        self.b = b</span><br><span class="line">        self.c = c</span><br><span class="line">        self.alpha = angle2Radian(alpha)  <span class="comment"># 角度转弧度</span></span><br><span class="line">        self.beta = angle2Radian(beta)</span><br><span class="line">        self.gamma = angle2Radian(gamma)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义C矩阵</span></span><br><span class="line">        c1 = c*cos(self.beta)</span><br><span class="line">        c2 = c*(cos(self.alpha) - cos(self.gamma)*cos(self.beta)/sin(self.gamma))</span><br><span class="line">        c3 = sqrt(c**<span class="number">2</span> - c1**<span class="number">2</span> - c2**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.C = array([</span><br><span class="line">                     [a, b*cos(self.gamma),   c1],</span><br><span class="line">                     [<span class="number">0</span>, b*sin(self.gamma),   c2],</span><br><span class="line">                     [<span class="number">0</span>, <span class="number">0</span>,              c3]</span><br><span class="line">                     ])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">self, u, v, w</span>):</span><br><span class="line">        vector = array([u,v,w])</span><br><span class="line">        <span class="keyword">return</span> dot(self.C, vector)</span><br></pre></td></tr></table></figure>
<h2 id="原子级表面微观形貌">原子级表面微观形貌</h2>
<p>STM技术是由Gerd Binnig与Heinrich
Rohrer共同开发的，他们因这一成就在1986年获得了诺贝尔奖。
在这种技术中，会在一个金属探针和感兴趣的样品之间施加一个恒定的偏压电压。当探针尖端在表面移动时，
样品电子会通过间隙（宽度为<span
class="math inline">\(d\)</span>）从样品隧穿到探针。
隧穿电流与量子力学隧穿概率成正比：<span
class="math inline">\(I\sim|T|\)</span>。 <span
class="math display">\[\begin{equation}\label{equ-1-7-19a}
    T=\frac{|\psi_{transmitted}|^2}{|\psi_{incident}|^2}\sim\exp(-2kd)
\end{equation}\]</span> 其中， <span
class="math display">\[\begin{equation}
    k=\sqrt{\frac{2m}{\hbar^2}(W-E)}
\end{equation}\]</span></p>
<p>以<span class="math inline">\(m\)</span>表示电子的质量；<span
class="math inline">\(E\)</span>代表电子的动能；而<span
class="math inline">\(W\)</span>则是样品电子的功函数（跃过能隙所需的最小能量）。
电子的动能可以与所施加的电压相关联，即<span
class="math inline">\(E=e\phi_{app}\)</span>；通过分析隧穿电流，可以对晶体样品的表面结构进行成像。</p>
<p>对于这个模型，电子会经历量子力学隧穿。在一维情况下，如果我们有一个高度为<span
class="math inline">\(V = V_0\)</span>、宽度为<span
class="math inline">\(a\)</span>的量子力学势垒，携带能量<span
class="math inline">\(E\)</span>的电子具有一个通过障碍的概率，这个概率由下式给出：
<span class="math display">\[\begin{equation} \label{equ-1-7-20a}
    T=\frac{|\psi_{transmitted}|^2}{|\psi_{incident}|^2}=\frac1{1+D\sinh^2(\alpha
a)}
\end{equation}\]</span> 其中， <span
class="math display">\[\begin{equation}
    D=\frac{V_0^2}{4E(V_0-E)}
\end{equation}\]</span> 以及， <span
class="math display">\[\begin{equation}
    \alpha=\sqrt{\frac{2m}{\hbar^2}(V_0-E)}
\end{equation}\]</span></p>
<p>在<span class="math inline">\(\alpha
a\gg1\)</span>的极限下，并令<span class="math inline">\(V_0 =
W\)</span>。方程<span
class="math inline">\(\ref{equ-1-7-20a}\)</span>变成： <span
class="math display">\[\begin{equation}
    T=\frac{|\psi_{transmitted}|^2}{|\psi_{incident}|^2}\approx
T_0\exp(-2kd)
\end{equation}\]</span> 其中， <span
class="math display">\[\begin{equation}
    T_0=\frac{16E(W-E)}{W^2}
\end{equation}\]</span></p>
<p>通过粗略地令<span class="math inline">\(T_0\sim
1\)</span>，则上面的方程又变回了方程<span
class="math inline">\(\ref{equ-1-7-19a}\)</span>。 让我们用方程<span
class="math inline">\(\ref{equ-1-7-19a}\)</span>做一个简单的数值模拟。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.constants <span class="keyword">as</span> C</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">hbC = C.hbar*C.c*<span class="number">1E9</span>/C.e    <span class="comment"># hbar*C in eV nm</span></span><br><span class="line">mc2 = C.m_e*C.c**<span class="number">2</span>/C.e  <span class="comment"># rest mass of the electron mc^2 in eV</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这里，我们采用近似的隧穿公式，及振幅约等于1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tunnel0</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, V0, d</span>): <span class="comment"># V0 功函数</span></span><br><span class="line">        self.V0 = V0</span><br><span class="line">        self.Va = np.arange(<span class="number">0</span>, self.V0 + self.V0/<span class="number">100.0</span>, self.V0/<span class="number">100.0</span>)     <span class="comment"># applied voltage in electron volts</span></span><br><span class="line">        self.E = self.Va</span><br><span class="line">        </span><br><span class="line">        self.k = np.sqrt(<span class="number">2</span>*mc2*(self.V0-self.E)/hbC**<span class="number">2</span>)</span><br><span class="line">        self.d = d      <span class="comment"># gap width in nm</span></span><br><span class="line">        self.T1_approx = np.exp(-<span class="number">2.0</span>*self.k*self.d) <span class="comment"># approximation</span></span><br><span class="line">        </span><br><span class="line">        self.plotTvsE()</span><br><span class="line">        self.plotTvsa()</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 显示图形</span></span><br><span class="line">        plt.show()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plotTvsE</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建子图</span></span><br><span class="line">        plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        plt.plot(self.E, self.T1_approx, <span class="string">&#x27;k--&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">        plt.axis([<span class="number">0</span>, <span class="number">1.1</span>*self.V0, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">        plt.text(<span class="number">0.1</span>, <span class="number">0.8</span>, <span class="string">r&#x27;$T(E)=e^&#123;-2.0k(E)d&#125;$&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;E (eV)&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;T&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">        plt.title(<span class="string">&#x27;T vs E&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plotTvsa</span>(<span class="params">self</span>):</span><br><span class="line">        s = np.arange(<span class="number">0</span>, self.d+self.d/<span class="number">25</span>, self.d/<span class="number">25</span>)</span><br><span class="line">        EE = <span class="number">0.5</span>*self.V0</span><br><span class="line">        k = np.sqrt(<span class="number">2</span>*mc2*(self.V0-EE)/hbC**<span class="number">2</span>)</span><br><span class="line">        T2_approx = np.exp(-<span class="number">2</span>*k*s)</span><br><span class="line">        </span><br><span class="line">        plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        plt.plot(s, T2_approx, <span class="string">&#x27;k--&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">        plt.axis([<span class="number">0</span>, <span class="number">1.1</span>*self.d, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">        plt.text(self.d/<span class="number">4</span>, <span class="number">0.4</span>, <span class="string">r&#x27;$T(d)=e^&#123;-2.0kd&#125;$&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;d (nm)&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;T&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">        plt.title(<span class="string">&#x27;T vs a&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">tunnel = tunnel0(<span class="number">4.3</span>, <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://g-d-zhou.github.io/year/05/19/groundBox/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Dr. Zhou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="格物轩">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 格物轩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/year/05/19/groundBox/" class="post-title-link" itemprop="url">接地BOX</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-19 19:44:20" itemprop="dateCreated datePublished" datetime="2024-05-19T19:44:20+08:00">2024-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-30 11:42:07" itemprop="dateModified" datetime="2024-08-30T11:42:07+08:00">2024-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BD%8E%E6%B8%A9%E7%AD%89%E7%A6%BB%E5%AD%90%E4%BD%93%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">低温等离子体理论与应用</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>"Plasma Simulations by Example"一书的学习笔记。</p>
<h2 id="简介">简介</h2>
<p>模拟描述：等离子体被限制在一个接地的box内部，该Box接地且壁具有反射性。模拟运用静电PIC方法，并且是全动力学的。
这意味着离子和电子都被当作粒子来处理。虽然该模拟并没有那么令人兴奋，但它实际上会导致有趣的振荡现象。
还能够构建后续所有代码使用的基础框架。</p>
<h2 id="模拟设置">模拟设置</h2>
<p>模拟区域如下图所示：边长为0.2 m的立方体盒子，其空间范围从(-0.1, -0.1,
0)延伸到(0.1, 0.1, 0.2)。 区域被划分为一个<span
class="math inline">\(21\times 21\times
21\)</span>的均匀笛卡尔网格。模拟区域中初始均匀离子密度<span
class="math inline">\(n_i = 10^11 m^{-3}\)</span>。
电子密度与离子相同，但电子只占据<span
class="math inline">\([-0.1,0)\times[-0.1,0)\times[0,0.1)\)</span>，也就是说：
<span class="math display">\[\begin{equation}
    n_e(\vec{x})=\left\{\begin{array}{ll}n_i&amp;\quad;\vec{x}\in[\vec{x}_0,\vec{x}_c)\\0&amp;\quad;\mathrm{otherwise}\end{array}\right.
\end{equation}\]</span></p>
<img src="/images/Lubos/latexImage_b85e56823794ae5c05376022819e5d8a.png" class="" width="400" title="Figure 2.1: Computational domain for the plasma in a box example. Electrons initially occupy only the shaded region.">
<p>这个区域在图中用灰色框表示。这种设定明显是不稳定的。剩下的七个八分之一区域充满了净正电荷。可以预料，电子会试图进入这些区域以减少局部电荷分离。在这样做的过程中，它们会overshoot离子。在无限广阔的领域中，电子最终会返回，因为它们被困在一个类似于《<a href="/year/01/11/plasmaFundamentals/" title="等离子体模拟基础">等离子体模拟基础</a>》所研究的势阱中。我们通过使壁具有反射性来近似这种行为。
0 V的Dirichlet边界条件被设定在所有边界上。</p>
<h3 id="赝代码">赝代码</h3>
<p>代码是分块编写的。作者喜欢从一个仅有基本框架的应用程序开始，
这个框架包含了稍后要实现的功能hook。然后这些hook会逐一得到充实。初始的代码可能类似于如下所示：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *args[])</span></span>&#123;</span><br><span class="line">    <span class="function">World <span class="title">world</span> <span class="params">(/∗ . . . ∗/)</span></span>;   <span class="comment">// 初始化计算域</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Species <span class="title">ions</span> <span class="params">(<span class="comment">/*...*/</span> )</span></span>;    <span class="comment">// 初始化离子secies</span></span><br><span class="line">    <span class="function">Species <span class="title">electrons</span> <span class="params">(<span class="comment">/*...*/</span> )</span></span>;  <span class="comment">// 初始化电子secies</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SolvePotential</span>();   <span class="comment">// 得到初始化的电势</span></span><br><span class="line">    <span class="built_in">ComputeElectricField</span>();  <span class="comment">// 差分电势</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">GenerateParticles</span>();  <span class="comment">// 生成初始粒子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">for</span> (ts=<span class="number">0</span>; ts&lt;num_ts; ts++)&#123;</span><br><span class="line">        <span class="built_in">ComputeChargeDensity</span>();  <span class="comment">// 计算电荷密度</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">SolvePotential</span>();   <span class="comment">// 求解电势</span></span><br><span class="line">        <span class="built_in">ComputeElectricField</span>();  <span class="comment">// 计算电场</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">IntegrateVelocity</span>();  <span class="comment">// 更新粒子速度</span></span><br><span class="line">        <span class="built_in">IntegratePosition</span>();  <span class="comment">// 更新粒子位置</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">RunTimeDiagnostics</span>();   <span class="comment">// 输出一些诊断信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OutputResults</span>();   <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// normal exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们首先定义一个名为World的变量，它封装了关于计算域的信息。接着，我们创建对象来存储离子和电子种类的数据。
这个对象属于Species类型，它存储了所有粒子共有的信息，比如它们的质量或电荷。
它还存储每个粒子的位置和速度。接下来，我们计算初始电场。这个电场对于Leapfrog方法中回溯粒子速度是必需的。
然后我们加载粒子。代码随后进入主循环。通常，我们会为预设的步数 num_ts
运行模拟。每一步都包括首先更新粒子的速度。 <span
class="math display">\[\begin{equation}
    \frac{d\vec{v}}{dt}=\frac
qm\left(\vec{E}+\vec{v}\times\vec{B}\right)
\end{equation}\]</span> 在没有磁场的情况下，这会简化为： <span
class="math display">\[\begin{equation}
    \frac{d\vec{v}}{dt}=\frac qm\vec{E}
\end{equation}\]</span></p>
<p>粒子的位置根据： <span class="math display">\[\begin{equation}
    \frac{d\vec{x}}{dt}=\vec{v}
\end{equation}\]</span></p>
<p>这些新位置随后被用来通过插值计算电荷密度<span
class="math inline">\(\rho\)</span>，将其位置映射到网格上。然后求解泊松方程:
<span class="math display">\[\begin{equation}
    \nabla^2\phi=-\frac\rho{\epsilon_0}
\end{equation}\]</span></p>
<p>电场是通过差分电势获得的： <span
class="math display">\[\begin{equation}
    \vec{E}=-\nabla\phi
\end{equation}\]</span></p>
<p>最后，我们添加了一些屏幕和文件诊断工具，以揭示模拟的进展状况。就是这样！循环会持续迭代，直到达到所需的时间步数。</p>
<h2 id="world对象">World对象</h2>
<p>首先，需要建立一个用于存储网格几何形状和基于节点值的容器。这个例子中使用的笛卡尔网格如下图所示。
由于其规则的结构，只需要九个量就能完全描述这个网格：原点的三个浮点值<span
class="math inline">\(x_0\)</span>、<span
class="math inline">\(y_0\)</span>、<span
class="math inline">\(z_0\)</span>；在<span
class="math inline">\(x\)</span>、<span
class="math inline">\(y\)</span>和<span
class="math inline">\(z\)</span>方向上的单元间距三个值：<span
class="math inline">\(\Delta x\)</span>、<span
class="math inline">\(\Delta y\)</span>和<span
class="math inline">\(\Delta z\)</span>；以及节点计数<span
class="math inline">\(ni\)</span>、<span
class="math inline">\(nj\)</span>和<span
class="math inline">\(nk\)</span>。以向量形式表示为<span
class="math inline">\(\vec{x}_0\)</span>、<span
class="math inline">\(\Delta\vec{h}\)</span>以及<span
class="math inline">\(\vec{nn}\)</span>。这些信息被存储在一个名为World的对象中。一个简单的版本是：</p>
<img src="/images/Lubos/latexImage_ec713bea4b512c23a2bce33df2f22a70.png" class="" width="400" title="Figure 2.2: Cartesian mesh used in this example.">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">World</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> x0[<span class="number">3</span>];   <span class="comment">// 网格原点</span></span><br><span class="line">    <span class="type">double</span> dh[<span class="number">3</span>];   <span class="comment">// cell spacing in x, y, z</span></span><br><span class="line">    <span class="type">int</span> nn[<span class="number">3</span>];     <span class="comment">// number of cells in x, y, z</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种数据结构需要外部代码直接操作数组。例如， <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    World world;</span><br><span class="line">    world.nn[<span class="number">0</span>] = <span class="number">21</span>;   <span class="comment">// 设置节点数</span></span><br><span class="line">    world.nn[<span class="number">1</span>] = <span class="number">21</span>;</span><br><span class="line">    world.nn[<span class="number">2</span>] = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">    world.x0[<span class="number">0</span>] = <span class="number">-0.1</span>; <span class="comment">// set origin</span></span><br><span class="line">    world.x0[<span class="number">1</span>] = <span class="number">-0.1</span>;</span><br><span class="line">    world.x0[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    world.dh[<span class="number">0</span>] = <span class="number">0.01</span>; <span class="comment">// set mesh spacing</span></span><br><span class="line">    world.dh[<span class="number">1</span>] = <span class="number">0.01</span>;</span><br><span class="line">    world.dh[<span class="number">2</span>] = <span class="number">0.01</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="构造函数constructor">构造函数(constructor)</h3>
<p>这种"C"风格的方法并不理想，因为它没有提供任何安全检查。
一旦相关数组初始化后，主函数中没有任何可以阻止修改变量(holding网格数量)的代码。这可能会导致内存损坏。C++提供了两种控制数据访问的工具。
首先，我们可以将类的成员定义为私有或受保护的，这阻止了类外部的任何代码访问它们。
或者，我们可以定义一个称为构造函数的特殊函数，每当对象初始化时都会自动调用。
它被定义为一个与类名相同且没有返回类型的函数。构造器使得我们可以初始化常量字段。这些成员可以在类外部读取，但一旦设置，它们的值就不能改变。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">World</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">    World(<span class="type">int</span> ni, <span class="type">int</span> nj, <span class="type">int</span> nk);  <span class="comment">// constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置网格跨度，同时重新计算单元间距</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setExtents</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> z1, <span class="type">double</span> x2, <span class="type">double</span> y2, <span class="type">double</span> z2)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> nn[<span class="number">3</span>];     <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ni, nj, nk;  <span class="comment">// number of nodes in individual variables</span></span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    <span class="type">double</span> x0[<span class="number">3</span>];   <span class="comment">// 网格原点</span></span><br><span class="line">    <span class="type">double</span> dh[<span class="number">3</span>];   <span class="comment">// cell spacing in x, y, z</span></span><br><span class="line">    <span class="type">double</span> xm[<span class="number">3</span>];   <span class="comment">// 网格最大值</span></span><br><span class="line">    <span class="type">double</span> xc[<span class="number">3</span>];   <span class="comment">// 网格中心</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<div class="note "><p>protected 访问修饰符控制类成员的访问权限，位于 protected
下面的内容具有以下特性：</p>
<p>类内：可以在类的内部访问，如类的成员函数和友元函数。
派生类：可以在继承该类的派生类中访问。
外部访问：不能直接通过类的实例访问（与 private 类似）。</p>
</div>
<p>除了构造函数之外，我们还添加了一些额外的变量。其中包括“max
bound”，这是原点在对角线另一端相对应的点：<span
class="math inline">\(\vec{x_m} = \vec{x_0} +\Delta \vec{h}\cdot
(\vec{nn}-1)\)</span>。我们还添加了网格中心<span
class="math inline">\(\vec{x_c}=(\vec{x_0}+\vec{x_m})/2\)</span>。
非恒定数据被移动到一个受保护的区域，以防止外部访问。成员函数<code>setExtents</code>设置了网格的边界框，并且也计算了单元格的大小。主函数的调用现在如下所示。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">World <span class="title">world</span><span class="params">(<span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line">    world.<span class="built_in">setExtents</span>(<span class="number">-0.1</span>, <span class="number">-0.1</span>, <span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="声明与实现">声明与实现</h3>
<p>至今我们只声明了类函数，但尚未实现它们。这可以通过在声明时提供函数体来完成，对于应该内联的小型函数来说，这确实是正确的选择。内联消除了与函数调用相关的开销。但是直接在类定义中包含代码有一些缺点。首先，或许算是一个小缺点，它会使代码更加杂乱。第二个原因与构建过程有关。C++通过三个步骤生成应用程序。首先，预处理器检查以#开头的特殊宏。其中一个，#include，允许我们导入另一个文件的内容。接下来，编译器生成实际的机器代码。为了调用函数或实例化类，编译器需要知道对象原型。原型告诉编译器函数期望的参数类型和返回类型是什么。
相似的信息由如上面所示的类声明提供。它允许编译器在实际上不知道成员函数具体做什么的情况下，构建和使用类型为World的对象。最后，链接器会查找函数体并确保它们在需要时可用。</p>
<h3 id="多个文件">多个文件</h3>
<p>我们可以将程序拆分为多个文件，比如Main.cpp、Output.cpp、Solver.cpp、Species.cpp和World.cpp。这些文件随后可以通过构建过程包含进来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -O2 Main.cpp Output.cpp Solver.cpp Species.cpp World.cpp -o ch2</span><br></pre></td></tr></table></figure>
<div class="note "><p>-O2
是优化选项中的一个，表示中等程度优化。其作用是启用一系列优化，以提升生成的可执行程序的性能，而不会显著增加编译时间。在大多数情况下，这个优化级别可以显著提高程序性能，而且不会出现重大的代码错误或临时异常。详细来说，-O2启用的优化包括但不限于：</p>
<ul>
<li>消除公共子表达式：检测和删除表达式中可以重复使用的部分，减少冗余计算。</li>
<li>删除死代码：去掉程序中不会被执行的代码。</li>
<li>代码内联：将小函数的代码直接插入调用处，以减少函数调用开销。</li>
<li>减少函数调用开销：通过转化一些递归为迭代、内联扩展等手段。</li>
<li>回合优化：多次遍历和优化代码的特定部分，以获取更高的性能提升。</li>
</ul>
</div>
<p>如果所有的.cpp文件均在一个文件夹，则可写为： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ *.cpp -o ch2</span><br></pre></td></tr></table></figure>
这个指令会编译并链接这五个文件，生成一个可执行程序ch2。另一种选择是，我们可以通过添加-c标志来编译文件，但不进行链接。
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -c Main.cpp Output.cpp Solver.cpp Species.cpp World.cpp </span><br></pre></td></tr></table></figure> 也可以： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -c *.cpp</span><br></pre></td></tr></table></figure></p>
<p>这个调用的输出则是五个对象文件：Main.o, Output.o, Solver.o, Species.o
和 World.o。然后我们将它们链接起来： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ Main.o Output.o Solver.o Species.o World.o -o ch2 </span><br></pre></td></tr></table></figure>
这与最初的编译和链接命令相同，只是现在输入文件是.o的对象文件。</p>
<p>假设我们只修改了在Main.cpp中定义的主要循环代码，其他四个文件无需重新编译。我们可以使用构建工具来重新构建这个应用：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -c Main.cpp</span><br><span class="line">$ g++ *.o -o ch2</span><br></pre></td></tr></table></figure></p>
<p>这虽然对于在这里开发的小型程序可能只是微不足道的时间节省，
但对于生产应用来说，有时从零开始编译可能需要花费数小时。make工具被用来通过自动确定哪些文件需要重新构建来自动化这一过程。
通过将函数体与其定义分离，我们减少了需要重新编译的代码量。我们在World.h头文件中编写World的定义，并在World.cpp源文件中包含适当的实现。其他需要使用World对象的文件则通过如下方法使用：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;World.h&quot;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这些函数在World.cpp中的代码改变时无需重新编译。函数实现是通过在函数名称前加上类的名字来指定的。例如，
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">World::setExtents</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2, <span class="type">double</span> z2)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可能需要将函数定义与其实现分开的另一个原因是，假设我们有两个类A和B，每个类都需要调用另一个类的功能：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;    <span class="comment">// B是后面要定义的类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(B &amp;b)</span></span>&#123;b.<span class="built_in">doSomething</span>();&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(A &amp;a)</span></span>&#123;a.<span class="built_in">doSomething</span>();&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    a.<span class="built_in">run</span>(b);</span><br><span class="line">    b.<span class="built_in">run</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>这段代码无法编译，因为当编译器运行A类中的(B
&amp;b)函数时，它还不知道B类有一个名为doSomething()的成员方法。尽管在第1行使用前向声明（class
B）告知编译器B是一个类，但这种情况依然存在。交换类的顺序并无助于解决问题，因为两个类互相依赖。但通过将实现与定义分开，我们可以使代码成功编译。我们甚至不需要使用多个文件:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;        <span class="comment">// B是后面要定义的类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(B &amp;b)</span></span>&#123;b.<span class="built_in">doSomething</span>();&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(A &amp;a)</span></span>&#123;a.<span class="built_in">doSomething</span>();&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::run</span><span class="params">(B &amp;b)</span></span>&#123;b.<span class="built_in">doSomething</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::run</span><span class="params">(A &amp;a)</span></span>&#123;a.<span class="built_in">doSomething</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    a.<span class="built_in">run</span>(b);</span><br><span class="line">    b.<span class="built_in">run</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子可能显得有些人为编造，但实际上在实践中确实会出现。在我们的例子中，创建物种对象时需要一个世界参照。然而，我们也在世界函数中使用物种来计算电荷密度。为了避免这种循环引用，这个函数的主体不得不被移出头文件。</p>
<h3 id="头文件保护">头文件保护</h3>
<p>最后，因为头文件可以包含其他头文件，有可能不经意间同一个文件被多次包含。这可能导致编译错误。为了防止这种情况，我们在头文件中使用头文件保护（header
guard）来包裹内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WORLD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WORLD_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">World</span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这个构造利用预处理器来检查当前编译单元中是否已经定义了宏_WORLD_H。如果没有定义，我们就定义它，然后包含文件内容。否则，不包含任何内容。即使在打印的片段中未显示，这个构造也会用在所有示例的头文件中。</p>
<h3 id="实施">实施</h3>
<p>考虑到这一点，我们继续实现World类。我们在World.cpp中添加以下代码：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constructor</span></span><br><span class="line">World::<span class="built_in">World</span>(<span class="type">int</span> ni, <span class="type">int</span> nj, <span class="type">int</span> nk) : ni&#123;ni&#125;, nj&#123;nj&#125;, nk&#123;nk&#125;, nn&#123;ni, nj, nk&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置网格扩展并计算单元格间距</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">World::setExtents</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> z1, <span class="type">double</span> x2, <span class="type">double</span> y2, <span class="type">double</span> z2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置起点(xmin)</span></span><br><span class="line">    x0[<span class="number">0</span>] = x1; x0[<span class="number">1</span>] = y1; x0[<span class="number">2</span>] = z1;</span><br><span class="line">    <span class="comment">// 「对角线 - 反对角线 (xmax)」</span></span><br><span class="line">    xm[<span class="number">0</span>] = x2; xm[<span class="number">1</span>] = y2; xm[<span class="number">2</span>] = z2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过将长度除以单元格数量计算间距</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        dh[i] = (xm[i] - x0[i])/(nn[i]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算中心</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        xc[i] = <span class="number">0.5</span>*(x0[i]+xm[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造函数通过初始化列表来设置类的常量成员。
大括号前的变量是类的成员，而里面的部分则是赋予它的值。
这些通常作为构造函数的参数。允许类成员和参数使用相同的名字。
然而，所有类都包含一个特殊的指针称为this，可以用来显式地引用类的成员。
通过这种方式使用<code>this-&gt;ni=ni;</code>可以作为将类成员设置为与局部变量（或函数参数）相同值的另一种方法，前提是这两个变量同名。
由于构造函数除了初始化数据之外没有其他操作，所以我们保持其body为空。</p>
<p><code>setExtents</code> 函数首先为<span
class="math inline">\(\vec{x}_0\)</span> 和 <span
class="math inline">\(\vec{x}_m\)</span>向量设置值。这种初始化也可以作为构造函数的一部分，但是会导致函数参数过多。将调用分开使得代码更易于阅读，至少在我看来是这样。下一步，我们计算网格间距:
<span class="math display">\[\begin{equation}
    \Delta x=\frac{x_m-x_0}{n_i-1}
\end{equation}\]</span></p>
<p>这里，<span
class="math inline">\(n_i\)</span>表示沿x方向的节点数量，<span
class="math inline">\(n_i - 1\)</span>则是相应的单元格计数。
我们还设置了网格质心，<span class="math inline">\(\vec{x}c = (\vec{x}_m
+
\vec{x}_0)/2\)</span>。质心仅仅用于加载电子群体。最后，我们调用一个函数来计算节点体积。这个函数尚未实现。</p>
<h3 id="网格分辨率">网格分辨率</h3>
<p>在继续之前，我们应该指出cell间距不能完全随意设定。等离子体在比德拜长度更小的尺度上才不呈中性:
<span class="math display">\[\begin{equation}
    \lambda_D=\sqrt{\frac{\epsilon_0k_BT_e}{n_eq_e^2}}
\end{equation}\]</span> 其中，<span
class="math inline">\(k_B\)</span>是玻尔兹曼常量。该方程忽略了离子贡献，但由于<span
class="math inline">\(T_i \ll T_e\)</span>，通常我们会忽略它。
既然我们关注的是模拟电子和离子的混合，就需要解决局部电荷分离的问题。
因此，我们需要cell体积小于德拜球的体积: <span
class="math display">\[\begin{equation}
    (\Delta x\Delta y\Delta z)&lt;\frac43\pi\lambda_D^3
\end{equation}\]</span> 或者，通常会要求: <span
class="math display">\[\begin{equation}
    \max(\Delta x,\Delta y,\Delta z)&lt;\lambda_D
\end{equation}\]</span></p>
<p>在我们的示例中，模拟前计算德拜长度并非易事，因为离子和电子都是冷加载的，<span
class="math inline">\(T_e = T_i = 0\)</span>。
然而，如后续章节(“结果”)所示，电子的总系统动能被限制在<span
class="math inline">\(KE &lt; 2\times 10^{-11}\)</span> J。
考虑到该系统模拟了<span
class="math inline">\(10^8\)</span>个电子，我们可以计算出每个电子的动能为<span
class="math inline">\(2\times 10^{-19}\)</span> J。
对于麦克斯韦速度分布，我们也有<span class="math inline">\(KE =
(3/2)kT\)</span>。因此，如果我们假定电子是麦克斯韦分布的，$T_e $ K。
通常以电子伏特来表示温度，1 eV <span
class="math inline">\(=(q/k_B)\approx 11604.5\)</span> K。因此，$T_e =
0.83 $ eV。 再加上<span class="math inline">\(n_e =
10^{11}\)</span>，我们有<span class="math inline">\(\lambda_D =
0.0214\)</span> m。对于<span class="math inline">\(20\times 20\times
20\)</span>的网格， <span class="math inline">\(\Delta
x=(x_m-x_0)/n_i=(0.2\text{m})/20=0.01\text{m}\)</span>
我们的网格足够精细，能够解析德拜长度。如果有疑问，可以通过在不同网格分辨率下运行模拟并比较结果来进行网格收敛性研究。此外，根据我的经验，除非满足网格分辨率要求，否则高斯-赛德尔泊松求解器无法收敛。场求解器的发散是需要更细网格的一个好指示器。</p>
<h2 id="场对象">场对象</h2>
<p>我们现在已经完全定义了网格几何形状，但是这个网格中不包含任何数据。
在第一章中，我们使用了std::vector来存储一维数组，包含ni个条目。遗憾的是，C++标准库中并没有与之对应的三维容器，所以我们需要创建自己的数据结构。我们将这个对象称为Field。这一部分将详细讲述实现的细节。接下来的内容可能会稍显枯燥，所以你可以自由地跳过这一节。如果你选择跳过，只需了解Field存储三维双精度数据。我们还实现了FieldI，用于存储整数，以及Field3，用于存储三元向量。
沿着这条路，我们还定义了一个用于存储三元组浮点数和整型数的容器 double3
和 int3。 这些对象使用操作符重载来支持常见的数学运算。例如，不这样实现：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a[<span class="number">3</span>], b[<span class="number">3</span>], c[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    c[i] = a[<span class="number">3</span>] + <span class="number">5</span>*b[i];   <span class="comment">//在循环中计算每一个维度</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以简单写为： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double3 a, b;</span><br><span class="line">double3 c = a+<span class="number">5</span>*b;  <span class="comment">// use overloaded * 以及 + 算符</span></span><br></pre></td></tr></table></figure></p>
<p>同样地，我们可以在整个3D场中执行操作，例如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field a, b;</span><br><span class="line">Field c = a + <span class="number">5</span>*b;  \\  every c[i][j][k] = a[i][j][k] + <span class="number">5</span>*b[i][j][k]</span><br></pre></td></tr></table></figure></p>
<h3 id="存储分配">存储分配</h3>
<h4 id="c">C++</h4>
<p>Field容器的主要目的是存储网格节点或cell中心数据。我们希望能够访问<span
class="math inline">\(\phi\)</span>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Field <span class="title">phi</span><span class="params">(ni, nj, nk)</span></span>;  <span class="comment">// initialize memory for ni*nj*nk values</span></span><br><span class="line">phi[i][j][k] = some_value</span><br></pre></td></tr></table></figure>
<p>C++与其他语言，如Java不同，它不原生支持多维数组的分配。这类数组通常是通过创建指针数组来近似的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> **v = <span class="keyword">new</span> <span class="type">double</span>*[<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>分配一个包含五个双精度数据指针的数组。每个条目，比如v[3]，是一个指针，可以指向任意的内存位置。
我们令： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[<span class="number">3</span>] = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p>现在，v[3] 指向一个包含10个双精度浮点数的数组。我们通过 v[3][0] 到
v[3][9] 来访问这些值。
分配三维数据也类似。我们首先创建一个指向指针的数组。然后，每个条目被设置为指向一个指向双精度浮点数的指针数组，每个这样的指针又分配给一个双精度浮点数的数组。看起来是这样的：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Field.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span>&#123;</span></span><br><span class="line">    pubic:</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    Field (<span class="type">int</span> ni, <span class="type">int</span> nj, <span class="type">int</span> nk) : ni&#123;ni&#125;, nj&#123;nj&#125;, nk&#123;nk&#125;&#123;</span><br><span class="line">        data = new <span class="type">double</span>**[ni];    <span class="comment">// ni pointers to pointers</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ni; i++)&#123;</span><br><span class="line">            data[i] = new <span class="type">double</span>*[nj];  <span class="comment">// nj pointers to doubles</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nj; j++)</span><br><span class="line">                data[i][j] = new <span class="type">double</span> [nk];   <span class="comment">// nk double</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// destructor，释放内存in reverse order</span></span><br><span class="line">    ~Field()&#123;</span><br><span class="line">        <span class="keyword">if</span> (data==nullptr) <span class="keyword">return</span>;  <span class="comment">// 返回如果分配了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>；i&lt;ni; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nj; j++)&#123;   <span class="comment">// 释放内存in reverse order</span></span><br><span class="line">                delete data[i][j]; </span><br><span class="line">                &#125;</span><br><span class="line">            delete data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        delete[]    data;</span><br><span class="line">        data = nullptr; <span class="comment">// mark as free</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ni, nj, nk;   <span class="comment">// number of nodes</span></span><br><span class="line">    protected:</span><br><span class="line">        <span class="type">double</span> ***data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>析构函数是一种特殊函数，在对象的作用域结束时会自动调用。我们用它来释放内存。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Field <span class="title">phi</span><span class="params">(<span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>)</span></span>;  <span class="comment">// calls Field constructor</span></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">// Field destructor called here automatically</span></span><br></pre></td></tr></table></figure></p>
<h4 id="python">python</h4>
<p>对于python而言，内存管理由垃圾收集器处理，通常不需要手动释放内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Field</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ni, nj, nk</span>):</span><br><span class="line">        self.ni = ni</span><br><span class="line">        self.nj = nj</span><br><span class="line">        self.nk = nk</span><br><span class="line">        <span class="comment"># Initialize the 3D array using numpy</span></span><br><span class="line">        self.data = np.zeros((ni, nj, nk), dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># 测试用例</span></span><br><span class="line">f = Field(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(f.data)</span><br></pre></td></tr></table></figure>
<h4 id="julia">Julia</h4>
<p>在 Julia
中，我们不需要显式地管理内存，垃圾收集器会自动处理内存释放。因此，不需要定义析构函数，类似
Python 的内存管理。 <figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> FieldModule</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Field</span><br><span class="line">    ni::<span class="built_in">Int</span></span><br><span class="line">    nj::<span class="built_in">Int</span></span><br><span class="line">    nk::<span class="built_in">Int</span></span><br><span class="line">    data::<span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construction function</span></span><br><span class="line">    <span class="keyword">function</span> Field(ni::<span class="built_in">Int</span>, nj::<span class="built_in">Int</span>, nk::<span class="built_in">Int</span>)</span><br><span class="line">        data = zeros(<span class="built_in">Float64</span>, ni, nj, nk)</span><br><span class="line">        <span class="keyword">return</span> new(ni, nj, nk, data)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="comment"># modul</span></span><br></pre></td></tr></table></figure> <figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> .FieldModule</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用例</span></span><br><span class="line">field = FieldModule.Field(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">println(<span class="string">&quot;数据内容：&quot;</span>)</span><br><span class="line">println(field.data)</span><br></pre></td></tr></table></figure></p>
<h3 id="operator-overloading">Operator overloading</h3>
<p>目前，没有直接访问存储在Field对象中的数据的方法。一种选择是将内部的double类型数据成员***data移动到公共区域。之后我们可以用phi.data[i][j][k]来访问数据。这种方式可能会比较繁琐。幸运的是，C++允许我们通过运算符重载定义自定义操作符。
几乎所有的运算符都可以重载，包括数组访问的方括号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Field</span>&#123;</span><br><span class="line">    <span class="comment">// overload the array access operator []</span></span><br><span class="line">    <span class="type">double</span>** <span class="keyword">operator</span> [](<span class="type">int</span> i)&#123;</span><br><span class="line">        <span class="keyword">return</span> data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="type">double</span> ***data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以重载赋值操作符，允许将所有字段条目设置为常量值。这在以下代码片段中展示：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Field&amp; <span class="keyword">operator</span>=(<span class="type">double</span> s)&#123; <span class="comment">// assignment operator</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ni; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nj; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;nk;k++)</span><br><span class="line">                data[i][j][k] = s;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">// 返回参照自身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个函数仅仅遍历所有数据条目，并将它们设置为给定的标量值。为了通用性，我们通过解引用this指针返回当前Field实例的引用。这样可以链式执行多个操作。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Field <span class="title">phi</span><span class="params">(<span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line">phi = <span class="number">0</span>;    <span class="comment">// 初始化所有的值为0</span></span><br><span class="line">phi[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>] = <span class="number">1.0</span>;     <span class="comment">// 使用重载的操作符来设置数据</span></span><br></pre></td></tr></table></figure>
原始数据的清理很重要，因为C++在创建变量时不会自动初始化它们。由于这个步骤对所有动态分配的数据都是必要的，我们在构造函数中添加了对该函数的调用：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="built_in">Field</span> (<span class="type">int</span> ni, <span class="type">int</span> nj, <span class="type">int</span> nk): ni&#123;ni&#125;, nj&#123;nj&#125;, nk&#123;nk&#125;&#123;</span><br><span class="line">    <span class="comment">/* 内存分配代码来自上方 */</span></span><br><span class="line">    (*<span class="keyword">this</span>) = <span class="number">0</span>;    <span class="comment">// 明确地使用赋值运算符</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
另外，我们也可以直接调用操作符。操作符其实就是具有特殊名称的成员函数：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Field (<span class="type">int</span> ni, <span class="type">int</span> nj, <span class="type">int</span> nk) : ni&#123;ni&#125;, nj&#123;nj&#125;, nk&#123;nk&#125;&#123;</span><br><span class="line">    <span class="comment">/* 内存分配代码 */</span></span><br><span class="line">    operator = (<span class="number">0</span>); <span class="comment">// 调用重载操作符=为函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="模版">模版</h3>
<p>Field 对象目前被固定为处理双精度浮点数数据。
尽管在大多数情况下是如此，但有时我们需要存储不同类型的数据。这些包括用整数标记节点类型，以及用于表示速度和电磁场的(x,
y, z)向量。 C++ 允许我们使用模板将 Field
定义为一种通用容器。这个通用版本被重命名为 Field_，其内容如下。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field_</span>&#123;</span></span><br><span class="line">    public:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        Field_ (<span class="type">int</span> ni, <span class="type">int</span> nj, <span class="type">int</span> nk):    ni&#123;ni&#125;, nj&#123;nj&#125;, nk&#123;nk&#125;&#123;</span><br><span class="line">            data = new T**[ni]；    <span class="comment">// ni pointers to pointers of type T</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ni; i++)&#123;</span><br><span class="line">                data[i] = new T*[nj];   <span class="comment">// 分配指针nj到T</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nj; j++)&#123;</span><br><span class="line">                    data[i][j] = new T[nk]; <span class="comment">// 分配T类型的nk对象</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            (*this)=<span class="number">0</span>;  <span class="comment">// clear data</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~Field_()&#123;</span><br><span class="line">            <span class="comment">/* 和之前的代码一样 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据访问操作</span></span><br><span class="line">        T** operator[]  (<span class="type">int</span> i) &#123; <span class="keyword">return</span> data[i];&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overload赋值操作符</span></span><br><span class="line">        Field_&lt;T&gt;&amp; operator= (T s)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ni; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nj; j++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;nk; k++)</span><br><span class="line">                        data[i][j][k] = s;</span><br><span class="line">            <span class="keyword">return</span> *this;       <span class="comment">// return reference to self</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> ni, nj,nk;    <span class="comment">// 节点数</span></span><br><span class="line">    </span><br><span class="line">    protected:</span><br><span class="line">        T ***data;      <span class="comment">// pointer of type T</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 类定义前缀有模板<typename T>参数。
这指示编译器将T视为一个由用户在创建对象时指定的泛型类型。所有之前直接写死为double类型的地方都被替换为T类型。现在我们可以将一个三维数组声明为Field_<double>。类似地，可以使用Field_<int>来实例化一个整数数组。不断地写出模板参数可能会让人感到厌倦。
我们通过使用关键字“using”来为这些类型定义“别名”，以此来解决这个问题。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Field = Field_&lt;<span class="type">double</span>&gt;;   <span class="comment">// field of doubles</span></span><br><span class="line"><span class="keyword">using</span> FiedlI = Field_&lt;<span class="type">int</span>&gt;;     <span class="comment">// field of integers</span></span><br></pre></td></tr></table></figure>
现在我们可以使用Field和FieldI来指代这两种类型。模板替换在编译时发生，因此编译器需要访问依赖于模板参数的所有代码。实际上，这意味着模板函数需要在头文件中完整实现。</p>
<h3 id="移动和复制构造函数">移动和复制构造函数</h3>
<p>为了完整性，我们也应该定义两种特殊的构造函数，允许Field对象被复制和移动。第一种是拷贝构造函数，它通过逐个元素复制另一个Field对象来实现深拷贝。移动构造函数则“窃取”来自另一个对象的数据。它用于从函数中返回临时对象，否则这些对象需要被复制。这两种构造函数的代码如下。拷贝构造函数通过初始化列表调用标准构造函数来分配内存，然后逐个设置元素。
这一过程使用了重载的()运算符来读取另一个字段的数据。[]运算符支持对数据进行读/写访问，因为它返回对象的引用。它不适用于常量成员，因为可以通过引用改变值。()运算符通过返回存储的值提供只读访问数据的方式。而移动构造函数仅设置节点计数，并“窃取”数据，使我们的数据指针指向其他字段持有的数据。通过将其设置为nullptr，使其他字段的数据指针失效。
这阻止了析构函数尝试释放内存。赋值运算符也被重载以支持移动操作。&amp;&amp;
符号表示另一个是临时对象的引用。这些对象，也被称为
r-values，当从函数返回局部变量时会遇到。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Field</span>&#123;</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">Field_</span>(<span class="type">const</span> Field_ &amp;other):</span><br><span class="line">    Field_&#123;other .ni, other .nj, other .nk&#125;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ni; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nj; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;nk; k++)</span><br><span class="line">                    data[i][j][k] = <span class="built_in">other</span>(i, j, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Field_</span>(Field_ &amp;&amp;other):</span><br><span class="line">        ni&#123;other.ni&#125;, nj&#123;other.nj&#125;, nk&#123;other.nk&#125;&#123;</span><br><span class="line">            <span class="keyword">if</span> (data) ~<span class="built_in">Field_</span>();    <span class="comment">// 处理分配数据</span></span><br><span class="line">            data = other.data;  <span class="comment">// 拿取数据</span></span><br><span class="line">            other.data = <span class="literal">nullptr</span>;   <span class="comment">// 无效化</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动标记操作</span></span><br><span class="line">        Field_&amp; <span class="keyword">operator</span> = (Field_ &amp;&amp;f)&#123;</span><br><span class="line">            <span class="keyword">if</span> (data) ~<span class="built_in">Field_</span>();    <span class="comment">// 释放数据</span></span><br><span class="line">            data = f.data;</span><br><span class="line">            f.data=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只读访问数据 data[i][j][k]</span></span><br><span class="line">        <span class="built_in">operator</span>() (<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k) <span class="type">const</span> &#123;<span class="keyword">return</span> data[i][j][k];&#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="additional-operators">Additional Operators</h3>
<p>我们现在定义一些后续会派上用场的额外函数。首先是一个元素级除法运算符，</p>
<p>我们同样为复合加法定义了一个类似的运算符。</p>
<p>接下来，我们编写两个运算符，用于按标量缩放场。</p>
<h3 id="代码的python实现step1">代码的Python实现：step1</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### World类</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">World</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ni:<span class="built_in">int</span>, nj:<span class="built_in">int</span>, nk:<span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># //constructor</span></span><br><span class="line">        self.ni = np.zeros(ni)</span><br><span class="line">        self.nj = np.zeros(nj)</span><br><span class="line">        self.nk = np.zeros(nk)</span><br><span class="line">        self.nn = np.array([ni,nj,nk])</span><br><span class="line">        self.x0 = np.zeros(<span class="number">3</span>)   <span class="comment"># mesh origin</span></span><br><span class="line">        self.dh = np.zeros(<span class="number">3</span>)   <span class="comment"># cell spacing</span></span><br><span class="line">        self.xm = np.zeros(<span class="number">3</span>)   <span class="comment"># mesh max bound</span></span><br><span class="line">        self.xc = np.zeros(<span class="number">3</span>)   <span class="comment"># domain centroid</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">computeNodeVolumes</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;/*to be implemented*/&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># sets mesh extents and computes cell spacing</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setExtents</span>(<span class="params">self, x1:<span class="built_in">float</span>,  y1:<span class="built_in">float</span>, z1:<span class="built_in">float</span>, x2:<span class="built_in">float</span>, y2:<span class="built_in">float</span>, z2:<span class="built_in">float</span></span>):</span><br><span class="line">        <span class="comment"># /*set origin*/ #</span></span><br><span class="line">        self.x0[<span class="number">0</span>] = x1</span><br><span class="line">        self.x0[<span class="number">1</span>] = y1</span><br><span class="line">        self.x0[<span class="number">2</span>] = z1</span><br><span class="line"></span><br><span class="line">        <span class="comment"># /*opposite corner*/ #</span></span><br><span class="line">        self.xm[<span class="number">0</span>] = x2</span><br><span class="line">        self.xm[<span class="number">1</span>] = y2</span><br><span class="line">        self.xm[<span class="number">2</span>] = z2</span><br><span class="line"></span><br><span class="line">        <span class="comment"># /*compute spacing by dividing length by number of cells*/ #</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            self.dh[i] = (self.xm[i] - self.x0[i]) / (self.nn[i]-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># /*compute centroid*/ #</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            self.xc[i] = (self.x0[i] + self.xm[i]) / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># /*recompute node volumes*/ #</span></span><br><span class="line">        self.computeNodeVolumes()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### 主代码</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定您想要添加为模块导入路径的目录</span></span><br><span class="line">pathClasses = <span class="string">&quot;path/to/ch2/snippets/steps1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定路径到sys.path</span></span><br><span class="line"><span class="keyword">if</span> pathClasses <span class="keyword">not</span> <span class="keyword">in</span> sys.path:</span><br><span class="line">    sys.path.append(pathClasses)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> World <span class="keyword">import</span> World</span><br><span class="line"></span><br><span class="line">world = World(<span class="number">21</span>,<span class="number">21</span>,<span class="number">21</span>)</span><br><span class="line">world.setExtents(-<span class="number">0.1</span>,-<span class="number">0.1</span>,-<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">phi = np.zeros([<span class="number">21</span>,<span class="number">21</span>,<span class="number">21</span>])</span><br><span class="line">phi[<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="输出">输出</h3>
<h3 id="three-component-vectors">Three-Component Vectors</h3>
<h3 id="向world中添加场">向World中添加场</h3>
<h3 id="初始化输出">初始化输出</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Output &#123;</span><br><span class="line">	<span class="comment">/*writes mesh data to a VTK image file*/</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fields</span><span class="params">(World &amp;world)</span></span>;	</span><br><span class="line">&#125; <span class="comment">// 包含在.h文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*saves output in VTK format*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Output::fields</span><span class="params">(World &amp;world)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stringstream name;</span><br><span class="line">	name&lt;&lt;<span class="string">&quot;fields.vti&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*open output file*/</span></span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(name.str())</span></span>;</span><br><span class="line">   	<span class="keyword">if</span> (!out.<span class="built_in">is_open</span>()) &#123;cerr&lt;&lt;<span class="string">&quot;Could not open &quot;</span>&lt;&lt;name.<span class="built_in">str</span>()&lt;&lt;endl;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*ImageData is vtk format for structured Cartesian meshes*/</span></span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;VTKFile type=\&quot;ImageData\&quot;&gt;\n&quot;</span>;</span><br><span class="line">	double3 x0 = world.<span class="built_in">getX0</span>();</span><br><span class="line">	double3 dh = world.<span class="built_in">getDh</span>();</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;ImageData Origin=\&quot;&quot;</span>&lt;&lt;x0[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;x0[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;x0[<span class="number">2</span>]&lt;&lt;<span class="string">&quot;\&quot; &quot;</span>;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;Spacing=\&quot;&quot;</span>&lt;&lt;dh[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dh[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dh[<span class="number">2</span>]&lt;&lt;<span class="string">&quot;\&quot; &quot;</span>;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;WholeExtent=\&quot;0 &quot;</span>&lt;&lt;world.ni<span class="number">-1</span>&lt;&lt;<span class="string">&quot; 0 &quot;</span>&lt;&lt;world.nj<span class="number">-1</span>&lt;&lt;<span class="string">&quot; 0 &quot;</span>&lt;&lt;world.nk<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\&quot;&gt;\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*output data stored on nodes (point data)*/</span></span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;PointData&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*potential, scalar*/</span></span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;DataArray Name=\&quot;NodeVol\&quot; NumberOfComponents=\&quot;1\&quot; format=\&quot;ascii\&quot; type=\&quot;Float64\&quot;&gt;\n&quot;</span>;</span><br><span class="line">	out&lt;&lt;world.node_vol;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;/DataArray&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*potential, scalar*/</span></span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;DataArray Name=\&quot;phi\&quot; NumberOfComponents=\&quot;1\&quot; format=\&quot;ascii\&quot; type=\&quot;Float64\&quot;&gt;\n&quot;</span>;</span><br><span class="line">	out&lt;&lt;world.phi;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;/DataArray&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*charge density, scalar*/</span></span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;DataArray Name=\&quot;rho\&quot; NumberOfComponents=\&quot;1\&quot; format=\&quot;ascii\&quot; type=\&quot;Float64\&quot;&gt;\n&quot;</span>;</span><br><span class="line">	out&lt;&lt;world.rho;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;/DataArray&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*electric field, 3 component vector*/</span></span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;DataArray Name=\&quot;ef\&quot; NumberOfComponents=\&quot;3\&quot; format=\&quot;ascii\&quot; type=\&quot;Float64\&quot;&gt;\n&quot;</span>;</span><br><span class="line">	out&lt;&lt;world.ef;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;/DataArray&gt;\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*close out tags*/</span></span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;/PointData&gt;\n&quot;</span>;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;/ImageData&gt;\n&quot;</span>;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;/VTKFile&gt;\n&quot;</span>;</span><br><span class="line"> 	out.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可视化">可视化</h3>
<p>就目前而言，我可能更关切的是用Python实现，暂时还不考虑性能问题。因此上述部分C++代码讲解跳过。</p>
<h3 id="代码的python实现step2">代码的Python实现：step2</h3>
<h4 id="world-类">World 类</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">World</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ni:<span class="built_in">int</span>, nj:<span class="built_in">int</span>, nk:<span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># //constructor</span></span><br><span class="line">        self.ni = ni</span><br><span class="line">        self.nj = nj</span><br><span class="line">        self.nk = nk</span><br><span class="line">        self.nn = np.array([ni,nj,nk])  <span class="comment"># number of nodes  </span></span><br><span class="line"></span><br><span class="line">        self.phi = np.zeros([ni, nj, nk])</span><br><span class="line">        self.rho = np.zeros([ni, nj, nk])</span><br><span class="line">        self.node_vol = np.zeros([ni, nj, nk])</span><br><span class="line">        self.ef = np.zeros([<span class="number">3</span>, ni, nj, nk,])</span><br><span class="line"></span><br><span class="line">        self.x0 = np.zeros(<span class="number">3</span>)   <span class="comment"># mesh origin</span></span><br><span class="line">        self.dh = np.zeros(<span class="number">3</span>)   <span class="comment"># cell spacing</span></span><br><span class="line">        self.xm = np.zeros(<span class="number">3</span>)   <span class="comment"># mesh max bound</span></span><br><span class="line">        self.xc = np.zeros(<span class="number">3</span>)   <span class="comment"># domain centroid</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setExtents</span>(<span class="params">self, _x0, _xm</span>):</span><br><span class="line">        <span class="comment"># /*set origin*/</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            self.x0[i] = _x0[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># /*opposite corner*/</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            self.xm[i] = _xm[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># /*compute spacing by dividing length by number of cells*/</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            self.dh[i] = (self.xm[i]-self.x0[i])/(self.nn[i]-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment">#//compute centroid</span></span><br><span class="line">            self.xc[i] = <span class="number">0.5</span>*(self.x0[i]+self.xm[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getX0</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.x0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getXm</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.xm</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getXc</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.xc</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getDh</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.dh</span><br></pre></td></tr></table></figure>
<h4 id="output类">Output类</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ReshapeForVTK</span>(<span class="params">arr, ni, nj, nk</span>):</span><br><span class="line">    arrNew = np.zeros([nk,ni*nj])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(nk):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(nj):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ni):</span><br><span class="line">                arrNew[k,i*k] = arr[i,j,k]</span><br><span class="line">    <span class="keyword">return</span> arrNew</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ReshapeForVTK3d</span>(<span class="params">arr, ni, nj, nk</span>):</span><br><span class="line">    arrNew = np.zeros([nk,ni*nj*<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(nk):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(nj):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ni):</span><br><span class="line">                <span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                    arrNew[k,i*k*f] = arr[f,i,j,k]</span><br><span class="line">    <span class="keyword">return</span> arrNew</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Output</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fields</span>(<span class="params">self, world</span>):</span><br><span class="line">        filename = <span class="string">&quot;/Users/zhouguangdi/Documents/data_for_software/Python/等离子体/通过例子学习等离子体模拟/ch2/snippets/step2/fields.vti&quot;</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> out:</span><br><span class="line">                <span class="comment"># ImageData is vtk format for structured Cartesian meshes</span></span><br><span class="line">                out.write(<span class="string">&#x27;&lt;VTKFile type=&quot;ImageData&quot;&gt;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                x0 = world.getX0()</span><br><span class="line">                dh = world.getDh()</span><br><span class="line"></span><br><span class="line">                origin_str = <span class="string">f&quot;<span class="subst">&#123;x0[<span class="number">0</span>]&#125;</span> <span class="subst">&#123;x0[<span class="number">1</span>]&#125;</span> <span class="subst">&#123;x0[<span class="number">2</span>]&#125;</span>&quot;</span></span><br><span class="line">                spacing_str = <span class="string">f&quot;<span class="subst">&#123;dh[<span class="number">0</span>]&#125;</span> <span class="subst">&#123;dh[<span class="number">1</span>]&#125;</span> <span class="subst">&#123;dh[<span class="number">2</span>]&#125;</span>&quot;</span></span><br><span class="line">                extent_str = <span class="string">f&quot;0 <span class="subst">&#123;world.ni-<span class="number">1</span>&#125;</span> 0 <span class="subst">&#123;world.nj-<span class="number">1</span>&#125;</span> 0 <span class="subst">&#123;world.nk-<span class="number">1</span>&#125;</span>&quot;</span></span><br><span class="line">                </span><br><span class="line">                out.write(<span class="string">f&#x27;&lt;ImageData Origin=&quot;<span class="subst">&#123;origin_str&#125;</span>&quot; Spacing=&quot;<span class="subst">&#123;spacing_str&#125;</span>&quot; WholeExtent=&quot;<span class="subst">&#123;extent_str&#125;</span>&quot;&gt;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Output data stored on nodes (point data)</span></span><br><span class="line">                out.write(<span class="string">&quot;&lt;PointData&gt;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Node volume</span></span><br><span class="line">                out.write(<span class="string">&#x27;&lt;DataArray Name=&quot;NodeVol&quot; NumberOfComponents=&quot;1&quot; format=&quot;ascii&quot; type=&quot;Float64&quot;&gt;\n&#x27;</span>)</span><br><span class="line">                np.savetxt(out, ReshapeForVTK(world.node_vol, world.ni, world.nj, world.nk))</span><br><span class="line">                out.write(<span class="string">&#x27;&lt;/DataArray&gt;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Potential, scalar</span></span><br><span class="line">                out.write(<span class="string">&#x27;&lt;DataArray Name=&quot;phi&quot; NumberOfComponents=&quot;1&quot; format=&quot;ascii&quot; type=&quot;Float64&quot;&gt;\n&#x27;</span>)</span><br><span class="line">                np.savetxt(out, ReshapeForVTK(world.phi, world.ni, world.nj, world.nk))</span><br><span class="line">                </span><br><span class="line">                out.write(<span class="string">&#x27;&lt;/DataArray&gt;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Charge density, scalar</span></span><br><span class="line">                out.write(<span class="string">&#x27;&lt;DataArray Name=&quot;rho&quot; NumberOfComponents=&quot;1&quot; format=&quot;ascii&quot; type=&quot;Float64&quot;&gt;\n&#x27;</span>)</span><br><span class="line">                np.savetxt(out,ReshapeForVTK(world.rho, world.ni, world.nj, world.nk))</span><br><span class="line">                </span><br><span class="line">                out.write(<span class="string">&#x27;&lt;/DataArray&gt;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Electric field, 3 component vector</span></span><br><span class="line">                out.write(<span class="string">&#x27;&lt;DataArray Name=&quot;ef&quot; NumberOfComponents=&quot;3&quot; format=&quot;ascii&quot; type=&quot;Float64&quot;&gt;\n&#x27;</span>)</span><br><span class="line">                np.savetxt(out, ReshapeForVTK3d(world.ef, world.ni, world.nj, world.nk))</span><br><span class="line">                out.write(<span class="string">&#x27;&lt;/DataArray&gt;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Close out tags</span></span><br><span class="line">                out.write(<span class="string">&quot;&lt;/PointData&gt;\n&quot;</span>)</span><br><span class="line">                out.write(<span class="string">&quot;&lt;/ImageData&gt;\n&quot;</span>)</span><br><span class="line">                out.write(<span class="string">&quot;&lt;/VTKFile&gt;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Output successfully written to <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Could not open <span class="subst">&#123;filename&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="主代码">主代码</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定您想要添加为模块导入路径的目录</span></span><br><span class="line">pathClasses = <span class="string">&quot;path/to/通过例子学习等离子体模拟/ch2/snippets/step2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定路径到sys.path</span></span><br><span class="line"><span class="keyword">if</span> pathClasses <span class="keyword">not</span> <span class="keyword">in</span> sys.path:</span><br><span class="line">    sys.path.append(pathClasses)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> World <span class="keyword">import</span> World</span><br><span class="line"><span class="keyword">from</span> Output <span class="keyword">import</span> Output</span><br><span class="line"></span><br><span class="line">world = World(<span class="number">21</span>,<span class="number">21</span>,<span class="number">21</span>) <span class="comment"># //calls World constructor to create a variable &#x27;world&#x27;</span></span><br><span class="line">world.setExtents([-<span class="number">0.1</span>,-<span class="number">0.1</span>,<span class="number">0</span>],[<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.2</span>]) <span class="comment"># </span></span><br><span class="line"></span><br><span class="line">output = Output()</span><br><span class="line"></span><br><span class="line">output.fields(world)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/images/Visualization_of_the_initial_domain_in_Paraview.png" class="" width="800" title="Figure 2.4: Visualization of the initial domain in Paraview.">
<h2 id="势求解器">势求解器</h2>
<p>上一章节介绍了Gauss-Seidel
算法求解泊松方程。我们从离散化控制方程开始： <span
class="math display">\[\begin{equation}
    \nabla^2\phi=-\rho/\epsilon_0
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    \begin{aligned}\frac{\phi_{i-1,j,k}-2\phi_{i,j,k}+\phi_{i+1,j,k}}{\Delta^2x}+\frac{\phi_{i,j-1,k}-2\phi_{i,j,k}+\phi_{i,j+1,k}}{\Delta^2y}+\\\frac{\phi_{i,j,k-1}-2\phi_{i,j,k}+\phi_{i,j,k+1}}{\Delta^2z}&amp;=-\rho_i/\epsilon_0\end{aligned}
\end{equation}\]</span></p>
<p>离散基于二阶中心差分。<span class="math inline">\(\Delta^2x=(\Delta
x)^2\)</span>。接下来将所有<span
class="math inline">\(\phi_{i,j,k}\)</span>项都放在等式左侧： <span
class="math display">\[\begin{equation}
    \begin{aligned}\left(\frac{2}{\Delta^2x}+\frac{2}{\Delta^2y}+\frac{2}{\Delta^2z}\right)\phi_{i,j,k}=\rho_i/\epsilon_0+\frac{\phi_{i-1,j,k}+\phi_{i+1,j,k}}{\Delta^2x}+\\\frac{\phi_{i,j-1,k}+\phi_{i,j+1,k}}{\Delta^2y}+\frac{\phi_{i,j,k-1}+\phi_{i,j,k+1}}{\Delta^2z}\end{aligned}
\end{equation}\]</span></p>
<p>最后，为了求解<span
class="math inline">\(\phi_{i,j,k}\)</span>，我们得到一个关于节点i、j、k处电势新估计的方程。
高斯-塞德尔常与连续过松弛法（SOR）结合使用，以加速收敛。最终的方程为
<span class="math display">\[\begin{equation}
    \begin{aligned}\phi_{i,j,k}^*=\left(\rho_i/\epsilon_0+\frac{\phi_{i-1,j,k}+\phi_{i+1,j,k}}{\Delta^2x}+\frac{\phi_{i,j-1,k}+\phi_{i,j+1,k}}{\Delta^2y}+\right.\\\frac{\phi_{i,j,k-1}+\phi_{i,j,k+1}}{\Delta^2z})/\left(\frac{2}{\Delta^2x}+\frac{2}{\Delta^2y}+\frac{2}{\Delta^2z}\right)\end{aligned}
\end{equation}\]</span> 以及 <span
class="math display">\[\begin{equation}
    \phi_{i,j,k}\leftarrow\phi_{i,j,k}+w(\phi_{i,j,k}^*-\phi_{i,j,k})
\end{equation}\]</span> 此处，箭头表明了我们将右侧的值 overwriting <span
class="math inline">\(\phi_{i,j,k}\)</span>的值。上述算法仅在内部节点(中心差分可以被
evaluated)上有效。一般情况下，我们需要添加方程以控制边界。由于此处box
walls被假定为Dirichlet，我们通过将循环限制在内部网格节点上(<span
class="math inline">\(i\in[1,ni-2]\)</span>、<span
class="math inline">\(j\in[1,nj-2]\)</span>以及<span
class="math inline">\(k\in[1,nk-2]\)</span>)以简单的跳过它们(边界？)。求解器被定义为位于
PotentialSolver.h 中的PotentialSolver对象的成员函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PotentialSolver</span>&#123;</span></span><br><span class="line">    public:</span><br><span class="line">        <span class="comment">// 构造函数，为输入设定成员函数</span></span><br><span class="line">        PotentialSolver(World &amp;world, <span class="type">int</span> max_it, <span class="type">double</span> tol):</span><br><span class="line">            world(world), max_solver_it(max_it), tolerance(tol)&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用高斯-塞德尔和SOR算法求解电势</span></span><br><span class="line">        <span class="type">bool</span> <span class="title function_">solve</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算电场 = -梯度(phi)</span></span><br><span class="line">        <span class="type">void</span> <span class="title function_">computeEF</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        protected:</span><br><span class="line">            World &amp;world;</span><br><span class="line">            unsingned max_solver_it;</span><br><span class="line">            <span class="type">double</span> tolerance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构造函数接受一个对World对象的引用作为参数，我们将其保存为类成员。
这个引用是为了访问phi场和网格几何结构。我们还设置了一些求解器参数：最大迭代次数和容差。实际的高斯-赛德尔算法在PotentialSolver.cpp中的solve函数中实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PotentialSolver::solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Field &amp;phi = world.phi; <span class="comment">// references to avoid writing world.phi</span></span><br><span class="line">    Field &amp;rho = world.rho;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预计算 1/(dx^2)</span></span><br><span class="line">    double3 dh = world.<span class="built_in">getDh</span>();</span><br><span class="line">    <span class="type">double</span> idx2 = <span class="number">1.0</span>/(dh[<span class="number">0</span>]*dh[<span class="number">0</span>]);   <span class="comment">// 1/dx^2</span></span><br><span class="line">    <span class="type">double</span> idy2 = <span class="number">1.0</span>/(dh[<span class="number">1</span>]*dh[<span class="number">1</span>]);   <span class="comment">// 1/dy^2</span></span><br><span class="line">    <span class="type">double</span> idz2 = <span class="number">1.0</span>/(dh[<span class="number">2</span>]*dh[<span class="number">2</span>]);   <span class="comment">// 1/dz^2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> L2=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> converged=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求解电势</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> it=<span class="number">0</span>; it&lt;max_solver_it; it++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;world.ni<span class="number">-1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;world.nj<span class="number">-1</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>; k&lt;world.nk<span class="number">-1</span>; k++)&#123;</span><br><span class="line">                    <span class="comment">// 标准内部开放节点</span></span><br><span class="line">                    <span class="type">double</span> phi_new = (rho[i][j][k]/Const::EPS_0 + </span><br><span class="line">                                        idx2* (phi[i<span class="number">-1</span>][j][k] + phi[i+<span class="number">1</span>][j][k]) +</span><br><span class="line">                                        idy2* (phi[i][j<span class="number">-1</span>][k] + phi[i][j+<span class="number">1</span>][k] )+</span><br><span class="line">                                        idz2* (phi[i][j][k<span class="number">-1</span>] + phi[i][j][k+<span class="number">1</span>])) /</span><br><span class="line">                                        (<span class="number">2</span>*idx2 + <span class="number">2</span>*idy2 + <span class="number">2</span>*idz2);</span><br><span class="line">                    <span class="comment">// SOR</span></span><br><span class="line">                    phi[i][j][k] = phi[i][j][k] + <span class="number">1.4</span>*(phi_new - phi[i][j][k]);                                                    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否守恒</span></span><br><span class="line">        <span class="keyword">if</span> (it%<span class="number">25</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;world.ni<span class="number">-1</span>; i++)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;world.nj<span class="number">-1</span>; j++)</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>; k&lt;world.nk<span class="number">-1</span>; k++)&#123;</span><br><span class="line">                                <span class="type">double</span> R = -phi[i][j][k]*(<span class="number">2</span>*idx2+<span class="number">2</span>*idy2+<span class="number">2</span>*idz2) +</span><br><span class="line">                                            rho[i][j][k]/Const::EPS_0 + </span><br><span class="line">                                            +idx2* (phi[i<span class="number">-1</span>][j][k] + phi[i+<span class="number">1</span>][j][k])</span><br><span class="line">                                            +idy2* (phi[i][j<span class="number">-1</span>][k] + phi[i][j+<span class="number">1</span>][k])</span><br><span class="line">                                            +idz2* (phi[i][j][k<span class="number">-1</span>] + phi[i][j][k+<span class="number">1</span>]);</span><br><span class="line">                                sum += R*R;</span><br><span class="line">                            &#125;</span><br><span class="line">            L2 = <span class="built_in">sqrt</span>(sum/world.ni*world.nj*world.nk);</span><br><span class="line">            <span class="keyword">if</span> (L2&lt;tolerance)&#123;</span><br><span class="line">                converged=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="comment">// 迭代循环</span></span><br><span class="line">    <span class="keyword">if</span> (!converged) cerr&lt;&lt;<span class="string">&quot;GS failed to converge, L2=&quot;</span>&lt;&lt;L2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> converged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先建立对phi和rho的local引用。这一步骤是为了美观，避免每次我们需要访问势能时都必须写出world.phi。
每隔25次迭代，计算残差向量： <span
class="math display">\[\begin{equation}
    \vec{R}=\mathbf{A}\vec{x}-\vec{b}
\end{equation}\]</span></p>
<p>并比较L2范数 <span class="math display">\[\begin{equation}
    \sqrt{\frac{\sum_nR_n^2}n}\leq\epsilon_{tol}
\end{equation}\]</span>
达到某种tolerance。这种收敛检查会跳过边界，因为那里自然满足狄利克雷条件。如果求解器无法达到所需的容忍度，我们会打印错误信息并返回false，表示失败。然后，我们可以重新运行求解器，增加迭代限制次数，或者像我经常做的那样，如果只在最初的几次时间步长中出现非收敛消息时，直接忽略它。物理常数以及其他一些常数的值是通过在World.h中添加的命名空间Const提供的。</p>
<p>由于目前<span
class="math inline">\(\rho\)</span>为零（我们还没有添加任何粒子），上述代码会在所有位置产生<span
class="math inline">\(\phi\)</span>等于0的结果。
这并不十分有趣。仅仅为了确认求解器确实能运行，我们通过在主程序中添加以下技巧，让<span
class="math inline">\(\phi_{i = 0} = 1\)</span>，<span
class="math inline">\(\phi_{k = 0} = 2\)</span>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化domain</span></span><br><span class="line">    <span class="function">World <span class="title">world</span><span class="params">(<span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>)</span></span></span><br><span class="line"><span class="function">    world.<span class="title">setExtents</span><span class="params">(&#123;<span class="number">-0.1</span>, <span class="number">-0.1</span>, <span class="number">0.0</span>&#125;,&#123;<span class="number">0.1</span>，<span class="number">0.1</span>， <span class="number">0.2</span>&#125;)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 设定phi[i=0]=1以测试</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="params">(<span class="type">int</span> j=<span class="number">0</span>; j&lt;world.nn[<span class="number">1</span>]; j++)</span></span></span><br><span class="line"><span class="function">        <span class="title">for</span> <span class="params">(<span class="type">int</span> k=<span class="number">0</span>; k&lt;world.nn[<span class="number">2</span>]; k++)</span></span></span><br><span class="line"><span class="function">            world.phi[0][j][k] </span>= <span class="number">1</span>;   <span class="comment">// phi[i=0]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定phi[k=0]=2以测试</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;world.nn[<span class="number">0</span>]; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;world.nn[<span class="number">1</span>]; j++)</span><br><span class="line">            world.phi[i][j][<span class="number">0</span>] = <span class="number">2</span>; <span class="comment">// phi[k=0] = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化和求解电势</span></span><br><span class="line">    <span class="function">PotentialSolver <span class="title">solver</span><span class="params">(world, <span class="number">5000</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    solver.<span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存结果</span></span><br><span class="line">    Output::<span class="built_in">fields</span>(world);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="电场">电场</h2>
<p>在ES-PIC模拟中，等离子体势仅仅是一块垫脚石，用于获取电场： <span
class="math display">\[\begin{equation}
    \vec{E}=-\nabla\phi\equiv-\left(\frac{\partial\phi}{\partial
x}\hat{i}+\frac{\partial\phi}{\partial
y}\hat{j}+\frac{\partial\phi}{\partial z}\hat{k}\right)
\end{equation}\]</span>
我们仍使用有限差分方法来重写导数。根据中心差分，我们有： <span
class="math display">\[\begin{equation}
    \begin{aligned}
    \vec{E}=&amp;\left(\frac{\phi_{i-1,j,k}-\phi_{i+1,j,k}}{2\Delta
x}\right)\hat{i}+\left(\frac{\phi_{i,j-1,k}-\phi_{i,j+1,k}}{2\Delta
y}\right)\hat{j}+\\&amp;\left(\frac{\phi_{i,j,k-1}-\phi_{i,j,k+1}}{2\Delta
z}\right)\hat{k}
    \end{aligned}
\end{equation}\]</span>
该差分只适用于内部节点。在边界上，我们使用前一章中研究的单侧二阶精度：
<span class="math display">\[\begin{equation}
    \begin{aligned}
        \left(E_x\right)_{i=0}&amp;
\large=\frac{3\phi_{0,j,k}+4\phi_{1,j,k}-\phi_{2,j,k}}{2\Delta x}  \\
        \left(E_x\right)_{\boldsymbol{i=}n\boldsymbol{i-1}}&amp;
=\frac{-\phi_{ni-3,j,k}+4\phi_{ni-2,j,k}-\phi_{ni-1,j,k}}{2\Delta x}
    \end{aligned}
\end{equation}\]</span></p>
<p>在<span class="math inline">\(y\)</span>和<span
class="math inline">\(z\)</span>面具有相似的方程。这些关系式在computeEF函数中实现。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算电场 = -梯度(phi)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PotentialSolver::computeEF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// reference to phi以避免写world.phi</span></span><br><span class="line">    Field &amp;phi = world.phi;</span><br><span class="line">    double3 dh = world.getDh</span><br><span class="line">    <span class="type">double</span> dx = dh[<span class="number">0</span>]</span><br><span class="line">    <span class="type">double</span> dy = dh[<span class="number">1</span>]</span><br><span class="line">    <span class="type">double</span> dz = dh[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;world.ni; i++)      <span class="comment">// 对整个节点循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;world.nj; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>; k&lt;world.nk; k++)&#123;</span><br><span class="line">                double3 &amp;ef = world.ef[i][j][k]; <span class="comment">// ref to (i,j,k) ef vec3</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// x component, efx</span></span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>)    <span class="comment">// 向前差分</span></span><br><span class="line">                    ef[<span class="number">0</span>] = -(<span class="number">-3</span>*phi[i][j][k] + <span class="number">4</span>*phi[i+<span class="number">1</span>][j][k] - phi[i+<span class="number">2</span>][j][k])/(<span class="number">2</span>*dx);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i==world.ni<span class="number">-1</span>) <span class="comment">// 向后差分</span></span><br><span class="line">                    ef[<span class="number">0</span>] = -(phi[i<span class="number">-2</span>][j][k] - <span class="number">4</span>*phi[i<span class="number">-1</span>][j][k] + <span class="number">3</span>*phi[i][j][k])/(<span class="number">2</span>*dx);</span><br><span class="line">                <span class="keyword">else</span>                    <span class="comment">// 中心差分</span></span><br><span class="line">                    ef[<span class="number">0</span>] = -(phi[i+<span class="number">1</span>][j][k] - phi[i<span class="number">-1</span>][j][k])/(<span class="number">2</span>*dx);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// y component, efy</span></span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span>)</span><br><span class="line">                    ef[<span class="number">1</span>] = -(<span class="number">-3</span>*phi[i][j][k] + <span class="number">4</span>*phi[i][j+<span class="number">1</span>][k] - phi[i][j+<span class="number">2</span>][k])/(<span class="number">2</span>*dy);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j==world.nj<span class="number">-1</span>)</span><br><span class="line">                    ef[<span class="number">1</span>] = -(phi[i][j<span class="number">-2</span>][k] - <span class="number">4</span>*phi[i][j<span class="number">-1</span>][k] + <span class="number">3</span>*phi[i][j][k])/(<span class="number">2</span>*dy);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ef[<span class="number">1</span>] = -(phi[i][j+<span class="number">1</span>][k] - phi[i][j<span class="number">-1</span>][k])/(<span class="number">2</span>*dy);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// z component, efz</span></span><br><span class="line">                <span class="keyword">if</span> (k==<span class="number">0</span>)</span><br><span class="line">                    ef[<span class="number">2</span>] = -(<span class="number">-3</span>*phi[i][j][k] + <span class="number">4</span>*phi[i][j][k+<span class="number">1</span>] - phi[i][j][k+<span class="number">2</span>])/(<span class="number">2</span>*dz);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (k==world.nk<span class="number">-1</span>)</span><br><span class="line">                    ef[<span class="number">2</span>] = -(phi[i][j][k<span class="number">-2</span>] - <span class="number">4</span>*phi[i][j][k<span class="number">-1</span>] + <span class="number">3</span>*phi[i][j][k])/(<span class="number">2</span>*dz);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ef[<span class="number">2</span>] = -(phi[i][j][k+<span class="number">1</span>] - phi[i][j][k<span class="number">-1</span>])/(<span class="number">2</span>*dz);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="粒子">粒子</h2>
<p>下一步，我们需要写载入和移动粒子的代码。作者喜欢通过气体种类分类粒子。
它也简化了计算宏观流动性质的过程，比如粒子数密度和平均流速。我们首先定义一个新的数据容器来存储单个粒子。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Particle</span>&#123;</span><br><span class="line">    <span class="type">double</span> pos[<span class="number">3</span>];  <span class="comment">//  位置</span></span><br><span class="line">    <span class="type">double</span> vel[<span class="number">3</span>]; <span class="comment">// 速度</span></span><br><span class="line">    <span class="type">double</span> mpw; <span class="comment">// 宏观粒子权重</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Particle</span> (<span class="type">double</span> x[<span class="number">3</span>], <span class="type">double</span> v[<span class="number">3</span>], <span class="type">double</span> mpw):    <span class="comment">// 构造函数</span></span><br><span class="line">        pos&#123;x[<span class="number">0</span>],x[<span class="number">1</span>],x[<span class="number">2</span>]&#125;,</span><br><span class="line">        vel&#123;v[<span class="number">0</span>],v[<span class="number">1</span>],v[<span class="number">2</span>]&#125;,</span><br><span class="line">        mpw&#123;mpw&#125;&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个物体存储了定义一个粒子所需的基本信息。具体来说，存储了粒子的位置<span
class="math inline">\(\vec{x}\)</span>和速度<span
class="math inline">\(\vec{v}\)</span>。 我们也存储宏粒子权重<span
class="math inline">\(w_{mp}\)</span>。多数情况下，所有粒子具有相同的权重，而<span
class="math inline">\(w_{mp}\)</span>可以delegated到species级别处理。
我们在这里保留它一般性。</p>
<p>下一步我们定义Species对象。构造函数接受一个字符串参数，表示物种的名称，每个粒子的质量和电荷，以及对World对象的引用。
这个对象用来初始化一个局部变量Field，用于存储数密度。我们还声明了几个稍后将实现的函数。
实际的粒子存储为一个名为particles的vector<Particle>数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Species</span>&#123;</span></span><br><span class="line">    public:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        Species(<span class="built_in">string</span> name, <span class="type">double</span> mass, <span class="type">double</span> charge, World &amp;world):</span><br><span class="line">            name(name), mass(mass), charge(charge), den(world.ni, world.nj, world.nk), world(world)&#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回粒子数量</span></span><br><span class="line">            <span class="type">size_t</span> <span class="title function_">getNp</span><span class="params">()</span> <span class="type">const</span> &#123;<span class="keyword">return</span> particles.size();&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 电场 ef[] 移动所有粒子</span></span><br><span class="line">            <span class="type">void</span> <span class="title function_">advance</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算数密度</span></span><br><span class="line">            <span class="type">void</span> <span class="title function_">computeNumberDensity</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加新粒子</span></span><br><span class="line">            <span class="type">void</span> <span class="title function_">addParticle</span><span class="params">(double3 pos, double3 vel, <span class="type">double</span> mpwt)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 载入在x1-x2 box中具有num_den密度的 num_mp 粒子</span></span><br><span class="line">            <span class="type">void</span> <span class="title function_">loadParticles</span><span class="params">(double3 x1, double3 x2, <span class="type">double</span> num_den, <span class="type">int</span> num_mp)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="built_in">string</span> name;  <span class="comment">// species name</span></span><br><span class="line">            <span class="type">const</span> <span class="type">double</span> mass;  <span class="comment">// particle mass in kg</span></span><br><span class="line">            <span class="type">const</span> <span class="type">double</span> charge;    <span class="comment">// 粒子电荷 in Coulomb</span></span><br><span class="line"></span><br><span class="line">            Field den;  <span class="comment">// 数密度</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">vector</span>&lt;Particle&gt; particles;  <span class="comment">// 存储粒子的数组</span></span><br><span class="line"></span><br><span class="line">    protected:</span><br><span class="line">        World &amp;world;  <span class="comment">// 指向World对象的引用</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>离子和电子species通过实例化Species类型的变量以添加到模拟中。我们存储这些对象
within another vector。 该方法允许我们自动化后续的操作 that 包括循环整个
flying materials。
标准库vector中的向量支持自动调整大小。但是调整大小涉及到复制（或移动）之前存储的数据，因此，如果我们提前知道需要存储多少项，预先使用reserve命令分配足够的空间对我们有利：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Species.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* World初始化 ... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设定粒子species</span></span><br><span class="line">    vector&lt;Species&gt; species;</span><br><span class="line">    species.<span class="built_in">reserve</span>(<span class="number">2</span>); <span class="comment">// 预先分配两种物种的空间</span></span><br><span class="line">    species.<span class="built_in">push_back</span>(<span class="built_in">Species</span>(<span class="string">&quot;O+&quot;</span>, <span class="number">16</span>*AMU, QE, world));  <span class="comment">// AMU 单位原子质量</span></span><br><span class="line">    species.<span class="built_in">push_back</span>(<span class="built_in">Species</span>(<span class="string">&quot;e-&quot;</span>, Me, <span class="number">-1</span>*QE, world));     <span class="comment">// 电子质量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="载入粒子">载入粒子</h3>
<p>随后通过加载粒子来初始化populations。我们感兴趣的是加载粒子以使得在特定bounding
box中获得物种数密度。 对于离子，该bounding
box的尺寸与计算域相同，而对于电子来说，它只包含选定的八分之一区域。
由于数密度是单位体积粒子数量，那么具有数密度<span
class="math inline">\(n\)</span>体积<span
class="math inline">\(V\)</span>的box中包含<span
class="math inline">\(N_{real}=nV\)</span>个物理离子或电子。
这个数量的真实粒子由<span
class="math inline">\(N_{sim}\)</span>个模拟宏粒子表示，因此每个粒子的权重为<span
class="math inline">\(w_{mp} = N_{real}/N_{sim}\)</span>。 此处, <span
class="math inline">\(N_{sim}\)</span> (或<span
class="math inline">\(M\)</span>使用我们之前语法)是用户输入的。
这个计算过程如下所示。一旦我们确定了权重，我们就使用循环来采样<span
class="math inline">\(N_{sim}\)</span>个粒子的位置和速度。这个采样的具体细节目前忽略不计。
在添加粒子之前，我们通过调用reserve预留足够空间来存放num_mp个粒子。这样可以避免当向量需要调整大小时，之前插入的数据需要移动或复制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadParticles</span><span class="params">(double3 x1, double3 x2, <span class="type">double</span> num_den, <span class="type">int</span> num_mp)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> box_vol = (x2[<span class="number">0</span>] - x1[<span class="number">0</span>])*(x2[<span class="number">1</span>] - x1[<span class="number">1</span>])*(x2[<span class="number">2</span>]-x1[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">double</span> num_real = num_den*box_vol;</span><br><span class="line">    <span class="type">double</span> mpw = num_sim/num_real;  <span class="comment">// 宏粒子权重</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为粒子预先分配内存</span></span><br><span class="line">    particles.<span class="built_in">reserve</span>(num_mp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环添加粒子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>; p&lt;num_sim; p++)&#123;</span><br><span class="line">        <span class="comment">/* 采样位置和速度 */</span></span><br><span class="line">        <span class="comment">/* 添加粒子 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机数">随机数</h3>
<p>一种明显的采样位置方法是选择兴趣区域内的一个随机点。我们可以通过下面的方式来生成在<span
class="math inline">\([x_1, x_2)\)</span>范围内的随机数： <span
class="math display">\[\begin{equation}
    \begin{aligned}x=x_1+\mathcal{R}(x_2-x_1)\quad&amp;\in[0,1)\end{aligned}
\end{equation}\]</span> 其中<span
class="math inline">\(\mathcal{R}\)</span>是随机数。随机数是通过称为随机数生成器或RNG的函数生成的。
重要的是要认识到，随机数生成器通常并不会生成真正的随机数。相反，它们会从一个足够长的序列中连续返回数值，这个序列长度使得对于一般观察者来说，这些数字看起来确实像是随机的。这个序列的长度——即在数字开始重复之前可以采样的唯一数值的数量——被称为周期。使用具有大周期的生成器是至关重要的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// World.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rnd</span>&#123;</span>  <span class="comment">//  用于抽样随机数字的对象</span></span><br><span class="line">    public:</span><br><span class="line">        <span class="comment">//  构造器：设置初始随机种子和分布限制</span></span><br><span class="line">        Rnd(): mt_gen&#123;<span class="built_in">std</span>::random_device()()&#125;, rnd_dist&#123;<span class="number">0</span>, <span class="number">1.0</span>&#125;&#123;&#125;</span><br><span class="line">        <span class="type">double</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">()</span>&#123;<span class="keyword">return</span> rnd_dist(mt_gen);&#125;</span><br><span class="line"></span><br><span class="line">    protected:</span><br><span class="line">        <span class="built_in">std</span>::mt19937 mt_gen;  <span class="comment">//  随机数生成器</span></span><br><span class="line">        <span class="built_in">std</span>::uniform_real_distribution&lt;<span class="type">double</span>&gt; rnd_dist;  <span class="comment">//  分布</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> Rnd rnd;  <span class="comment">//  类型名为Rnd的对象称为rnd，在某处已定义。</span></span><br></pre></td></tr></table></figure>
<p>构造函数通过创建random_device对象的实例并从中采样一个值来设置初始seed。
如果我们想要使用相同的一组随机数重复模拟，我们将用mt_gen{0}（或者某个其他固定值）替换这种初始化方式。
然后，在World.cpp中，我们创建了一个名为rnd的Rnd类型的实例。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rnd rnd;    <span class="comment">// 创建一个Rnd对象的实例</span></span><br></pre></td></tr></table></figure>
一个随机数可以通过rnd()来进行采样。这个call利用了重载的()操作以从均匀的[0,1)分布中返回双精度随机数。
这些作为函数行为的自定义对象被称为functors。我们现在可以实现粒子加载循环的主体部分：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Species::loadPatticlesBox</span><span class="params">(double3 x1, double3 x2, <span class="type">double</span> num_den, <span class="type">int</span> num_mp)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* same code as above */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load particles on an 相等间距网格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p=<span class="number">0</span>; p&lt;num_mp; p++)&#123;</span><br><span class="line">        <span class="comment">// sample random position</span></span><br><span class="line">        double3 pos;</span><br><span class="line">        pos[<span class="number">0</span>] = x1[<span class="number">0</span>] + <span class="built_in">rnd</span>()*(x2[<span class="number">0</span>] - x1[<span class="number">0</span>]);</span><br><span class="line">        pos[<span class="number">1</span>] = x1[<span class="number">1</span>] + <span class="built_in">rnd</span>()*(x2[<span class="number">1</span>] - x1[<span class="number">1</span>]);</span><br><span class="line">        pos[<span class="number">2</span>] = x1[<span class="number">2</span>] + <span class="built_in">rnd</span>()*(x2[<span class="number">2</span>] - x1[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set initial velocity</span></span><br><span class="line">        double3 vel &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;  <span class="comment">// 静止粒子</span></span><br><span class="line">        vel[<span class="number">0</span>] = <span class="built_in">rnd</span>()*v_max[<span class="number">0</span>];    <span class="comment">// 将一个新粒子添加到数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>addParticle</code>
函数简单地向粒子向量中添加一个新的条目， <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Species::addParticle</span><span class="params">(double3 pos, double3 vel, double3 mpw)</span></span>&#123;</span><br><span class="line">    particles.<span class="built_in">emplace_back</span>(pos, vel, mpw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
最后，我们在主程序中添加对粒子加载器的调用。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定粒子种类</span></span><br><span class="line">    vector&lt;Species&gt; species;</span><br><span class="line">    species.<span class="built_in">push_back</span>(<span class="built_in">Species</span>(<span class="string">&quot;O+&quot;</span>, <span class="number">16</span>*AMU, QE, world));</span><br><span class="line">    species.<span class="built_in">push_back</span>(<span class="built_in">Species</span>(<span class="string">&quot;e-&quot;</span>, ME, <span class="number">-1</span>*QE, world));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> np_ions = <span class="number">80000</span>;    <span class="comment">//  模拟离子数量</span></span><br><span class="line">    <span class="type">int</span> np_eles = <span class="number">10000</span>;    <span class="comment">//  模拟电子数量</span></span><br><span class="line">    species[<span class="number">0</span>].<span class="built_in">loadParticlesBox</span>(world.<span class="built_in">getX0</span>(), world.<span class="built_in">getXm</span>(), <span class="number">1e11</span>, np_ions);    <span class="comment">//  加载离子</span></span><br><span class="line">    species[<span class="number">1</span>].<span class="built_in">loadParticlesBox</span>(world.<span class="built_in">getX0</span>(), world.<span class="built_in">getXc</span>(), <span class="number">1e11</span>, np_eles);    <span class="comment">//  加载电子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用范围样式循环打印粒子计数</span></span><br><span class="line">    <span class="keyword">for</span> (Species &amp;sp:species)</span><br><span class="line">        cout&lt;&lt;sp.name&lt;&lt;<span class="string">&quot; has &quot;</span>&lt;&lt;sp.<span class="built_in">getNp</span>()&lt;&lt;<span class="string">&quot; particle&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
请注意，离子在<span class="math inline">\([\vec{x}_0,
\vec{x}_m)\)</span> 区域内创建，而电子则在更小的<span
class="math inline">\([\vec{x}_0, \vec{x}_c)\)</span>
区域中创建，其<span class="math inline">\(\vec{x}_c\)</span>是质心。
这段代码是在C++语言中较新添加的一种叫做范围基础循环（range-based for
loop）中调用的。这种语法使用迭代器对象来推进当前的索引。
这是一种更为简洁的书写方式: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;Species&gt;::iterator iter = species.<span class="built_in">begin</span>(); iter!= species.<span class="built_in">end</span>(); ++iter)&#123;</span><br><span class="line">    Species &amp;sp = *iter;    <span class="comment">// 元素在当前迭代位置</span></span><br><span class="line">    <span class="comment">/* use sp here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 节点体积</p>
<p>此时，无法检查加载是否按预期进行。虽然我们可以在其中添加一个输出函数，生成粒子位置的散点图，但我们将此留到下一章。
相反，我们从粒子数据计算数密度。数密度是指在小区域内粒子的数量除以该区域的体积。单元大小控制着我们可以解析的空间细节程度。
由于我们感兴趣于计算节点中心的量，所以我们定义了一个以节点为中心的、大小与单元相等的控制体积。这意味着每个体积延伸至相邻单元的质心。</p>
<p>在一个笛卡尔网格中，每个单元体的体积为 <span
class="math inline">\(V=\Delta x \Delta y \Delta
z\)</span>。节点的体积与cell相同，至少在远离边界的内部区域是这样。
在边界面，节点体积减半。这些节点索引要么是0，要么是ni-1, nj-1,
nk-1。边上的节点，若其有两个零或ni - 1, nj - 1, 或nk -
1的索引，它们的体积会减少四分之一。最后，位于角落的节点体积会减少八分之一。换句话说，每增加一个边界索引，节点体积就减少二分之一。
这项计算由World类中的一个名为computeNodeVolumes的函数执行，每当世界范围发生变化时，它就会被调用。该函数的声明被添加到World类的受保护区块中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算节点体积，在整数节点上dx*dy*dz</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">World::computeNodeVolumes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ni; i++)&#123;   <span class="comment">// 循环整个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;ni; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;nk; k++)&#123;</span><br><span class="line">                <span class="type">double</span> V= dh[<span class="number">0</span>]*dh[<span class="number">1</span>]*dh[<span class="number">2</span>];    <span class="comment">// 标准体积</span></span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span> || i=ni<span class="number">-1</span>) V*=<span class="number">0.5</span>;    <span class="comment">// 边界体积</span></span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span> || j==nj<span class="number">-1</span>) V*=<span class="number">0.5</span>;</span><br><span class="line">                <span class="keyword">if</span> (k==<span class="number">0</span> || k==nk<span class="number">-1</span>) V*=<span class="number">0.5</span>;</span><br><span class="line">                node_vol[i][j][k] = V;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在setExtents中call该函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">World::setExtents</span><span class="params">(double3 _x0, double3 _xm)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="built_in">computeNodeVolumes</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="散射粒子到网格插值">散射：粒子到网格插值</h3>
<p>一种计算数密度的方法是统计每个控制体积内的粒子数量。这种零阶方法不被推荐，因为它不会导致粒子在cell间穿行时密度的平滑变化。
我们使用一种被称为scatter的方法，它是之前提的gather方法的反过程。它使我们能够将particle-based
data内插到计算网格中。
数据scattered到八个（在三维中）节点上，这些节点构成包含粒子的cell。由于节点在单元之间共享，这种内插确保了周围单元也“感知”到粒子。</p>
<p>scatter算法的第一步是确定粒子属于哪一个cell。这对于笛卡尔坐标系来说非常简单，因为节点位置的方程可以解析地求逆。
我们有： <span class="math display">\[\begin{equation}
    l_i=(x-x_0)/\Delta x\\
    l_j=(y-y_0)/\Delta y\\
    l_k=(z-z_0)/\Delta z
\end{equation}\]</span></p>
<p>这些索引是浮点数。整数部分对应于节点索引，而小数部分则是相对于正i、j或k方向上相邻节点的归一化距离。
我们实现在一个名为XtoL的函数中进行这项计算。这个函数直接在World.h头文件中实现，以便编译器可以进行内联处理。我们还将该函数标记为const，以表明它不会修改类的数据。这个注解可以带来额外的优化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">World</span>&#123;</span></span><br><span class="line">    double3 <span class="title function_">XtoL</span><span class="params">(double3 x)</span> <span class="type">const</span>&#123;</span><br><span class="line">        double3 lc;</span><br><span class="line">        lc[<span class="number">0</span>] = (x[<span class="number">0</span>] - x0[<span class="number">0</span>])/dh[<span class="number">0</span>];</span><br><span class="line">        lc[<span class="number">1</span>] = (x[<span class="number">1</span>] - x0[<span class="number">1</span>])/dh[<span class="number">1</span>];</span><br><span class="line">        lc[<span class="number">2</span>] = (x[<span class="number">2</span>] - x0[<span class="number">2</span>])/dh[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> lc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>
<p>我们接着使用整数转换int(<span
class="math inline">\(l_i\)</span>)来获取节点索引。使用粒子位置，cell
可以被划分为八个八分之一。
其normalized体积被用来确定粒子数据分配到每个8节点的比例。数据deposited在“对角线相对(diagonally-opposed)”方向。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Field::scatter</span><span class="params">(double3 lc, <span class="type">double</span> value)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 确保我们在domain内</span></span><br><span class="line">    <span class="keyword">if</span> (lc[<span class="number">0</span>]&lt;<span class="number">0</span> || lc[<span class="number">0</span>]&gt;=nx<span class="number">-1</span> || lc[<span class="number">1</span>]&lt;<span class="number">0</span> || lc[<span class="number">1</span>]&gt;=ny<span class="number">-1</span> || lc[<span class="number">2</span>]&lt;<span class="number">0</span> || lc[<span class="number">2</span>]&gt;=nz<span class="number">-1</span>) <span class="keyword">return</span>; <span class="comment">// 如果上述任一条件为真（即任一坐标超出边界），则执行 return，退出当前函数。这意味着代码不会继续执行后面的逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算cell索引和分数距离</span></span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)lc[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> j = (<span class="type">int</span>)lc[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> k = (<span class="type">int</span>)lc[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> di = lc[<span class="number">0</span>] - i;</span><br><span class="line">    <span class="type">double</span> dj = lc[<span class="number">1</span>] - j;</span><br><span class="line">    <span class="type">double</span> dk = lc[<span class="number">2</span>] - k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deposit 分数值到8个周围的节点</span></span><br><span class="line">    data[i][j][k] += (<span class="number">1</span>-di)*(<span class="number">1</span>-dj)*(<span class="number">1</span>-dk)*value;</span><br><span class="line">    data[i+<span class="number">1</span>][j][k] += di*(<span class="number">1</span>-dj)*(<span class="number">1</span>-dk)*value;</span><br><span class="line">    data[i+<span class="number">1</span>][j+<span class="number">1</span>][k] += di*dj*(<span class="number">1</span>-dk)*value;</span><br><span class="line">    data[i][j+<span class="number">1</span>][k] += (<span class="number">1</span>-di)*dj*(<span class="number">1</span>-dk)*value;</span><br><span class="line">    data[i][j][k+<span class="number">1</span>] += (<span class="number">1</span>-di)*(<span class="number">1</span>-dj)*dk*value;</span><br><span class="line">    data[i+<span class="number">1</span>][j][k+<span class="number">1</span>] += di*(<span class="number">1</span>-dj)*dk*value;</span><br><span class="line">    data[i+<span class="number">1</span>][j+<span class="number">1</span>][k+<span class="number">1</span>] += di*dj*dk*value;</span><br><span class="line">    data[i][j+<span class="number">1</span>][k+<span class="number">1</span>] += (<span class="number">1</span>-di)*dj*dk*value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 数密度</p>
<p>现在将computeNumberDensity函数添加到Species类中： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Species::computeNumberDensity</span><span class="params">()</span></span>&#123;</span><br><span class="line">    den = <span class="number">0</span>;    <span class="comment">// 设定所有值为零</span></span><br><span class="line">    <span class="keyword">for</span> (Particle &amp;part:particles)&#123; <span class="comment">// loop over particles</span></span><br><span class="line">        double3 lc = world.<span class="built_in">XtoL</span>(part.pos); <span class="comment">// 得到逻辑坐标</span></span><br><span class="line">        den.<span class="built_in">scatter</span>(lc, part.mpwt); <span class="comment">// deposit weight</span></span><br><span class="line">    &#125;</span><br><span class="line">    den /= world.node_vol;      <span class="comment">// divide by node volume</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数首先通过使用2.4.2节中介绍的重载赋值运算符，将所有数值设为零，从而清空数据。
接着，我们遍历所有粒子。计算逻辑坐标，并利用它将宏粒子的质量分散到网格中。分散过程是累加的，因此在这一步之前需要清空场。
在粒子循环完成后，den
对象包含了被插值到网格节点上的真实粒子数量。但由于我们关心的是密度，我们需要将这些计数除以节点体积。
在这里，我们使用了重载的 /=
运算符。如果在不支持运算符重载的编程语言中开发代码（或者你只是不喜欢它们），你可以定义一个名为
divideByField 的函数来执行这种逐元素的除法操作。</p>
<p>我们还修改了Output::fields函数，使其接收第二个参数，即物种向量的reference。我们遍历成员，并将密度场作为名为nd.O+和nd.e-的数据数组输出。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Output::fields</span><span class="params">(World &amp;world, vector&lt;Species&gt; &amp;species)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="comment">// species数密度</span></span><br><span class="line">    <span class="keyword">for</span> (Species &amp;sp:species)&#123;</span><br><span class="line">        out&lt;&lt;<span class="string">&quot;&lt;DataArray Name=\&quot;nd.&quot;</span>&lt;&lt;sp.name&lt;&lt;<span class="string">&quot;\&quot;</span></span><br><span class="line"><span class="string">            NumberOfComponents = \&quot;1\&quot; format=\&quot;ascii\&quot;</span></span><br><span class="line"><span class="string">            type=\&quot;Float64\&quot;&gt;\n&quot;</span>;</span><br><span class="line">        out&lt;&lt;sp.den;</span><br><span class="line">        out&lt;&lt;<span class="string">&quot;&lt;/DataArray&gt;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="电荷密度">电荷密度</h2>
<p>有了粒子数密度，就可以计算电荷密度了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://g-d-zhou.github.io/year/04/20/blenderPython/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Dr. Zhou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="格物轩">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 格物轩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/year/04/20/blenderPython/" class="post-title-link" itemprop="url">Blender Python脚本</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-20 20:11:28 / 修改时间：21:30:20" itemprop="dateCreated datePublished" datetime="2024-04-20T20:11:28+08:00">2024-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%B8%A9%E5%9D%91%E5%90%88%E9%9B%86/" itemprop="url" rel="index"><span itemprop="name">踩坑合集</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="根据物体大小分类">根据物体大小分类</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bpy</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备一个字典，用来根据大小组织物体</span></span><br><span class="line">size_to_objects = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历场景中的所有物体</span></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> bpy.context.scene.objects:</span><br><span class="line">    <span class="comment"># 确保物体有网格数据</span></span><br><span class="line">    <span class="keyword">if</span> obj.<span class="built_in">type</span> == <span class="string">&#x27;MESH&#x27;</span>:</span><br><span class="line">        <span class="comment"># 计算物体的体积大小</span></span><br><span class="line">        <span class="comment"># 注意：确保物体的变换应用过，才能得到正确的体积</span></span><br><span class="line">        bpy.context.view_layer.objects.active = obj</span><br><span class="line">        bpy.ops.<span class="built_in">object</span>.mode_set(mode=<span class="string">&#x27;OBJECT&#x27;</span>)</span><br><span class="line">        bpy.ops.<span class="built_in">object</span>.transform_apply(location=<span class="literal">True</span>, rotation=<span class="literal">True</span>, scale=<span class="literal">True</span>)</span><br><span class="line">        volume = obj.dimensions.x * obj.dimensions.y * obj.dimensions.z</span><br><span class="line">        <span class="comment"># 根据大小分组</span></span><br><span class="line">        size_to_objects[volume].append(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据大小创建集合并分配物体</span></span><br><span class="line"><span class="keyword">for</span> size, objs <span class="keyword">in</span> size_to_objects.items():</span><br><span class="line">    <span class="comment"># 创建一个新的集合用于这个特定的大小</span></span><br><span class="line">    collection_name = <span class="string">f&quot;Size_<span class="subst">&#123;size:<span class="number">.2</span>f&#125;</span>&quot;</span></span><br><span class="line">    new_collection = bpy.data.collections.new(name=collection_name)</span><br><span class="line">    bpy.context.scene.collection.children.link(new_collection)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将具有相同大小的物体移动到新集合</span></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> objs:</span><br><span class="line">        <span class="comment"># 先从它们当前的集合中解除链接</span></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> obj.users_collection:</span><br><span class="line">            col.objects.unlink(obj)</span><br><span class="line">        <span class="comment"># 链接到新集合</span></span><br><span class="line">        new_collection.objects.link(obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;分组完成！&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="改变相机位置">改变相机位置</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bpy</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 获取场景中的相机对象</span></span><br><span class="line">    camera = bpy.data.objects.get(<span class="string">&#x27;Camera&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> camera:</span><br><span class="line">        <span class="comment"># 输出当前相机的位置和旋转角度</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前相机位置:&quot;</span>, camera.location)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前相机旋转角度 (弧度):&quot;</span>, camera.rotation_euler)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#    # 设定新的位置</span></span><br><span class="line">    <span class="comment">#    camera.location = (1.0, 2.0, 3.0)</span></span><br><span class="line">       </span><br><span class="line">    <span class="comment">#    # 设定新的旋转角度（采用弧度制）</span></span><br><span class="line">    <span class="comment">#    import math</span></span><br><span class="line">    <span class="comment">#    camera.rotation_euler = (math.radians(90), math.radians(0), math.radians(0))</span></span><br><span class="line">       </span><br><span class="line">    <span class="comment">#    # 输出修改后的相机位置和旋转角度</span></span><br><span class="line">    <span class="comment">#    print(&quot;修改后的相机位置:&quot;, camera.location)</span></span><br><span class="line">    <span class="comment">#    print(&quot;修改后的相机旋转角度 (弧度):&quot;, camera.rotation_euler)</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;场景中没有找到名为 &#x27;Camera&#x27; 的相机对象。请检查对象名称是否正确。&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生错误：&quot;</span>, <span class="built_in">str</span>(e))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://g-d-zhou.github.io/year/04/07/KineticTheoryofGas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Dr. Zhou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="格物轩">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 格物轩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/year/04/07/KineticTheoryofGas/" class="post-title-link" itemprop="url">气体的运动学理论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-07 19:51:48 / 修改时间：20:53:04" itemprop="dateCreated datePublished" datetime="2024-04-07T19:51:48+08:00">2024-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%83%AD%E5%8A%9B%E5%AD%A6%E4%B8%8E%E7%BB%9F%E8%AE%A1%E7%89%A9%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">热力学与统计物理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><span class="math display">\[\begin{equation}
    PV = nRT \\
    PV = NkT
\end{equation}\]</span> 其中，<span
class="math inline">\(n=N/N_A\)</span>,<span
class="math inline">\(N_A\)</span>是Avogadro常量。<span
class="math inline">\(N\)</span>是粒子数，<span
class="math inline">\(n\)</span>是摩尔数。</p>
<p><span class="math display">\[\begin{equation}
    \begin{aligned}
    \text{&lt;Kinetic Energy&gt;}&amp;=\frac32kT,\\\\
    \sqrt{&lt;|\vec{v}|^2&gt;}&amp;=v_{\text{rms}} = \sqrt { \frac { 3 k
T }{ m }}.
    \end{aligned}
\end{equation}\]</span></p>
<p>该书不太适合现阶段的我学习。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://g-d-zhou.github.io/year/03/08/RHEED-KMCS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Dr. Zhou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="格物轩">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 格物轩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/year/03/08/RHEED-KMCS/" class="post-title-link" itemprop="url">RHEED 动力学-蒙特卡洛模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-03-08 21:23:41 / 修改时间：21:31:29" itemprop="dateCreated datePublished" datetime="2024-03-08T21:23:41+08:00">2024-03-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%83%AD%E5%8A%9B%E5%AD%A6%E4%B8%8E%E7%BB%9F%E8%AE%A1%E7%89%A9%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">热力学与统计物理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>来源：https://github.com/PhSchuetz/Kinetic-Monte-Carlo-Model</p>
<p>这是一个简单的动力学-蒙特卡洛模型，用来描述脉冲激光沉积过程中沿（100）晶向生长的三元钙钛矿氧化物(ABO<sub>3</sub>)的生长动力学，并模拟阶梯密度模型中镜面反射高能电子衍射（RHEED）信号的强度。</p>
<p>特别地，该模型旨在描述材料（如SrIrO<sub>3</sub>或SrRuO<sub>3</sub>）在拥有不稳定B位面终止的情况下的生长情况。当在A位面终止的基底上生长（例如TiO<sub>2</sub>终止的SrTiO<sub>3</sub>）时，通常会预期薄膜结构为A面终止。然而，如果B阳离子倾向于在过度氧化时形成易挥发化合物（例如，SrIrO<sub>3</sub>中的IrO<sub>3</sub>或SrRuO<sub>3</sub>中的Ru<sub>2</sub>O<sub>4</sub>/RuO<sub>4</sub>），则在生长过程中可以观察到终止的转变为A位面终止。这种转变可能会持续到沉积一个或多个原子单层所需的时间。该模型旨在模拟这种转变对生长过程中观察到的镜面RHEED信号强度振荡的影响。</p>
<p>动力学-蒙特卡洛模拟的基本理念采自以下出版物：</p>
<ul>
<li><p><a
target="_blank" rel="noopener" href="https://iopscience.iop.org/article/10.1088/0268-1242/3/6/014">P.A.
Maksym, 快速蒙特卡洛模拟MBE生长</a></p></li>
<li><p><a
target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/003960289190013I#!">S.
Clarke, M.R. Wilby &amp; D.D. Vvedensky, Si(001)同质外延理论：I.
生长过程中的动力学</a></p></li>
<li><p><a
target="_blank" rel="noopener" href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.36.9312">S.
Clarke &amp; D.D. Vvedensky,
生长过程中表面阶梯密度对反射高能电子衍射镜面强度的影响</a></p></li>
<li><p><a
target="_blank" rel="noopener" href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.50.8122">V.S.
Achutharaman, N. Chandrasekhar, O.T. Valls, &amp; A.M. Goldman,
(Y,Dy)Ba2Cu3O7−x 薄膜生长过程中RHEED强度振荡的起源</a></p></li>
</ul>
<hr />
<h2 id="模型">模型</h2>
<p>采用的是固体-固体模型，不允许存在空位或悬挂。基底由简单立方晶格表示，由NxN矩阵A描述。条目a<sub>i,j</sub>描述了侧面(i,j)的晶格高度。应用周期边界条件，即(i,j)
= (i+N,j) =
(i,j+N)。钙钛矿材料沿(100)-方向的AO-BO<sub>2</sub>-AO-BO<sub>2</sub>-...序列始终保持不变。</p>
<h2 id="生长动力学">生长动力学</h2>
<p>生长动力学由一系列离散事件模拟。这些事件包括：</p>
<ol type="1">
<li><p>材料的沉积/剥离</p>
<p>沉积经常发生，沉积速率为f（通常为1-3赫兹）（即，经过时间n T =
n/f后）。随机地将N个ABO<sub>3</sub>单元格添加至表面（即，如果u &lt;
1/N，则a<sub>i,j</sub> = a<sub>i,j</sub> +
1，其中u是0和1之间的随机数）</p></li>
<li><p>材料的扩散</p>
<p>表面上的扩散由ABO<sub>3</sub>单元格的最近邻（NN）跳跃描述。跳跃速率h<sub>i,j</sub>是尝试速率h<sub>0</sub>和每次尝试成功的阿伦尼乌斯类型概率的乘积。激活能量E<sub>i,j</sub>由一个与位点无关的表面能垒E<sub>S</sub>、最近邻结合能垒E<sub>B</sub>以及位点(i,j)处的最近邻个数n<sub>i,j</sub>决定：E<sub>i,j</sub>
= E<sub>S</sub> +
n<sub>i,j</sub>E<sub>B</sub>。跳跃的方向是随机的。</p></li>
<li><p>材料的蒸发</p>
<p>如果表面展示出BO<sub>2</sub>-终止，则它可以局部转换为AO终止（即，a<sub>i,j</sub>
= a<sub>i,j</sub> -
0.5）。AO-终止被认为是热力学稳定的。蒸发速率是尝试速率h<sub>0</sub>和每次尝试成功的阿伦尼乌斯类型概率的乘积，激活能量为E<sub>e</sub></p></li>
</ol>
<h2 id="时间演化">时间演化</h2>
<p>事件瞬时发生，在事件之间系统的状态不发生变化。事件间隔时间T的分布P(T)由</p>
<p>P(T)dT = R<sub>t</sub>exp(-R<sub>t</sub>T)dT,</p>
<p>给出，其中R<sub>t</sub> =
Sum<sub>i,j</sub>(h<sub>i,j</sub>+e<sub>i,j</sub>)是总过渡速率。因此，事件间隔时间由</p>
<p>T = - ln[r<sub>1</sub>(0:1)]/R<sub>t</sub>,</p>
<p>给出，这里的r<sub>1</sub>(0:1)是一个0和1之间的随机数。</p>
<h2 id="事件和位点选择">事件和位点选择</h2>
<p>事件的类型由产生一个随机数r<sub>1</sub>(0:1)并检验不等式</p>
<p>0 &lt; r<sub>1</sub>(0:1)R<sub>t</sub> &lt;
Sum<sub>i,j</sub>h<sub>i,j</sub> 和</p>
<p>h<sub>i,j</sub> &lt; r<sub>1</sub>(0:1)R<sub>t</sub> &lt;
Sum<sub>i,j</sub>(h<sub>i,j</sub>+e<sub>i,j</sub>) = R<sub>t</sub></p>
<p>来确定。然后通过测试不等式</p>
<p>r<sub>1</sub>(0:1)R<sub>t</sub> &gt;
Sum<sub>k,l</sub><sup>i-1,j-1</sup>h<sub>k,l</sub></p>
<p>来找到位点。</p>
<h2 id="阶梯密度模型">阶梯密度模型</h2>
<p>在阶梯密度模型中，假设表面上的阶梯作为漫射散射点反射射入的电子。阶梯密度SD与反射RHEED强度I成正比：I
= 1- SD。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://g-d-zhou.github.io/year/01/27/PlasmaEnergeticsInPulsedLaser/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Dr. Zhou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="格物轩">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 格物轩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/year/01/27/PlasmaEnergeticsInPulsedLaser/" class="post-title-link" itemprop="url">脉冲激光沉积过程中的等离子能量学</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-01-27 15:13:16 / 修改时间：15:19:47" itemprop="dateCreated datePublished" datetime="2024-01-27T15:13:16+08:00">2024-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E5%90%88%E9%9B%86/" itemprop="url" rel="index"><span itemprop="name">文献阅读笔记合集</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文是Strikovski, et. al.书章节<a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a>的阅读笔记。</p>
<h2 id="energetic-condensation-in-thin-film-deposition">Energetic
condensation in Thin Film Deposition</h2>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Strikovski, M. D., Kim, J. &amp; Kolagani, S. H. Plasma
energetics in pulsed laser and pulsed electron deposition. In Govindhan
Dhanaraj, V. P., Kullaiah Byrappa &amp; Dudley, M. (eds.) Handbook of
Crystal Growth, chap. 35, 1193–1211 (Springer, Heidelberg, 2010).<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://g-d-zhou.github.io/year/01/11/plasmaFundamentals/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Dr. Zhou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="格物轩">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 格物轩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/year/01/11/plasmaFundamentals/" class="post-title-link" itemprop="url">等离子体模拟基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-11 13:29:12" itemprop="dateCreated datePublished" datetime="2024-01-11T13:29:12+08:00">2024-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-19 19:41:49" itemprop="dateModified" datetime="2024-05-19T19:41:49+08:00">2024-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BD%8E%E6%B8%A9%E7%AD%89%E7%A6%BB%E5%AD%90%E4%BD%93%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">低温等离子体理论与应用</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>"Plasma Simulations by Example"一书的学习笔记。</p>
<h2 id="介绍">介绍</h2>
<p>本章从动力学和流体方法模拟等离子体的概述开始，并介绍了静电PIC控制方程。随后，讨论了有限差分法对微分方程的离散化。我们将使用这种方法来模拟被困在势阱中电子的行为。</p>
<h2 id="气体模拟方法">气体模拟方法</h2>
<p>在微观尺度上，等离子体可以简单地看作由带电粒子（离子和电子）组成的气体。这是我们在本书中采取的基本观点。我们主要关注的是由中性原子、正离子和电子(足以中和空间电荷的)这样的基本组合。
流体模拟的目标是根据一些初始条件和控制定律，预测粒子速度和位置的演变。在经典牛顿物理学的框架下，我们假设所有的中性粒子、离子和电子都作为刚体受运动方程控制，</p>
<p><span class="math display">\[\begin{equation}\label{1.1}
    \frac{\mathrm{d} \vec{x}}{\mathrm{d} t}=\vec{v} \quad
\frac{\mathrm{d} \vec{v}}{\mathrm{d} t}=\vec{a}
\end{equation}\]</span></p>
<p>------Ai 润色到此处</p>
<p>其中，<span class="math inline">\(\vec{x}\)</span>，<span
class="math inline">\(\vec{v}\)</span>和<span
class="math inline">\(\vec{a}\)</span>分别是单个粒子的位置，速度和加速度。如果粒子的质量<span
class="math inline">\(m\)</span>保持不变(本书中该假设均成立)，加速度由牛顿第二定律可知为<span
class="math inline">\(\vec{a}=\sum \vec{F} / m\)</span>。
一些力，如重力，来自外部环境。其他力可能是系统固有的力。带电粒子通过库仑力相互作用，</p>
<p><span class="math display">\[\begin{equation}\label{1.2}
    \vec{F}_{c, i j}=\frac{1}{4 \pi \epsilon_{0}} \frac{q_{i}
q_{j}}{\left|\vec{x}_{i}-\vec{x}_{j}\right|^{3}}\left(\vec{x}_{i}-\vec{x}_{j}\right)
\end{equation}\]</span> 其中，<span
class="math inline">\(i\)</span>和<span
class="math inline">\(j\)</span>是两个带有<span
class="math inline">\(q_{i}\)</span>和<span
class="math inline">\(q_{j}\)</span>电量的粒子。<span
class="math inline">\(\epsilon_{0} \approx 8.8542 \times 10^{-12}\
\mathrm{C} /(\mathrm{Vm})\)</span>
是自由空间的介电常数。该公式忽略了移动电荷的磁场效应。单个粒子受到的总的力为，
<span class="math display">\[\begin{equation}\label{1.3}
    \vec{F}_{c, i}=\sum_{j}^{N} \vec{F}_{c, i j} \quad i \neq j
\end{equation}\]</span></p>
<p>其中，求和是对系统所有粒子的。粒子的速度也可以被碰撞改变。因此，我们有:
<span class="math display">\[\begin{equation}
    \frac{d\vec{v}}{dt}=\frac1m\left(\vec{F}_g+\vec{F}_c+\ldots\right)+\left(\frac{d\vec{v}}{dt}\right)_{col}
\end{equation}\]</span>
尽管上述公式中包含了重力，但人们习惯上忽略它。</p>
<h3 id="直接方法">直接方法</h3>
<p>从概念上讲，一个包含N个粒子的系统可以通过遍历整个列表来建模，并且每个粒子所受库仑力由下式计算：
<span class="math display">\[\begin{equation}
    \vec{F}_{c,i}=q_i\vec{E}_i
\end{equation}\]</span> 其中， <span
class="math display">\[\begin{equation}
    \begin{array}{rrrrrr}&amp;&amp;\vec{E_i}=\sum_j\frac1{4\pi\epsilon_0}\frac{q_j}{r_{ij}^3}\left(\vec{r_i}-\vec{r_j}\right)&amp;&amp;i\neq
j&amp;\\\hdashline\end{array}
\end{equation}\]</span></p>
<p>通过简单的估算可知，这样计算一次的时间比宇宙的年龄还要长七个数量级。实际上，后面会讲到有很快的方法计算。</p>
<p>然而，即使假设线性缩放，由于粒子数量巨大，计算运行时间也将是 21
年。此外，即使一些突然的突破导致计算速度的大幅提高，存储粒子数据所需的内存量也是惊人的。仅存储六个浮点数就需要超过
7000 亿 GB 的 RAM，这些浮点数捕获真空压力下单个立方米中 <span
class="math inline">\(10^{16}\)</span>
个粒子的粒子位置和速度。这超出了任何超级计算机的能力。</p>
<h3 id="玻尔兹曼方程">玻尔兹曼方程</h3>
<p>在一个小的控制体积内瞬间冻结所有的粒子，就可以根据它们的速度分量对它们进行分组。为了完成分组，我们在三维速度空间中定义了一个直方图。每个bin对应于x、y和z的速度分量u、v和w的唯一组合。每个bin的宽度由Δu、Δv和Δw给出。u±0.5Δu、v±0.5Δv和v±0.5Δv的粒子均落入同一bin内。在bin无穷小的极限情况下，离散直方图成为光滑的超空间曲面。该曲面表示速度分布函数，简称VDF。</p>
<p>图1.1给出了仅考虑u和v分量时的一个可能的VDF。函数的值，用表面的高度和阴影表示，表示具有相应u和v速度分量的粒子数。我们清楚地看到大多数粒子都集中在一些平均速度的周围。两条直线u
= 0和v = 0将每个速度分量划分为一个负半空间和一个正半空间。v速度以v =
0为中心，因此在y方向上没有净运动。另一方面，x存在明显的漂移。即使存在u
&lt; 0的粒子，大部分粒子的u为正。</p>
<img src="/images/Lubos/latexImage_3dd467dadf85e4af8364fe934ea1a25b.png" class="" width="400" title="Figure 1.1 Example of a typical gas velocity distribution function.">
<p>在没有碰撞的情况下，所有具有相同速度的粒子都具有一致的运动。这是牛顿第二定律的直接结果。这里我们假设控制体积足够小，使得力项不存在空间变化。由于结果对所有群体都是相同的，因此不需要对每个bin中的一个以上的粒子进行速度积分。只有通过碰撞，一部分群体才以独特的方式受到影响。因此，我们写出一个保守项：
<span class="math display">\[\begin{equation}\label{equ-1-7}
    \frac{df}{dt}=\left(\frac{\partial f}{\partial t}\right)_{col}
\end{equation}\]</span></p>
<p>这种关系表明，分布函数f的全导数只通过一些尚未定义的碰撞算子发生改变。到目前为止，我们所讨论的分布只对它被采样的小控制体积有效。不同的体积，对应其他空间区域，具有独特的粒子速度组合。分布也随时间演化。因此，VDF是7个变量的函数，<span
class="math inline">\(f = f(x, y, z, u, v, w, t)\)</span>。式中：f为(x,
y, z)位置和t时刻速度分量为(u, v,
w)的粒子数。该分布可以任意归一化，在这种情况下函数值(
f是找到这样一个粒子的概率)。我更喜欢使用非归一化版本，因为它携带了完全描述气体状态所需的所有信息。</p>
<p>利用链式法则改写方程<span
class="math inline">\(\ref{equ-1-7}\)</span>中的导数，得到玻尔兹曼方程：
<span class="math display">\[\begin{equation}
    \frac{\partial f}{\partial t}+v\nabla\cdot f+\frac Fm\nabla_v\cdot
f=\left(\frac{\partial f}{\partial t}\right)_{col}
\end{equation}\]</span></p>
<p>右端为零的无碰撞方程被称为Vlasov方程。与直接考虑颗粒间相互作用不同，我们可以通过积分这个偏微分方程(PDE)来模拟气体的演化。绝大多数等离子体仿真程序都没有采用这种方法。原因简单且耳熟能详：计算要求仍然大大超出了标准计算系统的能力。这些要求产生于如果保留所有的三个空间和速度分量，则需要存储六维数据。在降维的情况下，直接求解玻尔兹曼方程实际上是非常有吸引力的。我们在第6章考虑这类求解器，即使在保留碰撞的情况下也被混淆地称为Vlasov求解器。</p>
<h3 id="麦克斯韦-玻尔兹曼分布函数">麦克斯韦-玻尔兹曼分布函数</h3>
<p>显然，必须有替代方案，因为三维等离子体模拟通常在标准的桌面工作站上进行，网格要细得多。内存需求的大部分来自于每个空间单元中需要的大量速度单元。这些bin中的大部分实际上是空的-这实际上可以在图1.1中看到。因此，可以做一些额外的简化。第一种选择是假设VDF服从一个解析profile。具体来说，我们可以令每个方向上的速度为：
<span class="math display">\[\begin{equation}\label{equ-1-9}
    f_M(v)=\frac1{\sqrt{\pi}v_{th}}\exp\left(\frac{-(v-v_d)^2}{v_{th}^2}\right)
\end{equation}\]</span></p>
<p>这就是麦克斯韦-玻尔兹曼分布函数。利用量子理论或统计力学可以推导出它实际上是分子布居数的自然最高熵态。假设你有一个初始充满气体的盒子，里面恰好包含两种类型的粒子：以速度A运动的慢分子和以速度B运动的快分子。如果没有外力作用，并且壁面是完全镜面的，那么速度只能通过碰撞来改变。在动量交换碰撞中，速度较快的分子稍微减速，速度较慢的分子加速。碰撞率也与相对速度成反比。最终，在足够长的时间之后，两个最初离散的粒子群合并为一个没有净动量转移的粒子群。麦克斯韦-玻尔兹曼分布对应于这个末态，到达这个末态的过程称为热化。</p>
<p>利用式<span
class="math inline">\(\ref{equ-1-9}\)</span>的主要好处是，对于每个维度，VDF减少了到只有两个参数：平均(或漂移)速度<span
class="math inline">\(v_d\)</span> 和热速度<span
class="math inline">\(v_{th}\)</span> 。热速度以温度的形式定义，<span
class="math inline">\(v_{t h}=\sqrt{2 k_B T / m}\)</span>
。因此，只需六个浮点数就可以完整地描述每个空间单元中的VDF。通常，我们进一步假设各向同性的温度，将所需的内存减少到仅四个值：漂移速度的三个分量<span
class="math inline">\(\vec{v}_d\)</span>，以及单个量级的热速度。这是对初始粗直方图方法所需的8，000个值的巨大改进!但是生活中没有任何东西是自由的，而且这种做法也不是没有重大的弊端。为了使用方程<span
class="math inline">\(\ref{equ-1-9}\)</span>，我们要求气体通过一个"足够的时间"到使热化。这一要求并不总能得到满足。碰撞率与数密度成比例，分子在碰撞之间的平均距离由平均自由程给出:
<span class="math display">\[\begin{equation}
    \lambda=1/(\sigma n)
\end{equation}\]</span>
σ为碰撞截面，将在第4章中详细讨论。n为气体数密度。一个重要的因子，称为Knudsen数，将平均自由程与特征长度联系起来:
<span class="math display">\[\begin{equation}
    K_n=\frac\lambda L
\end{equation}\]</span> 这个长度是“problem
specific”。在真空室的模拟中，我们可以令L为真空室的直径。如果<span
class="math inline">\(K_n \ll 1\)</span> ，意味着<span
class="math inline">\(\lambda \ll L\)</span>
，每一个分子在壁与壁之间的运动过程中都会发生许多碰撞。这样的<strong>流动</strong>被认为是<strong>连续</strong>的，麦克斯韦VDF可以被认为是有效的。另一方面，如果<span
class="math inline">\(K_n \gg 1\)</span> ，<span
class="math inline">\(\lambda \gg
K\)</span>，分子之间比彼此更容易与壁面发生碰撞。这种状态描述了<strong>自由分子流</strong>。碰撞可以完全忽略，气体动力学由壁面效应驱动。最后，如果<span
class="math inline">\(K_n \approx 1\)</span>
，碰撞之间的距离与特征长度相当。在这种情况下，碰撞会发生，但不足以使麦克斯韦形式的VDF具有确定性。这种状态被称为<strong>稀薄气体</strong>，在等离子体中经常遇到。</p>
<h3 id="流体和动力学方法">流体和动力学方法</h3>
<p>因此，我们可以将气体模拟方法分为流体和动力学两大类。流体方法假设VDF具有解析形式的连续体。通过计算分布函数的矩，得到了熟悉的气体特性，如密度或平均速度。这些都是f的积分，随着速度提高到越来越高的幂次，并在整个速度空间上进行计算。
<span class="math display">\[\begin{equation}
    M^k(\vec{x},t)=\int\vec{v}^kf(\vec{x},\vec{v},t)d\vec{v}
\end{equation}\]</span></p>
<p>零阶、一阶和二阶矩导致了质量、动量和能量守恒方程。对于麦克斯韦的VDF，这些矩给出了计算流体力学(
CFD )中使用的标准Navier-Stokes方程。</p>
<p>在概率论和统计学中，“moment”
是描述随机变量分布特征的数学概念。一般来说，“moment”
描述了随机变量在不同次幂下的期望值。常见的"moment" 包括：</p>
<ul>
<li><p>零阶矩（Zeroth
Moment）：零阶矩是一个随机变量本身的期望值，即数学期望。对于随机变量
<span class="math inline">\(X\)</span>，其零阶矩 <span
class="math inline">\(E(X)\)</span> 表示 <span
class="math inline">\(X\)</span> 的平均值或期望值。</p></li>
<li><p>一阶矩（First
Moment）：一阶矩是随机变量与一个常数的乘积的期望值。对于随机变量 <span
class="math inline">\(X\)</span>，其一阶矩 <span
class="math inline">\(E(X)\)</span> 表示 <span
class="math inline">\(X\)</span> 的加权平均值，其中权重为 X
的概率密度函数。</p></li>
<li><p>二阶矩（Second
Moment）：二阶矩是随机变量的平方的期望值。对于随机变量 <span
class="math inline">\(X\)</span>，其二阶矩 <span
class="math inline">\(E(X^2)\)</span> 表示 <span
class="math inline">\(X\)</span> 的平方的平均值。</p></li>
</ul>
<p>另一方面，动力学方法不对VDF的形状做任何假设，允许其自洽演化。前面讨论的直接求解器和Vlasov求解器是动力学方法的两个例子。两者均被发现存在计算量过大的问题。幸运的是，存在另一类基于随机(随机)采样的方法。许多速度库中包含零粒子或仅包含少数几个粒子。我们不试图完全求解离散化后的VDF，而是可以生成若干个概率服从分布函数的随机速度样本。该采样过程如图1.2所示。</p>
<img src="/images/Lubos/latexImage_17e07b708c4fd5bae09514d39b114913.png" class="" width="400" title="Figure 1.2: Comparison of three approaches for representing a velocity distribution function: analytical function (black line), a histogram of discrete velocities (gray bars), and random samples (white circles).">
<p>利用解析形状表示一维Maxwell -
Boltzmann分布，并与Vlasov求解速度网格和随机采样进行了比较。我们将这些样本视为粒子，并根据运动方程让它们穿过计算域。在这样做的过程中，它们将离散的速度样本移到新的空间区域。每个粒子被分配一个大粒子权重wmp，这样初始的数密度可以用更少的样本来恢复。</p>
<p>大粒子(或特定)权重简单来说就是模拟粒子所代表的真实原子、离子或电子的数量。对于常权重的情形，我们有wmp
= Nreal / Nsim。基于该方法的两种流行方案是粒子模拟(Particle in
Cell，PIC)方法[15]和直接模拟蒙特卡罗(Direct Simulation Monte
Carlo，DSMC)方法[12]。PIC只考虑电磁力引起的加速度。DSMC考虑中性气体，只对碰撞进行建模。这两种方法有许多相似之处，并且经常结合起来模拟部分电离的气体。我们在第4章开展了PIC
-
DSMC模拟。随机性引入了噪声，可以通过使用更多的样本(粒子)来减少噪声。一旦解停止演化，也可以通过对结果进行长时间间隔的平均来降低噪声。因此，随机方法最适合于达到稳态的问题。</p>
<h3 id="拉格朗日和欧拉描述">拉格朗日和欧拉描述</h3>
<p>PIC和Vlasov求解器都是自洽求解VDF的动力学算法。然而，他们以不同的方式对待气体。当PIC跟随单个粒子在区域内运动时，Vlasov求解器使用一个固定的网格来进化气体。这两个模型被称为拉格朗日模型和欧拉模型。因此，我们可以将气体模拟分为四类：</p>
<ul>
<li><p>Fluid / Eulerian：计算流体力学( CFD )，磁流体力学( MHD)</p></li>
<li><p>流体/拉格朗日：光滑粒子流体动力学( SPH )</p></li>
<li><p>动力学/ Eulerian：Vlasov (直接动力学)求解器</p></li>
<li><p>动力学/拉格朗日：粒子模拟( PIC )，直接模拟蒙特卡洛(DSMC)</p></li>
</ul>
<p>本文未讨论的SPH方法与PIC方法的相似之处在于用拉格朗日粒子表示气体。但与PIC中每个粒子携带离散速度不同，SPH粒子表示具有麦克斯韦漂移速度和温度的流体包裹体。最后，PIC和DSMC方案使用欧拉空间网格。该网格用于计算粒子间相互作用。最近，使用“dynamic
octrees”的无网格粒子方法取得了很大的进展[26]。由于消除了对空间网格的依赖，这种无网格方法使方法真正具有拉格朗日性质。</p>
<p>本书的绝大部分内容都致力于动力学PIC方法的研究。原因有二。首先，流体方法与中性气体方法有许多相似之处。与计算流体力学(
CFD )中求解Navier - Stokes方程不同，磁流体动力学( MHD
)方程被求解。动力学( CFD )、磁流体动力学( MHD
)方程求解。求解方案类似，因为它们都涉及控制质量、动量和能量守恒的偏微分方程组的数值积分系统。主要的区别产生于需要考虑电磁场的演化。许多优秀的书籍已经对相关的集成方法进行了全面的调查。</p>
<p>但为完整起见，第6章对流体求解器进行了说明。流体方法也常用与PIC耦合形成混合方案。在我的电推进领域，直接模拟电子并不常见。取而代之的是“problem-specific
complexity”的流体模型。其次，PIC方法的通用性更强。流体方法仅限于连续介质区域。另一方面，<strong>PIC可以在整个克努森数范围内使用</strong>，尽管它们最适合稀薄和自由分子流。PIC的局限性来自于效率，而不是关于VDF的一些固有假设。将PIC应用于连续介质流动需要比流体方法大得多的计算资源，但最终也得到了相同的结果。反之则不成立，因为流体方法不能模拟速度分布为非麦克斯韦分布的稀薄气体。</p>
<h3 id="流体方法和动力学方法的比较">流体方法和动力学方法的比较</h3>
<p>为了说明流体方法和粒子方法的区别，我们考虑中性气体绕球流动的模拟。从流体方法开始，我们可以利用对气体动力学(或者查阅相应的工具书)的理解，得到关于质量、动量和可能的能量守恒的偏微分方程。计算温度需要能量方程，但通常我们假设温度保持不变。例如，我们可以得到如下密度和动量表达式：
<span class="math display">\[\begin{equation}
    \begin{aligned}
\frac{\partial n}{\partial t}+\nabla\cdot(n\vec{u})&amp; =0  \\
mn\left[\frac{\partial\vec{v}}{\partial
t}+(\vec{v}\cdot\nabla)\vec{v}\right]&amp; =\vec{F}-\nabla
p-mn\nu\vec{v}
\end{aligned}
\end{equation}\]</span></p>
<p>这些方程的细节目前并不重要。相反，我们应该注意到，两者都包含一个时间导数项∂(
) /∂t和一个或多个仅依赖于空间性质(如<span
class="math inline">\(\vec{F}\)</span>力项或碰撞阻力项<span
class="math inline">\(mnν\vec{v}\)</span>
)或其导数(压力梯度项∇p)的项。因此，方程可以被重写成一种形式: <span
class="math display">\[\begin{equation}
    \frac{\partial()}{\partial t}=G(X(\vec{x},t))
\end{equation}\]</span></p>
<p>式中：G为t时刻空间变化的气体状态X
(密度、速度、压力等)的函数。从这种形式可以看出，<strong>流体模拟涉及密度、速度等微分方程的时间积分</strong>。该方案一般涉及将时域划分为由一个小的∆t时间步分隔的状态。将物理域离散为空间网格。这种方法是必要的，因为有限的计算机内存并不能解决连续的现实世界中无限多的信息。</p>
<p>然后进行积分，从初始条件开始，直到满足退出准则。这可能涉及到模拟一个指定的实时，或者模拟达到稳态，其中感兴趣的属性不再变化，∂(
) /∂t = 0。</p>
<p>构成空间域的块被称为cell。cell角被称为节点，在邻居cell之间共享。cell一般可以具有任意形状，但它们不应该重叠。如果单元格的排序遵循逻辑结构，则单元格的集合称为模拟网格或模拟网格。</p>
<img src="/images/Lubos/latexImage_247568ef256a6e4f13e79ff35d0a948f.png" class="" width="400" title="Fig. 1.3 Comparison of a ﬂuid (top) and particle (bottom) approach.">
<p>图1.3所示为均匀的笛卡尔网格，该网格为立方、等维单元格，单元格边缘与3个坐标轴对齐。这种类型的网格由于其简单性，在数值模拟中无处不在。</p>
<p>模拟网格使得在感兴趣的属性如密度或速度是已知的地方定义离散点成为可能。最明显的两个选择是节点和cell中心。除非另有说明，本书中开发的所有模拟都使用了<strong>以节点为中心</strong>的方法。然后将控制方程转换为一种形式，从而令使用基于网格的数据对其进行评估成为可能。</p>
<p>我们还指定了控制气体如何进入和离开计算域的边界条件。例如，在x方向上可以给定恒定的密度<span
class="math inline">\(n = n_0\)</span> 和非零的流速，<span
class="math inline">\(\vec{u}=u_0 \hat{i}\)</span>(在<span
class="math inline">\(x_{min}\)</span>
 入口平面上)。我们还指定了嵌入边界的条件。在图1.3中，这些节点通过灰色阴影显示出来。从图中可以推断出，光滑的几何结构变成了退化的“sugarcube”
(或楼梯情况)表示。这种无法解析复杂几何是笛卡尔网格的主要局限性。一些解决方法涉及使用自适应网格细化或切割单元格。在第7章中，我们将看到如何利用非均匀网格来解决这个问题。</p>
<p>可以通过在属于球体的节点上设置离子密度为零，<span
class="math inline">\(n =
0\)</span>，来模拟离子在表面的中和损失。这是<strong>狄利克雷边界条件</strong>的一个例子。该条件为未知量规定了实际值。它并非处处适用。</p>
<p>我们事先并不知道下游的密度，<span class="math inline">\(x =
x_{max}\)</span>
面。指定Dirichlet边界条件将是不正确的。相反，我们告诉代码应该充分发展流动，要求在垂直于边界(或法向)的方向上没有变化，<span
class="math inline">\(\partial n / \partial \hat{n} \equiv \partial n /
\partial x=0\)</span>
。这是<strong>Neumann边界条件</strong>的一个例子。其他类型也有，包括Robin和Cauchy，但出现的次数要少得多。</p>
<p>在下半部分可视化的粒子法根本不利用任何宏观控制方程。它只是简单地根据某种源模型将粒子注入到计算域中。这里我们在<span
class="math inline">\(x_{min}\)</span>
面上注入粒子。选择注入粒子的数量，使其达到所需的密度。初始速度由入口速度分布函数采样得到。我们通过离散Δt时间步，积分运动方程1.1来推进粒子的速度和位置。</p>
<p>我们首先通过考虑作用在每个粒子上的力来计算每个粒子的新速度。我们也可以考虑碰撞。然后我们通过积分速度将粒子推向新的位置。边界条件现在控制着单个颗粒的微观行为。中性粒子撞击球体后可能发生漫反射脱落，而离子则可能重新组合成原子。如果模拟的问题具有空间对称性，那么离开计算域的粒子可能被移除或反射回来。</p>
<p>粒子模拟与流体模拟的不同之处在于，在每个时间步，模拟只由大量离散的位置和速度对组成。我们通常感兴趣的是计算体积密度、速度和温度。从微观粒子数据中获得这些宏观性质需要一些额外的平均。这一般是在计算网格的帮助下完成的。由于数密度只是粒子数除以cell体积，因此可以通过计算每个cell中的粒子数得到局部数密度。气速和温度可以通过类似的方式获得。</p>
<h2 id="静电pic">静电PIC</h2>
<p>假设空间某一小区域包含N个真实离子，用局部速度分布函数<span
class="math inline">\(f\)</span>来描述。我们可以通过从VDF中采样<span
class="math inline">\(M\)</span>个模拟粒子来近似这个“population”。这个小得多的样本代表了整个粒子群，因此每个粒子对应于<span
class="math inline">\(w_{mp} = N / M\)</span> 的实际离子或电子。</p>
<p>每个模拟粒子带着离散速度产生，并携带动量<span
class="math inline">\(w_{mp}m\vec{v}\)</span>。同样，对于局域数和电荷密度计算，粒子贡献<span
class="math inline">\(w_{mp}\)</span>个计数和<span
class="math inline">\(w_{mp}q\)</span> 电荷。速度和位置根据质量为<span
class="math inline">\(m\)</span> 、电荷为<span
class="math inline">\(q\)</span>
的单个物理离子或电子的质量和电荷进行更新。为了避免混淆用于移动粒子的电荷和对电荷密度的贡献，将每个大粒子设想为一堆<span
class="math inline">\(w_{mp}\)</span>的真实离子或电子协同移动。</p>
<h3 id="洛伦兹力">洛伦兹力</h3>
<p>粒子按前面讨论的运动方程运动，力按方程1.5计算。然而，我们没有使用库仑定律，而是使用如下方程求解洛伦兹力：
<span class="math display">\[\begin{equation}
    \vec{F}=q\left(\vec{E}+\vec{v}\times\vec{B}\right)
\end{equation}\]</span></p>
<h3 id="麦克斯韦方程组">麦克斯韦方程组</h3>
<p><span class="math display">\[\begin{equation}
    \begin{aligned}\text{Gauss&#39;
law:}&amp;\quad\nabla\cdot\vec{E}=\frac\rho{\epsilon_0}\\
    \text{Gauss&#39; law for magnetism:}&amp;\quad\nabla\cdot\vec{B}=0\\
    \text{Faraday&#39;s
law:}&amp;\quad\nabla\times\vec{E}=-\frac{\partial\vec{B}}{\partial t}\\
    \text{Ampere&#39;s
law:}&amp;\quad\nabla\times\vec{B}=\mu_0\left(\vec{j}+\epsilon_0\frac{\partial\vec{E}}{\partial
t}\right)\end{aligned}
\end{equation}\]</span></p>
<p>此处，<span class="math inline">\(\rho \equiv \Sigma_s q_s
n_s\)</span>是电荷密度，<span class="math inline">\(\vec{j}\equiv
\Sigma_s q_s n_s \vec{v_s}\)</span>
是电流密度。法拉第定律告诉我们，如果<span
class="math inline">\(\partial\vec{B}/\partial t=0\)</span>，则<span
class="math inline">\(\nabla\times\vec{E}=0\)</span>。具有零旋度的向量场被称为无旋的。</p>
<p>亥姆霍兹分解也被称为向量微积分的基本定律，进一步告诉我们，任何足够光滑的向量场<span
class="math inline">\(\vec{F}\)</span>都可以分解为无旋(无旋度)和“solenoidal”(无散度)两部分。这两部分可以用一个标量势(对于无旋)和一个矢量势(对于solenoidal势)来定义。
<span class="math display">\[\begin{equation}
    \vec F=-\nabla\phi+\nabla\times\vec A
\end{equation}\]</span></p>
<p>因此，如果磁场恒定(电场无旋)，则： <span
class="math display">\[\begin{equation}\label{1-22}
    \vec{E}=-\nabla\phi
\end{equation}\]</span></p>
<p><strong>磁场不随时间变化，就是所谓的静电假设</strong>。由于安培定律表明磁场由电流产生，因此该条件意味着电流密度足够低，自感应磁场可以忽略不计。此外，如果存在外部磁体，则所施加的磁场不能随时间变化。</p>
<h3 id="泊松方程">泊松方程</h3>
<p>静电假设极大地简化了剩余的分析。将方程<span
class="math inline">\(\ref{1-22}\)</span>代入高斯定律可得： <span
class="math display">\[\begin{equation}
    \nabla\cdot(-\nabla\phi) =\frac\rho{\epsilon_0}
\end{equation}\]</span></p>
<p>or</p>
<p><span class="math display">\[\begin{equation} \label{1-24}
    \nabla^2\phi =-\frac\rho{\epsilon_0}
\end{equation}\]</span></p>
<p>这是泊松方程，它构成了cell中静电粒子( ES-PIC
)方法的基础。它提供了等离子体电势和电荷密度之间的关系。电荷密度简单地说是单个“species”的数密度按其电荷标度的总和。在只含有单电荷和双电荷离子和电子的系统中，我们有<span
class="math inline">\(\rho= \text{e}( n_i +
2n_{i2}-n_{\text{e}})\)</span>，其中e是基本电荷。双电荷离子的密度可以用单电荷布居数(“population”)来替代，<span
class="math inline">\(n_{i2} = kn_{i}\)</span>，其中<span
class="math inline">\(k\)</span>为某一分数。</p>
<p>然后我们有：<span
class="math inline">\(\rho=e[(1+2k)n_i-n_e]=e(Z_in_i-n_e)\)</span>
，<span class="math inline">\(Z_i\)</span>项是平均电离态。</p>
<p>该方法最具吸引力之处在于认识到<strong>电荷密度是宏观性质</strong>。实际上，这意味着我们依据模拟网格来定义密度。
网格节点的数量G远小于计算粒子的数量M。 运行次数减少至：</p>
<ul>
<li><p>计算电荷密度，需要运行M次 (整个粒子循环)；</p></li>
<li><p>求解泊松方程，需要运行G log(G)次，(整个网格节点的循环)；</p></li>
<li><p>计算电场，运行G次，(整个网格节点的循环)；</p></li>
<li><p>粒子位置的积分，M次 (整个粒子循环)；</p></li>
</ul>
<h3 id="模拟的主循环">模拟的主循环</h3>
<p>对于PIC方法，首先将计算域离散成模拟网格。在每一个时间步，我们使用粒子位置来计算数密度。
然后，使用相应的电荷密度并利用方程<span
class="math inline">\(\ref{1-24}\)</span>来计算等离子体势。
一旦知道电势，就可以从方程<span
class="math inline">\(\ref{1-22}\)</span>中得到电场。
根据电场产生的洛伦兹来更新粒子速度。
新的速度将push粒子到新的位置，然后重复整个过程。
一般的ES-PIC算法遵从如下步骤：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">求解初始位置</span><br><span class="line">计算电场</span><br><span class="line">载入粒子</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟循环</span></span><br><span class="line">主循环：</span><br><span class="line">    <span class="comment">// 场</span></span><br><span class="line">    计算电荷密度</span><br><span class="line">    计算电势</span><br><span class="line">    计算电场</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 粒子</span></span><br><span class="line">    更新粒子速度</span><br><span class="line">    更新粒子位置</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选步骤</span></span><br><span class="line">    执行碰撞</span><br><span class="line">    注入额外粒子</span><br><span class="line">    输出 diagnostics</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止</span></span><br><span class="line">输出结果</span><br></pre></td></tr></table></figure>
<p>模拟主循环会持续运行直至满足某个退出条件。这可能包括完成预设的实际时间，或者达到稳态。循环结束后，我们通常会保存最终结果并进行额外的终态处理。在第七章讨论到的电磁PIC（EM-PIC）遵循类似的流程，但其推进电场和磁场的方法则有所不同</p>
<h2 id="单粒子运动">单粒子运动</h2>
<p>现在通过简单的例子展示PIC的核心概念。假定两接地电极之间存在电荷密度<span
class="math inline">\(\rho_0\)</span>均匀的粒子，如下图所示。此外，假定电极是无限大的，因此电荷密度是均匀的，且等离子体仅与<span
class="math inline">\(x\)</span>方向有关。这是一个一维问题的例子。</p>
<img src="/images/Lubos/latexImage_6da4fa83eeaa26a11ab1e00c14cf882e.png" class="" width="400" title="Figure 1.4 Simulation domain for the single particle motion example">
<p>假定该区域仅存在离子，<span class="math inline">\(\rho_0 = e
n_i\)</span>。对于<span class="math inline">\(\rho_0
&gt;0\)</span>，两壁之间的电势为正。
若在靠近某一电极处放一静止电子，那么电子将会向势能顶部移动，在那里达到最大速度。接着它沿山下坡，一路减速，直至速度再次降为零。然后运动方向反转，电子继续以这种来回振动的方式运动。</p>
<p>当然，该模型忽略了任何的摩擦(或碰撞)损失。为了develop模拟，假定背景离子密度保持不变，而且足够高，以至于单个电子所带的电荷对电势分布的影响可以忽略不计。这便使得我们只需计算一次势能。余下的代码仅仅涉及更新电子的位置。我们有如下的伪代码：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">求解势</span><br><span class="line">计算电场</span><br><span class="line">载入粒子</span><br><span class="line"></span><br><span class="line">主循环：</span><br><span class="line">    更新粒子速度</span><br><span class="line">    更新粒子位置</span><br><span class="line">    write diagnostics</span><br></pre></td></tr></table></figure></p>
<h3 id="域离散化">域离散化</h3>
<p>如前所述，我们利用计算网格来描述电势、电荷密度以及电场的空间变化。在计算机实现中，这涉及到为每个变量分配一个内存数组，用于存储<span
class="math inline">\(n_i\)</span>个浮点数值，其中<span
class="math inline">\(n_i\)</span>表示网格节点的数量。在经典的C++中，数组可以通过new运算符进行动态分配。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常数</span></span><br><span class="line"><span class="keyword">namespace</span> Const&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> QE = <span class="number">1.602176565e-19</span>; <span class="comment">// 单位电荷，单位C</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ni = <span class="number">21</span>;  <span class="comment">// 网格点数</span></span><br><span class="line">    <span class="type">double</span> *phi = <span class="keyword">new</span> <span class="type">double</span>[ni]; <span class="comment">//势</span></span><br><span class="line">    <span class="type">double</span> *rho = <span class="keyword">new</span> <span class="type">double</span>[ni]; <span class="comment">//电荷密度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了一个具有 ni 个元素的 double 类型的动态数组，并用指针 phi 指向它。通过动态分配内存，我们可以在运行时决定数组的大小，并且在不再需要它时可以手动释放内存。记得在程序的适当位置使用 delete[] phi; 来释放内存，防止内存泄漏。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;&lt;ni; i++)&#123;</span><br><span class="line">        phi[i] = <span class="number">0</span>;</span><br><span class="line">        rho[i] = Const::QE*<span class="number">1e12</span>; <span class="comment">//电荷密度</span></span><br><span class="line">        ef[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* rest of the code goes here */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> [] phi;  <span class="comment">//存储清理</span></span><br><span class="line">    <span class="keyword">delete</span> [] rho;</span><br><span class="line">    <span class="keyword">delete</span> [] ef;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法有多个缺点。首先，默认情况下分配的数据并未进行初始化。每个数组组件最初仅仅包含分配给它的内存位置上存在的某些随机字节。在使用之前，我们需要手动将每个条目设置为零（或者其他有意义的值）。其次，我们需要记住，在数组不再需要时，使用delete[]运算符来释放内存。</p>
<p>一种更干净的方法是使用C++标准库中的std::vector容器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// vector 是一个非常有用的容器类，它提供了动态数组的功能</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;    <span class="comment">// 在代码中直接使用 vector 类型和相关的函数，而无需写全限定名 std::vector。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ni = <span class="number">21</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">phi</span><span class="params">(ni)</span></span>; <span class="comment">//ni doubles的空间，所有均设为零；</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">rho</span><span class="params">(ni, Const::QE*<span class="number">1e12</span>)</span></span>; <span class="comment">// set to QE*1e12, rho 中包含了ni个值为QE*1e12的元素</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">ef</span><span class="params">(ni)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* rest of the code goes here */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">// normal exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以注意到两个主要的区别：</p>
<ul>
<li><p>不再需要初始化数据。它会被自动设置为零，除非提供了不同的值，如电荷密度那样。</p></li>
<li><p>也不需要手动释放内存--当主程序块退出并且向量变量的作用域结束时，这会自动发生。</p></li>
</ul>
<p>std::vector
是一个模板容器，能够存储任意类型的数据。<double>模块参数告诉编译器，我们需要一个用于存储双精度浮点数的容器。</p>
<p>有时候，频繁地输入这些参数可能会变得繁琐。为了解决这个问题，我们可以通过使用指令来定义一个新的类型，叫做dvector。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">using</span> dvector = vector&lt;<span class="type">double</span>&gt;;    <span class="comment">// 定义一个“nickname”</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ni = <span class="number">21</span>;</span><br><span class="line">    <span class="function">dvector <span class="title">phi</span><span class="params">(ni)</span></span>;  <span class="comment">// ni double 以存储 potential</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* rest of the code */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种使用关键字的语法是在C++11语言扩展中引入的。另外，我们也可以利用传统的typedef关键字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> dvector vector&lt;<span class="type">double</span>&gt;;   <span class="comment">// 一个在C++11之前的旧方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至今为止，我们仅仅指定了网格的分辨率。但我们尚未包含与其对应的实际物理区域的信息。
在x方向上均匀分布的笛卡尔网格具有如下位置的节点： <span
class="math display">\[\begin{equation}
    x=x_0+i\Delta x\quad i\in[0,c_i]
\end{equation}\]</span></p>
<p>其中<span
class="math inline">\(c_i\)</span>是x方向的cells数量。或者说： <span
class="math display">\[\begin{equation}
    \Delta x=L/c_i
\end{equation}\]</span></p>
<p>节点的数量为<span class="math inline">\(n_i = c_i +
1\)</span>，因此上述方程也可以写为： <span
class="math display">\[\begin{equation}
    \Delta x=\frac{x_m-x_0}{n_i-1}
\end{equation}\]</span></p>
<p>此处，<span class="math inline">\(L = x_m
-x_0\)</span>表示x值最大的点到原点的距离. 根据图1.4的示意图，我们有<span
class="math inline">\(x_0 = 0\)</span>和$x_m = 0.1 $
m。我们添加代码来设置这些参数。我们还包括一个将网格域输出到逗号分隔文件(.csv)的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常数</span></span><br><span class="line"><span class="keyword">namespace</span> Const &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> QE = <span class="number">1.602176565e-19</span>; <span class="comment">// C, 电子电荷</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> EPS0 = <span class="number">8.85418782e-12</span>; <span class="comment">// C/V/m，电介质常数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> ME = <span class="number">9.10938215e-31</span>; <span class="comment">// kg, 电子质量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Const; <span class="comment">// 避免经常写 Const::QE</span></span><br><span class="line"><span class="keyword">using</span> dvector = vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function prototypes</span></span><br><span class="line"><span class="comment">// 布尔值，指示操作是否成功</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">outputCSV</span><span class="params">(<span class="type">double</span> x0, <span class="type">double</span> dx, <span class="type">const</span> dvector &amp;phi, <span class="type">const</span> dvector &amp;rho, <span class="type">const</span> dvector &amp;ef)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ni = <span class="number">21</span>;  <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> x0 = <span class="number">0</span>;    <span class="comment">//  网格起点</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> xm = <span class="number">0.1</span>;  <span class="comment">//   相反端</span></span><br><span class="line">    <span class="type">double</span> dx = (xm-x0)/(ni<span class="number">-1</span>); <span class="comment">// 节点空间</span></span><br><span class="line"></span><br><span class="line">    <span class="function">dvector <span class="title">phi</span><span class="params">(ni)</span></span>;</span><br><span class="line">    <span class="function">dvector <span class="title">rho</span><span class="params">(ni, QE*<span class="number">1e12</span>)</span></span>;</span><br><span class="line">    <span class="function">dvector <span class="title">ef</span><span class="params">(ni)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output to a CSV file for plotting</span></span><br><span class="line">    <span class="built_in">outputCSV</span>(x0, dx, phi, rho, ef);   <span class="comment">// ef, 电场</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// normal exit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出给定的场到CSV文件中，输出成功则返回true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">outputCSV</span><span class="params">(<span class="type">double</span> x0, <span class="type">double</span> dx, <span class="type">const</span> dvector &amp;phi, <span class="type">const</span> dvector &amp;rho, <span class="type">const</span> dvector &amp;ef)</span></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;results.csv&quot;</span>)</span></span>;    <span class="comment">// open file for writing, ofstream类是包含在头文件 &lt;fstream&gt;中的</span></span><br><span class="line">    <span class="keyword">if</span> (!out)&#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;Could not open output file !&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out&lt;&lt;<span class="string">&quot;x,phi,rho,ef\n&quot;</span>;   <span class="comment">// write header</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;phi.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        out&lt;&lt;x0+i*dx;   <span class="comment">// 写入i-th位置</span></span><br><span class="line">        out&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;phi[i]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;rho[i]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;ef[i];  <span class="comment">//写入值</span></span><br><span class="line">        out&lt;&lt;<span class="string">&quot;\n&quot;</span>;  <span class="comment">//新一行，没有使用endl，以避免buffer flush</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//当输出goes out of scope时，文件自动关闭</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译和运行： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo g++ ch1_01.cpp</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure></p>
<p>python 代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.constants <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 该模块包含了所需的真空介电常数: epsilon_0、电子电荷: e、电子质量m_e: 9.10938215e-31;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义常量</span></span><br><span class="line">ni = <span class="number">21</span>;  <span class="comment"># 节点数量</span></span><br><span class="line">x0 = <span class="number">0</span>;    <span class="comment">#  网格起点</span></span><br><span class="line">xm = <span class="number">0.1</span>;  <span class="comment">#   相反端</span></span><br><span class="line">dx = (xm-x0)/(ni-<span class="number">1</span>); <span class="comment"># 节点空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建存储数组</span></span><br><span class="line">phi = np.zeros(ni)</span><br><span class="line">rho = np.full(ni, e*<span class="number">1e12</span>) <span class="comment"># np.full(shape, fill_value, dtype=None, order=&#x27;C&#x27;)</span></span><br><span class="line">ef = np.zeros(ni)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存成csv文件</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打开 CSV 文件并创建写入对象</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;results.csv&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入第一行数据</span></span><br><span class="line">    writer.writerow([<span class="string">&quot;x&quot;</span>, <span class="string">&quot;phi&quot;</span>, <span class="string">&quot;rho&quot;</span>, <span class="string">&quot;ef&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(phi)):</span><br><span class="line">        writer.writerow([x0+i*dx, phi[i], rho[i], ef[i]])</span><br></pre></td></tr></table></figure>
<p>Julia代码的实现：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> PhysicalConstants.CODATA2018 <span class="comment"># 基于国际科学和技术数据委员会（CODATA）发布的2018年常数集</span></span><br><span class="line"><span class="keyword">using</span> CSV</span><br><span class="line"><span class="keyword">using</span> DataFrames</span><br><span class="line"><span class="keyword">using</span> LinearAlgebra</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义常量</span></span><br><span class="line">ni = <span class="number">21</span>  <span class="comment"># 节点数量</span></span><br><span class="line">x0 = <span class="number">0.0</span>  <span class="comment"># 网格起点</span></span><br><span class="line">xm = <span class="number">0.1</span>  <span class="comment"># 相反端</span></span><br><span class="line">dx = (xm - x0) / (ni - <span class="number">1</span>)  <span class="comment"># 节点空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建存储数组</span></span><br><span class="line">phi = zeros(ni)</span><br><span class="line">rho = fill(PhysicalConstants.CODATA2018.e * <span class="number">1e12</span>, ni) <span class="comment"># fill(x, dims)</span></span><br><span class="line">ef = zeros(ni)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DataFrame来存储数据</span></span><br><span class="line">data = DataFrame(x = x0 .+ (<span class="number">0</span>:ni-<span class="number">1</span>) .* dx, phi = phi, rho = rho, ef = ef)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存成csv文件</span></span><br><span class="line">CSV.write(<span class="string">&quot;results.csv&quot;</span>, data)</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="有限差分方法">有限差分方法</h3>
<p>为了得出等离子体势<span
class="math inline">\(\phi\)</span>，需要求解泊松方程<span
class="math inline">\(\epsilon_0\nabla^2\phi =
-\rho/\epsilon_0\)</span>。 对于此处考虑的恒定电荷密度<span
class="math inline">\(\rho_0 = en_0\)</span>的情况，是有解析解的： <span
class="math display">\[\begin{equation}
    \begin{aligned}
\frac{\partial^2\phi}{\partial x^2}&amp; =-\frac{\rho_0}{\epsilon_0}  \\
\frac{\partial\phi}{\partial x}&amp; =-\frac{\rho_0}{\epsilon_0}x+A  \\
\phi &amp; =-\frac\rho{\epsilon_0}\frac{x^2}2+Ax+B
\end{aligned}
\end{equation}\]</span></p>
<p>积分常数由边界条件设定。<span
class="math inline">\(x=0\)</span>处<span
class="math inline">\(\phi=0\)</span>，因此<span
class="math inline">\(B=0\)</span>。 同样地，<span
class="math inline">\(x=L\)</span>处<span
class="math inline">\(\phi=0\)</span>，因此有<span
class="math inline">\(\begin{aligned}A=\rho_0L/(2\epsilon_0)\end{aligned}\)</span>。
则势的解析表达式为： <span class="math display">\[\begin{equation}
    \phi=\frac{\rho_0}{2\epsilon_0}x(L-x)
\end{equation}\]</span></p>
<p>由<span class="math inline">\(E=-\partial\phi/\partial
x\)</span>可得： <span class="math display">\[\begin{equation}
    \begin{aligned}E=\frac\rho{\epsilon_0}\left(x-\frac
L2\right)\end{aligned}
\end{equation}\]</span></p>
<p>事实上，实际问题肯定没有如此优雅的解析解。因此，我们必须重写方程从而可以通过计算机进行求解。</p>
<p>有三种主要的可用方法：有限差分方法(FDM)、有限体积法(FVM)以及有限元方法(FEM)。
该书三种方法都有所涉及，先从FDM开始。 对于FDM，我们运用泰勒级数。 <span
class="math display">\[\begin{equation}
    \begin{aligned}f(x+\Delta x)&amp;=f(x)+\frac{\Delta
x}{1!}\frac{\partial f}{\partial x}+\frac{(\Delta
x)^2}{2!}\frac{\partial^2f}{\partial x^2}+\frac{(\Delta
x)^3}{3!}\frac{\partial^3f}{\partial x^3}+\ldots\end{aligned}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    \begin{aligned}f(x-\Delta x)&amp;=f(x)-\frac{\Delta
x}{1!}\frac{\partial f}{\partial x}+\frac{(\Delta
x)^2}{2!}\frac{\partial^2f}{\partial x^2}-\frac{(\Delta
x)^3}{3!}\frac{\partial^3f}{\partial x^3}+\ldots\end{aligned}
\end{equation}\]</span></p>
<p>将上述两方程相加，且令<span class="math inline">\(f_i\equiv
f(x_i)\)</span>、<span class="math inline">\(f_{i+1} \equiv f(x+\Delta
x)\)</span>以及<span class="math inline">\(f_{i-1}\equiv f(x-\Delta
x)\)</span>，则有： <span class="math display">\[\begin{equation}
    \begin{aligned}f_{i+1}+f_{i-1}=2f_i+\Delta^2x\frac{\partial^2f}{\partial
x^2}+\text{HOT}\end{aligned}
\end{equation}\]</span></p>
<p>HOT是高阶项(Higher Order Terms)，此外<span
class="math inline">\(\Delta^2x \equiv(\Delta x)^2\)</span>。由于<span
class="math inline">\(\Delta
x&lt;&lt;1\)</span>，因此上述方程等号右侧第二项可忽略。
从而得到的方程是二阶精确的。我们使用一个"大O
"符号来识别这个截断误差，记为<span
class="math inline">\(O(2)\)</span>。</p>
<p>下一步可以重新书写上述方程以分离导数项。 <span
class="math display">\[\begin{equation}\label{1-36}
    \begin{aligned}\frac{\partial^2f}{\partial
x^2}=\frac{f_{i-1}-2f_i+f_{i+1}}{\Delta^2x}+O(3)\end{aligned}
\end{equation}\]</span> 这个表达式被称为二阶导数的标准中心差分。</p>
<h3 id="势求解器">势求解器</h3>
<p>泊松方程在域内处处成立。在每个内部节点上我们都有 <span
class="math display">\[\begin{equation}
    \begin{aligned}\frac{\partial^2\phi}{\partial
x^2}=-\frac{\rho_i}{\epsilon_0}\quad i\in[1,n_i-2]\end{aligned}
\end{equation}\]</span></p>
<p>根据方程<span
class="math inline">\(\ref{1-36}\)</span>可将上式改写为： <span
class="math display">\[\begin{equation}
    \frac{\phi_{i-1}-2\phi_i+\phi_{i+1}}{\Delta^2x}=-(\rho_i/\epsilon_0)\quad
i\in[1,n_i-2]
\end{equation}\]</span></p>
<p>对于<span class="math inline">\(n_i\)</span>个未知量有<span
class="math inline">\(n_i-2\)</span>个方程。通过指定最左端和最右端节点的边界条件来close
the system。 由于两端节点上的电势是固定的，因此采用狄利克雷边界，<span
class="math inline">\(\phi_0=\phi_{ni-1}=0\text{ V}\)</span>。
作为一个例子，我们考虑一个只有七个节点的网格。泊松方程的有限差分法公式产生了下面的方程：
<span class="math display">\[\begin{equation}
    \begin{aligned}
\phi_0&amp; =\phi_{\boldsymbol{left}}  \\
(1/\Delta^2x)\left(\phi_0-2\phi_1+\phi_2\right)&amp;
=-\rho_1/\epsilon_1  \\
(1/\Delta^2x)\left(\phi_1-2\phi_2+\phi_3\right)&amp;
=-\rho_2/\epsilon_2  \\
(1/\Delta^2x)\left(\phi_2-2\phi_3+\phi_4\right)&amp;
=-\rho_3/\epsilon_3  \\
(1/\Delta^2x)\left(\phi_3-2\phi_4+\phi_5\right)&amp;
=-\rho_4/\epsilon_4  \\
(1/\Delta^2x)\left(\phi_4-2\phi_5+\phi_6\right)&amp;
=-\rho_5/\epsilon_5  \\
\phi_{6}&amp; =\phi right
\end{aligned}
\end{equation}\]</span></p>
<p>我们可以用矩阵表示法重写这个system (入下图所示)。</p>
<img src="/images/Lubos/latexImage_4ac5dd0f0f2a3fbf2514a5a8017c00af.png" class="" width="400" title="Figure 1.5: One dimensional Poisson equation coeﬃcient matrix for a mesh with 7 nodes and Dirichlet boundary conditions.">
<p>任何线性的矩阵系统可以通过在两边乘矩阵的逆进行求解，<span
class="math inline">\(\mathbf{A}^{-1}\mathbf{A}\vec{\phi}=\mathbf{A}^{-1}\vec{b}\)</span>。
这个公式假设逆矩阵存在：矩阵不奇异。矩阵的逆与矩阵相乘就是单位矩阵，因此有<span
class="math inline">\(\vec{\phi}=\mathbf{A}^{-1}\vec{b}\)</span>。
然而，求解矩阵的逆计算量非常的大。此外，此外，泊松方程的系数矩阵仅由以主对角线为中心的少数非零带组成。
这是带状矩阵的一个例子，它本身就是稀疏矩阵的一种类型。
通过只记录非零元素，稀疏矩阵可以被有效地存储。逆矩阵失去了这种带状结构，并且包含了更多的非零元素。</p>
<h4 id="tridiagonal-算法">Tridiagonal 算法</h4>
<p>大多数代码中采用的方法是计算给定系统的解，而不需要显式地计算逆。矩阵求解器可以分为两类：直接求解器和迭代求解器。
直接求解器利用矩阵数据中的一些固有结构，在固定的迭代次数内产生精确解。
我们令<span class="math inline">\(\vec{a}\)</span>和<span
class="math inline">\(\vec{c}\)</span>分别代表主对角线<span
class="math inline">\(\vec{b}\)</span>左边和右边的系数，并标记右边的向量为<span
class="math inline">\(\vec{d}\)</span>。
算法由两步组成，首先，向前sweep，我们将系数修改为：</p>
<p><span class="math display">\[\begin{equation}
    \left.c_i&#39;=\left\{\begin{array}{ll}\frac{c_i}{b_i},&amp;;i=0\\\frac{c_i}{b_i-a_ic_{i-1}^{\prime}}&amp;;i=1,\ldots,n-2\end{array}\right.\right.
\end{equation}\]</span> 以及 <span
class="math display">\[\begin{equation}
    \left.d_i^{\prime}=\left\{\begin{array}{ll}\frac{d_i}{b_i},&amp;;i=0\\\frac{d_i-a_id_{i-1}^{\prime}}{b_i-a_ic_{i-1}^{\prime}}&amp;;i=1,\ldots,n-2\end{array}\right.\right.
\end{equation}\]</span></p>
<p>然后，向后代换得： <span class="math display">\[\begin{equation}
    \begin{aligned}x_{n-1}&amp;=d_{n-1}^{\prime}\\
    x_i&amp;=d_i^{\prime}-c_i^{\prime}x_{i+1}\ \ \ \ \
\  ;i=n-2,\ldots,0
    \end{aligned}
\end{equation}\]</span></p>
<p>算法实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solvePotentialDirect</span><span class="params">(<span class="type">double</span> dx, dvector &amp;phi, <span class="type">const</span> dvector &amp;rho)</span></span>&#123;    <span class="comment">//void 函数返回类型关键字，表示函数不会返回任何值</span></span><br><span class="line">    <span class="type">int</span> ni = phi.<span class="built_in">size</span>();  <span class="comment">//  网格节点的数量</span></span><br><span class="line">    <span class="function">dvector <span class="title">a</span><span class="params">(ni)</span></span>;    <span class="comment">//  phi[i-1]的系数</span></span><br><span class="line">    <span class="function">dvector <span class="title">b</span><span class="params">(ni)</span></span>;    <span class="comment">//  phi[i]的系数</span></span><br><span class="line">    <span class="function">dvector <span class="title">c</span><span class="params">(ni)</span></span>;    <span class="comment">//  phi[i+1]的系数</span></span><br><span class="line">    <span class="function">dvector <span class="title">d</span><span class="params">(ni)</span></span>;    <span class="comment">//  等号右边项(RHS)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定系数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ni;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span> || i==ni<span class="number">-1</span>)&#123;   <span class="comment">//  直接边界条件</span></span><br><span class="line">            b[i] = <span class="number">1</span>;   <span class="comment">//  对角线值为1</span></span><br><span class="line">            d[i] = <span class="number">0</span>;   <span class="comment">//  RHS值为： 0 V</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// 设定标准模版</span></span><br><span class="line">            a[i] = <span class="number">1</span>/(dx*dx);   <span class="comment">// phi[i-1]系数</span></span><br><span class="line">            b[i] = <span class="number">-2</span>/(dx*dx);  <span class="comment">// phi[i]系数</span></span><br><span class="line">            c[i] = <span class="number">1</span>/(dx*dx);  <span class="comment">// phi[i+1]系数</span></span><br><span class="line">            d[i] = -rho[i]/EPS_0;   <span class="comment">// RHS值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    c[<span class="number">0</span>] = c[<span class="number">0</span>]/b[<span class="number">0</span>];</span><br><span class="line">    d[<span class="number">0</span>] = d[<span class="number">0</span>]/b[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前步骤</span></span><br><span class="line">    <span class="keyword">for</span> （<span class="type">int</span> i=<span class="number">1</span>; i&lt;ni; i++）&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;ni<span class="number">-1</span>)&#123;</span><br><span class="line">            c[i] = c[i]/(b[i]-a[i]*c[i<span class="number">-1</span>]);</span><br><span class="line">            d[i] = (d[i] − a[i]*d[i−<span class="number">1</span>])/(b[i] − a[i]*c[i−<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向后代换</span></span><br><span class="line">    phi[ni<span class="number">-1</span>] = d[ni<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=ni<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        phi[i] = d[i] - c[i]*phi[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jacobi-迭代">Jacobi 迭代</h4>
<p>对于2D和3D问题，经常使用迭代求解器来求解。对于Jacboi迭代，迭代形式为(根据Jacboi迭代可轻松得出，此处不展开)：
<span class="math display">\[\begin{equation}
    \phi_i^{k+1}=\left[b_i-\sum_{j=0}^{nj-1}(1-\delta_{ij})a_{ij}\phi_j^k\right]/a_{ii}
\end{equation}\]</span></p>
<p>where 对于<span class="math inline">\(\delta_{ij}\)</span>，当<span
class="math inline">\(i=j\)</span>时为0，反之为1。<span
class="math inline">\(k\)</span>和<span
class="math inline">\(k+1\)</span>分别代表当前和新的值。
在这里，利用系数矩阵的稀疏结构也是很有意义的。
此外，对于泊松方程，所有非边界系数都是相同的，因此有： <span
class="math display">\[\begin{equation} \label{equ-1-51}
    \phi_i^{k+1}=\left(\phi_{i-1}^k+\phi_{i+1}^k-b\Delta^2x\right)/2
\end{equation}\]</span></p>
<p>Jacobi 迭代算法实现如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;max_it; k++)&#123;</span><br><span class="line">    <span class="comment">// 在整数节点上计算k+1的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;ni<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        phi_new[i] = (phi[i<span class="number">-1</span>] + phi[i+<span class="number">1</span>] - (dx*dx)*b[i])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 应用边界条件</span></span><br><span class="line">    phi_new[<span class="number">0</span>] = phi_left;</span><br><span class="line">    phi_new[ni<span class="number">-1</span>] = phi_right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的k+1值copy down到 &#x27;k&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;ni; i++)&#123;</span><br><span class="line">        phi[i] = phi_new[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="gauss-seidel-方案">Gauss-Seidel 方案</h4>
<p>Jacobi迭代需要存储当前和新的值，然后将新的值覆盖当前值。但我们是否可以直接覆盖当前值？这将给我们Gauss-Seidel方案。
方程<span class="math inline">\(\ref{equ-1-51}\)</span>被如下方程替代：
<span class="math display">\[\begin{equation}
    \phi_i^{k+1}=\left(\phi_{i-1}^{k+1}+\phi_{i+1}^k-b\Delta^2x\right)/2
\end{equation}\]</span></p>
<p>相应的伪代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用边界条件</span></span><br><span class="line">phi[<span class="number">0</span>] = phi_left;</span><br><span class="line">phi[ni<span class="number">-1</span>] = phi_right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;max_it;k++)&#123;</span><br><span class="line">    <span class="comment">// 在整数节点计算&#x27;k+1&#x27;的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;ni<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        phi[i] = (phi[i−<span class="number">1</span>] + phi[i+<span class="number">1</span>] − (dx*dx)*b[i])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Gauss-Seidel方案更简单，且不需要二次array。它通常比Jacobi收敛得更快，尽管存在Gauss
- Seidel可能发散而Jacobi不发散的矩阵系统。</p>
<div class="note "><p>对角优势：每个方程中对角线系数的绝对值必须大于方程中其他系数的绝对值之和。</p>
<p>当方程组具有对角优势的时候，肯定收敛。如果不具有，也有可能收敛(充分不必要条件)。</p>
</div>
<h4 id="连续超松弛">连续超松弛</h4>
<p>我们可以通过实施连续超松弛( Successive Over Relaxation，SOR
)来进一步加快收敛速度。
该方案利用旧的和新的近似来预测未来的解。对于任意两点y1和y2，我们可以用线性拟合定义另一点，<span
class="math inline">\(y = y_1 + w(y_2-y1)\)</span>。 式中：<span
class="math inline">\(w\)</span>为松弛因子。该表达式在<span
class="math inline">\(w = 0\)</span>时取值为<span
class="math inline">\(y_1\)</span>，在<span class="math inline">\(w =
1\)</span>时取值为<span class="math inline">\(y_2\)</span>。当<span
class="math inline">\(w &gt; 1\)</span>时，我们得到了超出<span
class="math inline">\(y_2\)</span>极限的插值值。
通过这样的方法将新的值和旧的值进行加权平均，也许在<span
class="math inline">\(t&gt;1\)</span>时可以得到比较好的近似。
SOR加速的GS算法为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;max_it; k++)&#123;</span><br><span class="line">    <span class="comment">// 在整数节点计算“k+1”值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;ni<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="type">double</span> g = (phi[i−<span class="number">1</span>] + phi[i+<span class="number">1</span>] − (dx*dx)*b[i])/<span class="number">2</span>;</span><br><span class="line">        phi[i] = phi[i]+w*(g-phi[i]); <span class="comment">// SOR</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 应用边界条件</span></span><br><span class="line">    phi[<span class="number">0</span>] = phi_left;</span><br><span class="line">    phi[ni<span class="number">-1</span>] = phi_right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最优加速度参数w的值需要通过试凑来确定，但习惯上使用1.4左右的值。过大的w会导致初始误差向错误的方向传播而出现收敛问题。利用w
&lt;
1被称为欠松弛，并在CFD中用于稳定可能发散的求解器。一种自适应的方法有时是首选的。</p>
<div class="note "><p>超松弛隐含了一个假设：新值正在朝着真正解的正确方向移动。</p>
</div>
<h4 id="收敛性检查">收敛性检查</h4>
<p>在迭代次数<span class="math inline">\(k\)</span>时当前的矩阵系统为：
<span class="math display">\[\begin{equation}
    \mathbf{A}\vec{\phi}^k=\vec{b}^k+\vec{R}^k
\end{equation}\]</span></p>
<p><span class="math inline">\(\vec{R}^k\)</span>是残差。</p>
<p>通过向量范数来刻画它的大小。有几种范数，其中一个称为L2： <span
class="math display">\[\begin{equation}
    ||R||=\sqrt{\frac{\sum_i^n(R_i)^2}n}
\end{equation}\]</span></p>
<p>由于这种计算需要耗费一些宝贵的计算资源，我们一般不会在每次迭代中计算残差。我一般每隔25~50次求解器迭代就对Gauss-Seidel求解器中的残差进行评估，因为这似乎是在不太频繁地执行收敛检查与超出期望的容差运行额外的迭代之间的一个很好的妥协。完整的求解器代码如下所示。至多运行max_it次迭代。一旦范数下降到10-6以下，函数以成功代码终止。否则，如果超过求解器的最大迭代次数而没有达到期望的容忍度，我们返回错误来表示失败。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solvePotentialGS</span><span class="params">(<span class="type">double</span> dx, dvector &amp;phi, <span class="type">const</span> dvector &amp;rho, <span class="type">int</span> max_it=<span class="number">5000</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> L2;</span><br><span class="line">    <span class="type">double</span> dx2 = dx*dx;  <span class="comment">// 提前计算dx*dx</span></span><br><span class="line">    condt <span class="type">double</span> w = <span class="number">1.4</span>;</span><br><span class="line">    <span class="type">int</span> ni = phi.<span class="built_in">size</span>();    <span class="comment">// 网格节点数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求解电势</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> solver_it=<span class="number">0</span>; solver_it&lt;max_it; solver_it++)&#123;</span><br><span class="line">        phi[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 左侧直接边界条件</span></span><br><span class="line">        phi[ni<span class="number">-1</span>] = <span class="number">0</span>; <span class="comment">// 右侧直接边界条件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Gauss Seidel方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;ni<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="type">double</span> g = <span class="number">0.5</span>*(phi[i<span class="number">-1</span>] + phi[i+<span class="number">1</span>] + dx2*rho[i]/EPS_0);</span><br><span class="line">            phi[i] = phi[i] + w*(g-phi[i]); <span class="comment">//SOR</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查收敛性</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (solver_it%<span class="number">50</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 仅检查触边界节点外的整数节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;ni<span class="number">-1</span>; i++)&#123;</span><br><span class="line">                <span class="type">double</span> R = -rho[i]/EPS0 − (phi[i−<span class="number">1</span>] − <span class="number">2</span>*phi[i] + phi[i+<span class="number">1</span>])/dx2; <span class="comment">//已知值减去根据迭代值算出的值，得到残差</span></span><br><span class="line">                sum+=R*R ;</span><br><span class="line">            &#125;</span><br><span class="line">            L2 = <span class="built_in">sqrt</span>(sum/ni);  <span class="comment">// L2范数</span></span><br><span class="line">            <span class="keyword">if</span> (L2&lt;<span class="number">1e-6</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;GS solver converged after &quot;</span>&lt;&lt;solver_it&lt;&lt;<span class="string">&quot;iterations&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;GS solver failed to converge, L2=&quot;</span>&lt;&lt;L2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="电场">电场</h3>
<p>下一个步骤计算电场： <span class="math display">\[\begin{equation}
    E=-\frac{\partial\phi}{\partial x}
\end{equation}\]</span></p>
<p>在节点位置<span class="math inline">\(i\)</span>处使用泰勒展开：</p>
<p><span class="math display">\[\begin{equation}\label{1-56}
    \begin{gathered}
\boldsymbol{f_{i+1}} =f_i+\frac{\Delta x}1\frac{\partial f}{\partial
x}+\frac{(\Delta x)^2}2\frac{\partial^2f}{\partial x^2}+\text{HOT} \\
\boldsymbol{f_{i-1}} =f_i-\frac{\Delta x}1\frac{\partial f}{\partial
x}+\frac{(\Delta x)^2}2\frac{\partial^2f}{\partial x^2}+\text{HOT}
\end{gathered}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    \begin{aligned}f_{i+1}-f_{i-1}=2\Delta x\frac{\partial f}{\partial
x}+\text{HOT}\end{aligned}
\end{equation}\]</span></p>
<p>同样地，通过一阶偏微分方程的中心差分，可得： <span
class="math display">\[\begin{equation}
    \frac{\partial f}{\partial
x}\thickapprox\frac{f_{i+1}-f_{i-1}}{2\Delta x}
\end{equation}\]</span></p>
<p>如果忽略二阶导数，则得到向前以及向后差分： <span
class="math display">\[\begin{equation}
    \begin{aligned}\frac{\partial f}{\partial
x}&amp;\approx\frac{f_{i+1}-f_i}{\Delta x}\\\\\frac{\partial f}{\partial
x}&amp;\approx\frac{f_i-f_{i-1}}{\Delta x}\end{aligned}
\end{equation}\]</span></p>
<p>显然： <span class="math display">\[\begin{equation}
    \begin{aligned}f_{i+2}=f_i+2\Delta x\frac{\partial f}{\partial
x}+2\Delta^2x\frac{\partial^2f}{\partial x}\end{aligned}
\end{equation}\]</span></p>
<p>对方程<span class="math inline">\(\ref{1-56}\)</span>乘以4，则得：
<span class="math display">\[\begin{equation}
    \begin{aligned}\frac{\partial f}{\partial
x}&amp;\approx\frac{-3f_i+4f_{i+1}-f_{i+2}}{2\Delta x}\end{aligned}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    \begin{aligned}\frac{\partial f}{\partial
x}&amp;\approx\frac{f_{i-2}-4f_{i-1}+3f_i}{2\Delta x}\end{aligned}
\end{equation}\]</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过差分电势计算电场</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">computeEF</span><span class="params">(<span class="type">double</span> dx, dvector &amp;ef, <span class="type">const</span> dvector &amp;phi, <span class="type">bool</span> second_order=<span class="literal">true</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ni = phi.<span class="built_in">size</span>();    <span class="comment">//网格点数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数点上的中心差分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;ni<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        ef[i] = -(phi[i+<span class="number">1</span>] - phi[i<span class="number">-1</span>])/(<span class="number">2</span>*dx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界上one-sided 一阶或二阶差分</span></span><br><span class="line">    <span class="keyword">if</span> (second_order)&#123;</span><br><span class="line">        ef[<span class="number">0</span>] = (<span class="number">3</span>*phi[<span class="number">0</span>] - <span class="number">4</span>*phi[<span class="number">1</span>] + phi[<span class="number">2</span>])/(<span class="number">2</span>*dx);</span><br><span class="line">        ef[ni<span class="number">-1</span>] = (-phi[ni<span class="number">-3</span>] + <span class="number">4</span>*phi[ni<span class="number">-2</span>] - <span class="number">3</span>*phi[ni<span class="number">-1</span>])/(<span class="number">2</span>*dx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">// 一阶</span></span><br><span class="line">        ef[<span class="number">0</span>] = -(phi[<span class="number">1</span>] - phi[<span class="number">0</span>])/(dx);</span><br><span class="line">        ef[ni<span class="number">-1</span>] = -(phi[ni<span class="number">-1</span>] - phi[ni<span class="number">-2</span>])/(dx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="粒子运动">粒子运动</h3>
<p>既然我们已经计算出了电势和电场，我们就可以引入试验粒子。我们通过质量、电荷、位置以及速度来定义粒子。
粒子运动由运动方程<span
class="math inline">\(\ref{1.1}\)</span>给出，力由<span
class="math inline">\(F_x=qE_x\)</span>确定。注意，此处不含磁场。
我们使用有限差分，注意时间只能向前流动，因此不能使用中心差分。 <span
class="math display">\[\begin{equation}
    \begin{aligned}&amp;x^{k+1}=x^k+v^k\Delta
t\\&amp;v^{k+1}=v^k+(q/m)E^k\Delta t\end{aligned}
\end{equation}\]</span>
这个方案被称为前向欧拉方法。这是一种显式方法，因为在时间<span
class="math inline">\(k+1\)</span>的新值仅依赖于时间k的数据。
因此，可以为每个粒子定义一个方程式，明确提供新的位置。
这与隐式方法形成对比，在隐式方法中，<span
class="math inline">\(k+1\)</span>处的值依赖于其他也是<span
class="math inline">\(k+1\)</span>处的值。
通常，隐式方案会导致线性系统出现，需要矩阵求解。 在上述公式中，<span
class="math inline">\(E_k =
E(x^k)\)</span>表示在第k时间步粒子位置的电场采样。
我们很快会了解如何将网格数据插值到粒子。现在，假设电场是恒定的。通过以下代码展示积分过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 载入粒子</span></span><br><span class="line">    <span class="type">double</span> m = ME; <span class="comment">// 粒子质量</span></span><br><span class="line">    <span class="type">double</span> q = -QE; <span class="comment">// 粒子电荷</span></span><br><span class="line">    <span class="type">double</span> x = <span class="number">0</span>; <span class="comment">// 初始位置</span></span><br><span class="line">    <span class="type">double</span> v = <span class="number">0</span>; <span class="comment">// 初始速度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟参数</span></span><br><span class="line">    <span class="type">double</span> dt = <span class="number">1e-9</span>; <span class="comment">// 时间步长</span></span><br><span class="line">    <span class="type">double</span> E = <span class="number">-100</span>; <span class="comment">// 电场强度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开粒子轨迹文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;trace.csv&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!out)&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;无法打开轨迹文件&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;t, x, v\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 粒子循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> it=<span class="number">0</span>; it&lt;<span class="number">10</span>; it++)&#123;</span><br><span class="line">        <span class="comment">// 写入轨迹文件</span></span><br><span class="line">        out&lt;&lt;it*dt&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;v&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新速度和位置</span></span><br><span class="line">        x+= v*dt;</span><br><span class="line">        v+= (q/m)*E*dt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//moraml exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="向前向后欧拉方法">向前/向后欧拉方法</h4>
<p>原书中讨论了这两种方法，总的来说都有较大的误差。</p>
<h4 id="蛙跳方法">蛙跳方法</h4>
<p>在积分过程中，<span class="math inline">\(v^k\)</span>和<span
class="math inline">\(v^{k+1}\)</span>是可用的，我们可以利用它们的平均值。
因此我们有： <span class="math display">\[\begin{equation}
    x^{k+1}=x^k+\left(\frac{v^k+v^{k+1}}2\right)\Delta t
\end{equation}\]</span> 该方案可以产生更精确的结果。利用<span
class="math inline">\(v^{k+1} = v^{k} + \Delta
t(q/m)E\)</span>，我们有： <span class="math display">\[\begin{equation}
    \frac{v^k+v^{k+1}}2=v^k+\frac{\Delta t}2\frac qmE\equiv v^{k+0.5}
\end{equation}\]</span></p>
<p>位置需要在半个步时来进行速度积分。由于这些半步时刻仅需要速度，因此让初始粒子速度在<span
class="math inline">\(k=-0.5\)</span>时定义是合理的。</p>
<p>这种方法避免了显式执行平均的需要。虽然这看起来可能是个微不足道的优化，考虑到在典型的PIC模拟中有数百万的粒子以及数十万的时间步长，消除任何低效对我们都是有利的。
通过这种方案，我们知道了在时间k =
−0.5、0.5、1.5等时刻的速度。同时，我们也知道了在时间k =
0、1、2等时刻的粒子位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 载入粒子</span></span><br><span class="line">    <span class="type">double</span> m = ME; <span class="comment">// 粒子质量</span></span><br><span class="line">    <span class="type">double</span> q = -QE; <span class="comment">// 粒子电荷</span></span><br><span class="line">    <span class="type">double</span> x = <span class="number">0</span>; <span class="comment">// 初始位置</span></span><br><span class="line">    <span class="type">double</span> v = <span class="number">0</span>; <span class="comment">// 初始速度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟参数</span></span><br><span class="line">    <span class="type">double</span> dt = <span class="number">1e-9</span>; <span class="comment">// 时间步长</span></span><br><span class="line">    <span class="type">double</span> E = <span class="number">-100</span>; <span class="comment">// 电场强度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开粒子轨迹文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;trace.csv&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!out)&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;无法打开轨迹文件&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;t, x, v\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 速度回滚</span></span><br><span class="line">    v -= <span class="number">0.5</span>*(q/m)*E*dt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 粒子循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> it=<span class="number">0</span>; it&lt;<span class="number">10</span>; it++)&#123;</span><br><span class="line">        <span class="comment">// 写入轨迹文件</span></span><br><span class="line">        out&lt;&lt;it*dt&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;v&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新速度和位置</span></span><br><span class="line">        v+= (q/m)*E*dt;</span><br><span class="line">        x+= v*dt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// moraml exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note "><p>由于回退时间步，实际上是让电场回退到两个格点中间，因此需要差值计算。</p>
</div>
<h4 id="替代方法">替代方法</h4>
<p>另一种替代方法是四阶精确的龙格-库塔方法(RK4)。对于一个一般的偏微分方程来说:
<span class="math display">\[\begin{equation}
    \begin{aligned}\frac{\partial f}{\partial t}=g(t,f)\end{aligned}
\end{equation}\]</span></p>
<p>未来时间步的值由下式确定： <span
class="math display">\[\begin{equation}
    \begin{aligned}f^{k+1}&amp;=f^k+\frac16\left(k_1+2k_2+2k_3+k_4\right)\end{aligned}
\end{equation}\]</span> 其中， <span
class="math display">\[\begin{equation}
    \begin{aligned}
&amp;\boldsymbol{k_1} \Large=\Delta tg\left(t^k,y^k\right)  \\
&amp;\boldsymbol{k}_{2} =\Delta tg\left(t^k+\frac{\Delta
t}2,y^k+\frac{k_1}2\right)  \\
&amp;{\boldsymbol{k}_3} =\Delta tg\left(t^k+\frac{\Delta
t}2,y^k+\frac{k_2}2\right)  \\
&amp;{\boldsymbol{k}_4} =\Delta tg\left(t^k+\Delta t,y^k+k_3\right)
\end{aligned}
\end{equation}\]</span></p>
<p>但是对于等离子体模拟而言，PK4是不常用的，因为它的计算成本很高。具体分析见原书。</p>
<h3 id="插值">插值</h3>
<p>上文，我们在格点中计算电场。但对处于格点中间的粒子而言，如果直接使用会导致电场非常不连续。
这种不连续性可能会引发数值不稳定性，导致非物理结果。
作者采用了线性插值的方式，使得电场变得连续。</p>
<p><span class="math display">\[\begin{equation}
    \begin{aligned}f=f_i+d_i(f_{i+1}-f_i)\end{aligned}
\end{equation}\]</span> 上式中，<span
class="math inline">\(f_i\)</span>是格点<span
class="math inline">\(i\)</span>上的电场值，<span
class="math inline">\(f_{i+1}\)</span>是格点<span
class="math inline">\(i+1\)</span>上的电场值，<span
class="math inline">\(d_i\)</span>是插值系数。</p>
<p>可以重新写为： <span
class="math display">\[\begin{equation}\label{1.79}
    \begin{aligned}f=(1-d_i)f_i+(d_i)f_{i+1}\end{aligned}
\end{equation}\]</span></p>
<img src="/images/Lubos/latexImage_0973cb5041f3469f5a9911e5f67c1b0d.png" class="" width="400" title="Figure 1.10: Visualization of the one-dimensional linear gather operation.">
<p>上述表达式给出的操作被称为gather，因为它将多个基于网格的值聚集到特定位置以evaluate一个量。
相反的过程被称为scatter，它用于将基于粒子的数据存放回网格。我们在下一章中使用scatter操作来计算粒子密度。
在方程<span class="math inline">\(\ref{1.79}\)</span>中，<span
class="math inline">\((1−di)\)</span>和<span
class="math inline">\((di)\)</span>项被称为基函数，或者称为形状因子。它们在图1.10中以两条虚线表示。在粒子位置<span
class="math inline">\(x_p\)</span>处，它们的幅值用于缩放两个周围节点<span
class="math inline">\(f_i\)</span>和<span
class="math inline">\(f_{i+1}\)</span>的值。</p>
<p>聚集和分散算法都需要知道包含粒子的单元。我们还需要知道粒子在单元内的相对位置。
对于均匀网格，这种计算很简单。通过反转节点位置的映射，我们得到<span
class="math inline">\(l_i = (x−x_0)/\Delta x\)</span>。这里的<span
class="math inline">\(l_i\)</span>是逻辑坐标。
它只是我们之前用于计算节点位置的整数索引<span
class="math inline">\(i\)</span>的浮点数对应物。 <span
class="math inline">\(l_i\)</span>的整数部分是节点索引，而小数部分是与下一个节点的分数距离<span
class="math inline">\(d_i\)</span>。因此，我们定义一个辅助函数:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">XtoL</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> dx, <span class="type">double</span> x0=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x-x0)/dx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以evaluate逻辑坐标。通过如下代码获得节点索引以及分数部分<span
class="math inline">\(d_i\)</span>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">gather</span><span class="params">(<span class="type">double</span> li, <span class="type">const</span> dvector &amp;field)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">int</span>(li);</span><br><span class="line">    <span class="type">double</span> di = li-i;</span><br><span class="line">    <span class="keyword">return</span> field[i]*(<span class="number">1</span>-di)+field[i+<span class="number">1</span>]*di;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">我们使用如下函数：</span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function">dvector <span class="title">ef</span><span class="params">(ni)</span></span>; <span class="comment">// 基于节点的电场</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ts=<span class="number">0</span>; ts&lt;<span class="number">2000</span>; ts++)&#123; <span class="comment">// 2000个时间步长</span></span><br><span class="line">    <span class="comment">// 粒子位置的电场</span></span><br><span class="line">    <span class="type">double</span> li = <span class="built_in">XtoL</span>(x, dx);</span><br><span class="line">    <span class="type">double</span> ef_p = <span class="built_in">gather</span>(li, ef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 速度和位置积分</span></span><br><span class="line">    v += (q/m)*ef_p*dt;</span><br><span class="line">    x += v*dt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="诊断">诊断</h3>
<p>我们现在已经实现了完成代码所需的所有部分。但是，就像任何计算机模拟一样，验证结果是否具有物理意义是很重要的。
粒子振荡源于能量的守恒。因此，我们应该检查能量是否确实得到了守恒。
在时刻<span
class="math inline">\(k\)</span>，一个粒子的总能量由其势能和动能之和给出:
<span class="math display">\[\begin{equation}
    \frac12mv^2+q(\phi-\phi_{max})=C
\end{equation}\]</span> 其中<span
class="math inline">\(C\)</span>是常数。实现这个诊断检查要求在同一物理时间评估速度与位置。
通过我们的leapfrog，这两个参数实际上有半个时间步长的offset，速度落后于位置。
一种可能性是通过追踪旧位置来使两个参数处于相同的物理时间，在<span
class="math inline">\(x^{k-0.5}=(x^k+x^{k-1})/2\)</span>。
将两种能量从焦耳转换为电子伏特，方法是将它们除以基本电荷。
通过一下代码实现： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> phi_p = <span class="built_in">gather</span>(<span class="built_in">XtoL</span>((x+x_old)/<span class="number">2</span>, dx) phi); <span class="comment">// phi(x(k-0.5))</span></span><br><span class="line"><span class="type">double</span> ke = <span class="number">0.5</span>*m*v*v/QE; <span class="comment">// KE in eV</span></span><br><span class="line"><span class="type">double</span> pe = q*(phi_p-phi_max)/QE; <span class="comment">// PE in eV</span></span><br></pre></td></tr></table></figure></p>
<h2 id="全部代码">全部代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// constants</span></span><br><span class="line"><span class="keyword">namespace</span> Const&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> QE = <span class="number">1.602176634e-19</span>; <span class="comment">// C, 单位电荷</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> ME = <span class="number">9.10938356e-31</span>; <span class="comment">// kg, 单位质量   </span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> EPS0 = <span class="number">8.854187817e-12</span>; <span class="comment">// F/m, 真空电界常数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Const;  </span><br><span class="line"><span class="keyword">using</span> dvector = vector&lt;<span class="type">double</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数 prototypes (声明？)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">outputCSV</span><span class="params">(<span class="type">double</span> x0, <span class="type">double</span> dx, <span class="type">const</span> dvector &amp;phi, <span class="type">const</span> dvector &amp;rho, <span class="type">const</span> dvector &amp;ef)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solvePotentialDirect</span><span class="params">(<span class="type">double</span> dx, dvector &amp;phi, <span class="type">const</span> dvector &amp;rho)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solvePotentialGS</span><span class="params">(<span class="type">double</span> dx, dvector &amp;phi, <span class="type">const</span> dvector &amp;rho, <span class="type">int</span> max_it=<span class="number">5000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">computeEfield</span><span class="params">(<span class="type">double</span> dx, dvector &amp;ef, <span class="type">const</span> dvector &amp;phi, <span class="type">bool</span> second_order=<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">gather</span><span class="params">(<span class="type">double</span> li, <span class="type">const</span> dvector &amp;field)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将物理坐标x转化为逻辑坐标l</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">XtoL</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> dx, <span class="type">double</span> x0 = <span class="number">0</span>)</span></span>&#123;<span class="keyword">return</span> (x-x0)/dx;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ni = <span class="number">21</span>;          <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> x0 = <span class="number">0</span>;        <span class="comment">// 原点</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> xd = <span class="number">0.1</span>;          <span class="comment">// 长度</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> dx = (xd-x0)/(ni<span class="number">-1</span>); <span class="comment">// 网格间距</span></span><br><span class="line"></span><br><span class="line">    <span class="function">dvector <span class="title">rho</span><span class="params">(ni, QE*<span class="number">1e12</span>)</span></span>;      <span class="comment">// 电荷密度</span></span><br><span class="line">    <span class="function">dvector <span class="title">ef</span><span class="params">(ni)</span></span>;     <span class="comment">// 电场</span></span><br><span class="line">    <span class="function">dvector <span class="title">phi</span><span class="params">(ni)</span></span>;     <span class="comment">// 电势</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求解电势</span></span><br><span class="line">    <span class="built_in">solvePotentialGS</span>(dx, phi, rho);</span><br><span class="line">    <span class="comment">// solvePotentialDirect(dx, phi, rho);  // 替换求解器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算电场</span></span><br><span class="line">    <span class="built_in">computeEF</span>(dx, ef, phi, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成测试电子</span></span><br><span class="line">    <span class="type">double</span> m = ME;</span><br><span class="line">    <span class="type">double</span> q = -QE;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">4</span>*dx;    <span class="comment">// four cells from left edge</span></span><br><span class="line">    <span class="type">double</span> v = <span class="number">0</span>;   <span class="comment">//  静止</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> dt = <span class="number">1e-10</span>;  <span class="comment">//  时间步长</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 速度rewind</span></span><br><span class="line">    <span class="type">double</span> li = <span class="built_in">XtoL</span>(x, dx);</span><br><span class="line">    <span class="type">double</span> ef_p = <span class="built_in">gather</span>(li, ef);</span><br><span class="line">    v -= <span class="number">0.5</span>*(q/m)*ef_p*dt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为PE计算保存初始电场</span></span><br><span class="line">    <span class="type">double</span> phi_max = phi[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;ni; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (phi[i] &gt; phi_max) </span><br><span class="line">            phi_max = phi[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开粒子追踪的文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;trace.csv&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!out) &#123;cerr&lt;&lt;<span class="string">&quot;未打开trace文件&quot;</span>&lt;&lt;endl; <span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line">    out&lt;&lt;<span class="string">&quot; time, x, v, KE, PE\n&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">double</span> x_old = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 粒子循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ts=<span class="number">1</span>; ts&lt;<span class="number">4000</span>; ts++)&#123;</span><br><span class="line">        <span class="comment">// 粒子位置处的网格数据</span></span><br><span class="line">        <span class="type">double</span> li =<span class="built_in">XtoL</span>(x, dx);</span><br><span class="line">        <span class="type">double</span> ef_p = <span class="built_in">gather</span>(li, ef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 速度和位置积分</span></span><br><span class="line">        x_old = x;</span><br><span class="line">        v += (q/m)*ef_p*dt;</span><br><span class="line">        x += v*dt;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> phi_p = <span class="built_in">gather</span>(<span class="built_in">XtoL</span>(<span class="number">0.5</span>*(x+x_old), dx), phi);</span><br><span class="line">        <span class="comment">// phi (x(k-0.5))</span></span><br><span class="line">        <span class="type">double</span> ke = <span class="number">0.5</span>*m*v*v/QE;       <span class="comment">// KE in eV</span></span><br><span class="line">        <span class="type">double</span> pe = q*(phi_p-phi_max)/QE;  <span class="comment">// PE in eV</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入到文件中</span></span><br><span class="line">        out&lt;&lt;ts*dt&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;v&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;ke&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;pe&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ts==<span class="number">1</span> || ts%<span class="number">1000</span>==<span class="number">0</span>)&#123;       <span class="comment">// 每1000时间步向屏幕输出</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;ts: &quot;</span>&lt;&lt;ts&lt;&lt;<span class="string">&quot;, x: &quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;, v: &quot;</span>&lt;&lt;v&lt;&lt;<span class="string">&quot;, KE: &quot;</span>&lt;&lt;ke&lt;&lt;<span class="string">&quot;, PE: &quot;</span>&lt;&lt;pe&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结果输出到CSV文件</span></span><br><span class="line">        <span class="built_in">outputCSV</span>(ni, dx, phi, rho, ef);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// normal exit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定的场输出到CSV文件中，如果成功则返回true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">outputCSV</span><span class="params">(<span class="type">double</span> x0, <span class="type">double</span> dx, <span class="type">const</span> dvector &amp;phi, <span class="type">const</span> dvector &amp;rho, <span class="type">const</span> dvector &amp;ef)</span></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;results.csv&quot;</span>)</span></span>;    <span class="comment">//打开文件以写入</span></span><br><span class="line">    <span class="keyword">if</span> (!out) &#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;未打开results文件&quot;</span>&lt;&lt;endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out&lt;&lt;<span class="string">&quot;x,phi,rho,ef&quot;</span>&lt;&lt;endl;      <span class="comment">// write header</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;phi.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        out&lt;&lt;x0+i*dx;</span><br><span class="line">        out&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;phi[i]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;rho[i]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;ef[i];  <span class="comment">// write values</span></span><br><span class="line">        out&lt;&lt;<span class="string">&quot;\n&quot;</span>;      <span class="comment">// 新line， not using endl to avoid buffer flush</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// 文件在此处自动关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Thomas 算法求解泊松方程with Dirichlet boundaries</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solvePotentialDirect</span><span class="params">(<span class="type">double</span> dx, dvector &amp;phi, <span class="type">const</span> dvector &amp;rho)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ni = phi.<span class="built_in">size</span>();    <span class="comment">//  mesh节点的数量</span></span><br><span class="line">    <span class="function">dvector <span class="title">a</span><span class="params">(ni)</span></span>;  <span class="comment">// 为矩阵系数分配内存</span></span><br><span class="line">    <span class="function">dvector <span class="title">b</span><span class="params">(ni)</span></span>;</span><br><span class="line">    <span class="function">dvector <span class="title">c</span><span class="params">(ni)</span></span>;</span><br><span class="line">    <span class="function">dvector <span class="title">d</span><span class="params">(ni)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定系数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ni; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span> || i==ni<span class="number">-1</span>)&#123;   <span class="comment">// Dirichlet 边界</span></span><br><span class="line">            b[i] = <span class="number">1</span>;   <span class="comment">// 斜对角为1</span></span><br><span class="line">            d[i] = <span class="number">0</span>;   <span class="comment">// RHS， 0 V</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a[i] = <span class="number">1</span>/(dx*dx);</span><br><span class="line">            b[i] = <span class="number">-2</span>/(dx*dx);</span><br><span class="line">            c[i] = <span class="number">1</span>/(dx*dx);</span><br><span class="line">            d[i] = -rho[i]/EPS_0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    c[<span class="number">0</span>] = c[<span class="number">0</span>]/b[<span class="number">0</span>];</span><br><span class="line">    d[<span class="number">0</span>] = d[<span class="number">0</span>]/b[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前步骤</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;ni; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;ni<span class="number">-1</span>)</span><br><span class="line">            c[i] = c[i]/(b[i]-a[i]*c[i<span class="number">-1</span>]);</span><br><span class="line">        d[i] = (d[i] - a[i]*d[i<span class="number">-1</span>])/(b[i] - a[i]*c[i - <span class="number">1</span>]);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回代</span></span><br><span class="line">    phi[ni - <span class="number">1</span>] = d[ni - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=ni<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        phi[i] = d[i] - c[i]*phi[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Gauss seidel方法求解势函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solvePotentialGS</span><span class="params">(<span class="type">double</span> dx, dvector &amp;phi, <span class="type">const</span> dvector &amp;rho, <span class="type">int</span> max_it)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> L2;</span><br><span class="line">    <span class="type">double</span> dx2 = dx*dx;  <span class="comment">// 预计算 dx*dx</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> w = <span class="number">1.4</span>;</span><br><span class="line">    <span class="type">int</span> ni = phi.<span class="built_in">size</span>();    <span class="comment">// mesh nodes 的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求解势</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> solver_it = <span class="number">0</span>; solver_it &lt; max_it; solver_it++)&#123;</span><br><span class="line">        phi[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">// Dirichlet 边界 on left</span></span><br><span class="line">        phi[ni<span class="number">-1</span>] = <span class="number">0</span>; <span class="comment">// Dirichlet 边界 on right</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Gauss Seidel 方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;ni<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="type">double</span> g = <span class="number">0.5</span>*(phi[i<span class="number">-1</span>]+phi[i+<span class="number">1</span>]+dx2*rho[i]/EPS_0);</span><br><span class="line">            phi[i] = phi[i] + w*(g-phi[i]); <span class="comment">// SOR</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收敛性检查</span></span><br><span class="line">        <span class="keyword">if</span> (solver_it%<span class="number">50</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 内部节点，自动满足Dirichlet boundaries</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;ni<span class="number">-1</span>; i++)&#123;</span><br><span class="line">                <span class="type">double</span> R = -rho[i]/EPS_0 - (phi[i<span class="number">-1</span>] - <span class="number">2</span>*phi[i] + phi[i+<span class="number">1</span>])/dx2;</span><br><span class="line">                sum += R*R;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            L2 = <span class="built_in">sqrt</span>(sum/(ni<span class="number">-2</span>));</span><br><span class="line">            <span class="keyword">if</span> (L2&lt;<span class="number">1e-6</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Gauss-Seidel converged after &quot;</span>&lt;&lt;solver_it&lt;&lt;<span class="string">&quot; iterations.&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Gauss-Seidel failed to converge, L2 = &quot;</span>&lt;&lt;L2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过差分电势计算电场</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculateEF</span><span class="params">(<span class="type">double</span> dx, dvector &amp;ef, <span class="type">const</span> dvector &amp;phi, <span class="type">bool</span> second_order)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ni = phi.<span class="built_in">size</span>();    <span class="comment">//网格节点数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 整数节点的中心差分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;ni<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        ef[i] = -(phi[i+<span class="number">1</span>] - phi[i<span class="number">-1</span>])/(<span class="number">2</span>*dx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (second_order)&#123;</span><br><span class="line">        ef[<span class="number">0</span>] = (<span class="number">3</span>*phi[<span class="number">0</span>] - <span class="number">4</span>*phi[<span class="number">1</span>] + phi[<span class="number">2</span>])/(<span class="number">2</span>*dx);</span><br><span class="line">        ef[ni<span class="number">-1</span>] = (-phi[ni<span class="number">-3</span>] + <span class="number">4</span>*phi[ni<span class="number">-2</span>] - <span class="number">3</span>*phi[ni<span class="number">-1</span>])/(<span class="number">2</span>*dx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 一阶</span></span><br><span class="line">        ef[<span class="number">0</span>] = (phi[<span class="number">0</span>] - phi[<span class="number">1</span>])/dx;</span><br><span class="line">        ef[ni<span class="number">-1</span>] = (phi[ni<span class="number">-2</span>] - phi[ni<span class="number">-1</span>])/dx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用线性插值在li处得到f</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">gather</span><span class="params">(<span class="type">double</span> li, <span class="type">const</span> dvector &amp;f)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)li;</span><br><span class="line">    <span class="type">double</span> di = li-i;</span><br><span class="line">    <span class="keyword">return</span> f[i]*(<span class="number">1</span>-di) + f[i+<span class="number">1</span>]*di;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="python实现numba加速">python实现(numba加速)</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.constants <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 该模块包含了所需的真空介电常数: epsilon_0、电子电荷: e、电子质量m_e: 9.10938215e-31;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将给定的场输出到CSV文件中，如果成功则返回true</span></span><br><span class="line"><span class="comment"># 不能在nopython=True下使用Numba来加速涉及到文件IO（输入/输出）的代码块</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outputCSV</span>(<span class="params">x0, dx, phi, rho,  ef</span>):</span><br><span class="line">    <span class="comment"># 打开results.csv，如果不存在该文件则报错</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/results.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">            <span class="comment"># 创建一个csv写入器</span></span><br><span class="line">            writer = csv.writer(csvfile)</span><br><span class="line">            <span class="comment"># 写入表头</span></span><br><span class="line">            writer.writerow([<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;phi&#x27;</span>, <span class="string">&#x27;rho&#x27;</span>, <span class="string">&#x27;ef&#x27;</span>])</span><br><span class="line">            <span class="comment"># 写入数据</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(phi)):</span><br><span class="line">                <span class="comment"># print(3)</span></span><br><span class="line">                writer.writerow([x0+i*dx, phi[i], rho[i], ef[i]])  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: Can&#x27;t open results.csv，该文件不存在&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outputCSV_trace</span>(<span class="params">time, x, v, KE, PE</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/trace.csv&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">            <span class="comment"># 创建一个csv写入器</span></span><br><span class="line">            writer = csv.writer(csvfile)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 写入</span></span><br><span class="line">            writer.writerow([time, x, v, KE, PE])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: Can&#x27;t open trace.csv，该文件不存在&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Thomas 算法求解泊松方程with Dirichlet boundaries</span></span><br><span class="line"><span class="meta">@jit(<span class="params">nopython=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solvePotentialDirect</span>(<span class="params">dx, phi, rho</span>):</span><br><span class="line">    ni = <span class="built_in">len</span>(phi)   <span class="comment">#网格节点的数量</span></span><br><span class="line">    a = np.zeros(ni)    <span class="comment">#为矩阵系数分配内存</span></span><br><span class="line">    b = np.zeros(ni)</span><br><span class="line">    c = np.zeros(ni)</span><br><span class="line">    d = np.zeros(ni)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设定系数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, ni):</span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> i==ni-<span class="number">1</span>: <span class="comment"># Dirichlet 边界</span></span><br><span class="line">            b[i] = <span class="number">1</span>    <span class="comment"># 斜对角为1</span></span><br><span class="line">            d[i] = <span class="number">0</span>    <span class="comment"># RHS， 0 V</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a[i] = <span class="number">1</span> / (dx * dx)</span><br><span class="line">            b[i] = -<span class="number">2</span> / (dx * dx)</span><br><span class="line">            c[i] = <span class="number">1</span> / (dx * dx)</span><br><span class="line">            d[i] = -rho[i] / EPS_0</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    c[<span class="number">0</span>] = c[<span class="number">0</span>] / b[<span class="number">0</span>]</span><br><span class="line">    d[<span class="number">0</span>] = d[<span class="number">0</span>] / b[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向前步骤</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ni):</span><br><span class="line">        <span class="keyword">if</span> i &lt; ni - <span class="number">1</span>:</span><br><span class="line">            c[i] = c[i] / (b[i] - a[i] * c[i - <span class="number">1</span>])</span><br><span class="line">        d[i] = (d[i] - a[i] * d[i - <span class="number">1</span>]) / (b[i] - a[i] * c[i - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 回代</span></span><br><span class="line">    phi[ni - <span class="number">1</span>] = d[ni - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ni - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        phi[i] = d[i] - c[i] * phi[i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Gauss Seidel方法求解势函数</span></span><br><span class="line"><span class="meta">@jit(<span class="params">nopython=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solvePotentialGS</span>(<span class="params">dx, phi, rho, max_it</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    dx: 网格间距，类型：浮点</span></span><br><span class="line"><span class="string">    phi: 电势，类型：数组</span></span><br><span class="line"><span class="string">    rho: 电荷密度，类型：数组</span></span><br><span class="line"><span class="string">    max_it: 最大迭代次数，类型：整数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    L2 = <span class="number">0</span></span><br><span class="line">    dx2 = dx * dx</span><br><span class="line">    w = <span class="number">1.4</span></span><br><span class="line">    ni = <span class="built_in">len</span>(phi)  <span class="comment"># mesh nodes 的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 求解势</span></span><br><span class="line">    <span class="keyword">for</span> solver_it <span class="keyword">in</span> <span class="built_in">range</span>(max_it):</span><br><span class="line">        phi[<span class="number">0</span>] = <span class="number">0</span>  <span class="comment"># Dirichlet 边界 on left</span></span><br><span class="line">        phi[ni - <span class="number">1</span>] = <span class="number">0</span>  <span class="comment"># Dirichlet 边界 on right</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Gauss Seidel 方法</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ni - <span class="number">1</span>):</span><br><span class="line">            g = <span class="number">0.5</span> * (phi[i - <span class="number">1</span>] + phi[i + <span class="number">1</span>] + dx2 * rho[i] / EPS_0)</span><br><span class="line">            phi[i] = phi[i] + w * (g - phi[i])  <span class="comment"># SOR</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 收敛性检查</span></span><br><span class="line">        <span class="keyword">if</span> solver_it % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 内部节点，自动满足Dirichlet boundaries</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ni - <span class="number">1</span>):</span><br><span class="line">                R = -rho[i] / EPS_0 - (phi[i - <span class="number">1</span>] - <span class="number">2</span> * phi[i] + phi[i + <span class="number">1</span>]) / dx2</span><br><span class="line">                <span class="built_in">sum</span> += R * R</span><br><span class="line"></span><br><span class="line">            L2 = np.sqrt(<span class="built_in">sum</span> / (ni - <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> L2 &lt; <span class="number">1e-6</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Gauss-Seidel converged after &quot;</span> + <span class="built_in">str</span>(solver_it) + <span class="string">&quot; iterations.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Gauss-Seidel failed to converge, L2 = &quot;</span> + <span class="built_in">str</span>(L2))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过差分电势计算电场</span></span><br><span class="line"><span class="meta">@jit(<span class="params">nopython=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculateEF</span>(<span class="params">dx, ef, phi, second_order</span>):</span><br><span class="line">    ni = <span class="built_in">len</span>(phi)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ni-<span class="number">1</span>):</span><br><span class="line">        ef[i] = -(phi[i+<span class="number">1</span>] - phi[i-<span class="number">1</span>])/(<span class="number">2</span>*dx)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> second_order:</span><br><span class="line">        ef[<span class="number">0</span>] = (<span class="number">3</span>*phi[<span class="number">0</span>] - <span class="number">4</span>*phi[<span class="number">1</span>] + phi[<span class="number">2</span>])/(<span class="number">2</span>*dx)</span><br><span class="line">        ef[ni-<span class="number">1</span>] = (-phi[ni-<span class="number">3</span>] + <span class="number">4</span>*phi[ni-<span class="number">2</span>] - <span class="number">3</span>*phi[ni-<span class="number">1</span>])/(<span class="number">2</span>*dx)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ef[<span class="number">0</span>] = (phi[<span class="number">0</span>] - phi[<span class="number">1</span>])/dx</span><br><span class="line">        ef[ni-<span class="number">1</span>] = (phi[ni-<span class="number">2</span>] - phi[ni-<span class="number">1</span>])/dx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用线性插值在li处得到f</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gather</span>(<span class="params">li, f</span>):</span><br><span class="line">    i = <span class="built_in">int</span>(li)</span><br><span class="line">    di = li-i</span><br><span class="line">    <span class="keyword">return</span> f[i]*(<span class="number">1</span>-di) + f[i+<span class="number">1</span>]*di</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将物理坐标x转化为逻辑坐标</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">X2L</span>(<span class="params">x, dx, x0=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">return</span> (x-x0)/dx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 物理量</span></span><br><span class="line">EPS_0 = epsilon_0</span><br><span class="line">QE = e</span><br><span class="line">ME = m_e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义常量</span></span><br><span class="line">ni = <span class="number">21</span>  <span class="comment"># 节点数量</span></span><br><span class="line">x0 = <span class="number">0</span>    <span class="comment">#  网格起点</span></span><br><span class="line">xd = <span class="number">0.1</span>  <span class="comment">#   终点端</span></span><br><span class="line">dx = (xd-x0)/(ni-<span class="number">1</span>) <span class="comment"># 节点空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建存储数组</span></span><br><span class="line">phi = np.zeros(ni) <span class="comment"># 电势</span></span><br><span class="line">rho = np.full(ni, e*<span class="number">1e12</span>) <span class="comment"># 电荷密度</span></span><br><span class="line">ef = np.zeros(ni) <span class="comment"># 电场</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解势</span></span><br><span class="line">solvePotentialGS(dx, phi, rho, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算电场</span></span><br><span class="line">calculateEF(dx, ef, phi, second_order=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成测试电子</span></span><br><span class="line"></span><br><span class="line">m = ME</span><br><span class="line">q = -QE</span><br><span class="line">x = <span class="number">4</span>*dx    <span class="comment"># four cells from left edge</span></span><br><span class="line">v = <span class="number">0</span>   <span class="comment"># 静止</span></span><br><span class="line"></span><br><span class="line">dt = <span class="number">1e-10</span>  <span class="comment"># 时间步</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 速度时间回退</span></span><br><span class="line">li = X2L(x,dx)</span><br><span class="line">ef_p = gather(li,ef)</span><br><span class="line">v -= <span class="number">0.5</span>*(q/m)*ef_p*dt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为PE计算保存初始电势</span></span><br><span class="line">phi_max = phi[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ni):</span><br><span class="line">    <span class="keyword">if</span> phi[i] &gt; phi_max:</span><br><span class="line">        phi_max = phi[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开粒子追踪文件</span></span><br><span class="line">outputCSV_trace(<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;KE&#x27;</span>, <span class="string">&#x27;PE&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x_old = x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 粒子循环</span></span><br><span class="line"><span class="keyword">for</span> ts <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4000</span>):</span><br><span class="line">    <span class="comment"># 粒子位置处的网格数据</span></span><br><span class="line">    li = X2L(x, dx)</span><br><span class="line">    ef_p = gather(li, ef)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 速度和位置积分</span></span><br><span class="line">    x_old = x</span><br><span class="line">    v += (q/m)*ef_p*dt</span><br><span class="line">    x += v*dt</span><br><span class="line"></span><br><span class="line">    phi_p = gather(X2L(<span class="number">0.5</span>*(x+x_old), dx), phi)</span><br><span class="line">    <span class="comment"># phi (x(k-0.5))</span></span><br><span class="line">    ke = <span class="number">0.5</span>*m*v*v/QE      <span class="comment"># KE in eV</span></span><br><span class="line">    pe = q*(phi_p-phi_max)/QE   <span class="comment"># PE in eV</span></span><br><span class="line"></span><br><span class="line">    outputCSV_trace(ts*dt, x, v, ke, pe)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ts == <span class="number">1</span> <span class="keyword">or</span> ts % <span class="number">1000</span> == <span class="number">0</span>:  <span class="comment"># 使用 `or` 而不是 `||` 来连接条件</span></span><br><span class="line">    <span class="comment"># 使用 Python 的 print 函数和 f-string 来格式化输出</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;ts: <span class="subst">&#123;ts&#125;</span>, x: <span class="subst">&#123;x&#125;</span>, v: <span class="subst">&#123;v&#125;</span>, KE: <span class="subst">&#123;ke&#125;</span>, PE: <span class="subst">&#123;pe&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    outputCSV(x0, dx, phi, rho, ef)</span><br></pre></td></tr></table></figure>
<h2 id="julia实现">Julia实现</h2>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LinearAlgebra</span><br><span class="line"><span class="keyword">using</span> Printf</span><br><span class="line"><span class="keyword">using</span> CSV</span><br><span class="line"><span class="keyword">using</span> DataFrames</span><br><span class="line"><span class="keyword">using</span> PhysicalConstants.CODATA2018</span><br><span class="line"><span class="keyword">using</span> Unitful</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将给定的场输出到CSV文件中</span></span><br><span class="line"><span class="keyword">function</span> outputCSV(x0, dx, phi, rho, ef)</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        df = DataFrame(x = x0 .+ (<span class="number">0</span>:length(phi)-<span class="number">1</span>) * dx,</span><br><span class="line">                       phi = phi,</span><br><span class="line">                       rho = rho,</span><br><span class="line">                       ef = ef)</span><br><span class="line">        CSV.write(<span class="string">&quot;/path/to//results.csv&quot;</span>, df)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">catch</span> e</span><br><span class="line">        println(<span class="string">&quot;Error: Can&#x27;t open results.csv，该文件不存在&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将粒子跟踪信息输出到CSV文件中</span></span><br><span class="line"><span class="keyword">function</span> outputCSV_trace(time, x, v, KE, PE)</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        df = DataFrame(time = time,</span><br><span class="line">                       x = x,</span><br><span class="line">                       v = v,</span><br><span class="line">                       KE = KE,</span><br><span class="line">                       PE = PE)</span><br><span class="line">        CSV.write(<span class="string">&quot;/path/to/trace.csv&quot;</span>, df, append = <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">catch</span> e</span><br><span class="line">        println(<span class="string">&quot;Error: Can&#x27;t open trace.csv，该文件不存在&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Gauss Seidel方法求解势函数</span></span><br><span class="line"><span class="keyword">function</span> solvePotentialGS(dx, phi, rho, max_it)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    dx: 网格间距，类型: 浮点</span></span><br><span class="line"><span class="string">    phi: 电势，类型: 数组</span></span><br><span class="line"><span class="string">    rho: 电荷密度，类型: 数组</span></span><br><span class="line"><span class="string">    max_it: 最大迭代次数，类型: 整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    L2 = <span class="number">0.0</span></span><br><span class="line">    dx2 = dx * dx</span><br><span class="line">    w = <span class="number">1.4</span></span><br><span class="line">    ni = length(phi)  <span class="comment"># mesh nodes 的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 求解势</span></span><br><span class="line">    <span class="keyword">for</span> solver_it <span class="keyword">in</span> <span class="number">1</span>:max_it</span><br><span class="line">        phi[<span class="number">1</span>] = <span class="number">0.0</span>  <span class="comment"># Dirichlet 边界 on left</span></span><br><span class="line">        phi[ni] = <span class="number">0.0</span>  <span class="comment"># Dirichlet 边界 on right</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Gauss Seidel 方法</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">2</span>:(ni - <span class="number">1</span>)</span><br><span class="line">            g = <span class="number">0.5</span> * (phi[i - <span class="number">1</span>] + phi[i + <span class="number">1</span>] + dx2 * rho[i] / EPS_0)</span><br><span class="line">            phi[i] = phi[i] + w * (g - phi[i])  <span class="comment"># SOR</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 收敛性检查</span></span><br><span class="line">        <span class="keyword">if</span> solver_it % <span class="number">50</span> == <span class="number">0</span></span><br><span class="line">            sum = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 内部节点，自动满足Dirichlet boundaries</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">2</span>:(ni - <span class="number">1</span>)</span><br><span class="line">                R = -rho[i] / EPS_0 - (phi[i - <span class="number">1</span>] - <span class="number">2</span> * phi[i] + phi[i + <span class="number">1</span>]) / dx2</span><br><span class="line">                sum += R * R</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            L2 = sqrt(sum / (ni - <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> L2 &lt; <span class="number">1e-6</span></span><br><span class="line">                <span class="meta">@printf</span> <span class="string">&quot;Gauss-Seidel converged after %d iterations.\n&quot;</span> solver_it</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@printf</span> <span class="string">&quot;Gauss-Seidel failed to converge, L2 = %.6e\n&quot;</span> L2</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过差分电势计算电场</span></span><br><span class="line"><span class="keyword">function</span> calculateEF(dx, ef, phi, second_order)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    dx: 网格间距，类型: 浮点</span></span><br><span class="line"><span class="string">    ef: 电场，类型: 数组</span></span><br><span class="line"><span class="string">    phi: 电势，类型: 数组</span></span><br><span class="line"><span class="string">    second_order: 是否使用二阶中心差分，类型: 布尔值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    ni = length(phi)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">2</span>:(ni-<span class="number">1</span>)</span><br><span class="line">        ef[i] = -(phi[i+<span class="number">1</span>] - phi[i-<span class="number">1</span>]) / (<span class="number">2</span>*dx)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> second_order</span><br><span class="line">        ef[<span class="number">1</span>] = (<span class="number">3</span>*phi[<span class="number">1</span>] - <span class="number">4</span>*phi[<span class="number">2</span>] + phi[<span class="number">3</span>]) / (<span class="number">2</span>*dx)</span><br><span class="line">        ef[ni] = (-phi[ni-<span class="number">2</span>] + <span class="number">4</span>*phi[ni-<span class="number">1</span>] - <span class="number">3</span>*phi[ni]) / (<span class="number">2</span>*dx)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ef[<span class="number">1</span>] = (phi[<span class="number">1</span>] - phi[<span class="number">2</span>]) / dx</span><br><span class="line">        ef[ni] = (phi[ni-<span class="number">1</span>] - phi[ni]) / dx</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> gather(li, f)</span><br><span class="line">    i = <span class="built_in">Int</span>(floor(li))</span><br><span class="line">    di = li - i</span><br><span class="line">    <span class="keyword">return</span> f[i] * (<span class="number">1</span> - di) + f[i + <span class="number">1</span>] * di</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> X2L(x, dx, x0=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (x - x0) / dx +<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义常量</span></span><br><span class="line">EPS_0 = ustrip(PhysicalConstants.CODATA2018.ε_0)   <span class="comment"># 真空介电常数</span></span><br><span class="line">QE = ustrip(PhysicalConstants.CODATA2018.e)          <span class="comment"># 电子电荷</span></span><br><span class="line">ME = ustrip(PhysicalConstants.CODATA2018.m_e)         <span class="comment"># 电子质量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义网格常量</span></span><br><span class="line">ni = <span class="number">21</span>  <span class="comment"># 节点数量</span></span><br><span class="line">x0 = <span class="number">0</span>    <span class="comment">#  网格起点</span></span><br><span class="line">xd = <span class="number">0.1</span>  <span class="comment">#   终点端</span></span><br><span class="line">dx = (xd-x0)/(ni-<span class="number">1</span>) <span class="comment"># 节点空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建存储数组</span></span><br><span class="line">phi = zeros(ni)  <span class="comment"># 电势</span></span><br><span class="line">rho = fill(QE*<span class="number">1e12</span>, ni)  <span class="comment"># 电荷密度</span></span><br><span class="line">ef = zeros(ni)  <span class="comment"># 电场</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解势</span></span><br><span class="line">solvePotentialGS(dx, phi, rho, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算电场</span></span><br><span class="line">calculateEF(dx, ef, phi, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成测试电子</span></span><br><span class="line"></span><br><span class="line">m = ME</span><br><span class="line">q = -QE</span><br><span class="line">x = <span class="number">4</span>*dx    <span class="comment"># four cells from left edge</span></span><br><span class="line">v = <span class="number">0</span>   <span class="comment"># 静止</span></span><br><span class="line"></span><br><span class="line">dt = <span class="number">1e-10</span>  <span class="comment"># 时间步</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 速度时间回退</span></span><br><span class="line">li = X2L(x, dx)</span><br><span class="line">ef_p = gather(li, ef)</span><br><span class="line">v -= <span class="number">0.5</span>*(q/m)*ef_p*dt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为PE计算保存初始电势</span></span><br><span class="line">phi_max = phi[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">2</span>:ni</span><br><span class="line">    <span class="keyword">if</span> phi[i] &gt; phi_max</span><br><span class="line">        <span class="keyword">global</span> phi_max = phi[i]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开粒子追踪文件</span></span><br><span class="line">outputCSV_trace(<span class="string">&quot;time&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="string">&quot;KE&quot;</span>, <span class="string">&quot;PE&quot;</span>)</span><br><span class="line"></span><br><span class="line">x_old = x</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ts <span class="keyword">in</span> <span class="number">1</span>:<span class="number">3999</span></span><br><span class="line">    <span class="comment"># 粒子位置处的逻辑坐标与</span></span><br><span class="line">    li = X2L(x, dx)</span><br><span class="line">    ef_p = gather(li, ef)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 速度和位置积分</span></span><br><span class="line">    <span class="keyword">global</span> x_old = x</span><br><span class="line">    <span class="keyword">global</span> v += (q/m) * ef_p * dt</span><br><span class="line">    <span class="keyword">global</span> x += v * dt</span><br><span class="line"></span><br><span class="line">    phi_p = gather(X2L(<span class="number">0.5</span> * (x + x_old), dx), phi)</span><br><span class="line">    <span class="comment"># phi (x(k-0.5))</span></span><br><span class="line">    ke = <span class="number">0.5</span> * m * v * v / QE  <span class="comment"># KE in eV</span></span><br><span class="line">    pe = q * (phi_p - phi_max) / QE  <span class="comment"># PE in eV</span></span><br><span class="line"></span><br><span class="line">    outputCSV_trace(ts * dt, x, v, ke, pe)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ts == <span class="number">1</span> || ts % <span class="number">1000</span> == <span class="number">0</span></span><br><span class="line">        println(<span class="string">&quot;ts: <span class="variable">$ts</span>, x: <span class="variable">$x</span>, v: <span class="variable">$v</span>, KE: <span class="variable">$ke</span>, PE: <span class="variable">$pe</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    outputCSV(x0, dx, phi, rho, ef)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img src="/images/plasma-sec-1-1-11.png" /></div><div class="group-picture-column"><img
src="/images/plasma-sec-1-1-12.png" /></div></div></div>
<h2 id="小结">小结</h2>
<p>等离子体计算的流程图</p>
<img src="/images/%E5%8D%95%E4%B8%AA%E7%94%B5%E5%AD%90%E5%9C%A8%E7%A6%BB%E5%AD%90%E4%B8%AD%E7%9A%84%E8%BF%90%E5%8A%A8.png" class="" width="400">

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://g-d-zhou.github.io/year/01/04/ProbabilityAndStatistics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Dr. Zhou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="格物轩">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 格物轩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/year/01/04/ProbabilityAndStatistics/" class="post-title-link" itemprop="url">概率与统计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-04 11:02:32" itemprop="dateCreated datePublished" datetime="2024-01-04T11:02:32+08:00">2024-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-07 19:40:14" itemprop="dateModified" datetime="2024-04-07T19:40:14+08:00">2024-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%83%AD%E5%8A%9B%E5%AD%A6%E4%B8%8E%E7%BB%9F%E8%AE%A1%E7%89%A9%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">热力学与统计物理</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>来自实际分子动力学模拟的数据可能非常庞大。数据集变得极其巨大，因此我们需要有效的工具来突出最重要的方面。在这里，我们将引入概率的概念，以及概率的基本性质，如加法规则和乘法规则。我们将介绍概率分布和密度。我们将引入期望值和方差及其估计量，平均值和标准差。我们将介绍二项分布、正态分布和指数分布。我们将证明独立变量之和的分布通常呈正态分布，而与每个事件分布的细节无关。</p>
<p>统计学为我们提供了描述真实数据的工具，而概率论则为统计学提供了理论基础。在这里，我们将从基于事件频率的实用概率论方法开始，利用这个方法来建立概率的基本法则。这种方法对物理学家来说很直观，从计算视角考虑也是最直接的方法。</p>
<h2 id="motivating-example气体中的涨落">Motivating
example：气体中的涨落</h2>
<p>分子动力学模拟中，气体的运动呈现出大致随机的波动，因此物理量的测量也会有所变化。比如，箱子里左侧的原子数量n(t)，会随时间变化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2d Lennard-Jones gas</span></span><br><span class="line">units lj</span><br><span class="line">dimension <span class="number">2</span></span><br><span class="line">atom_style atomic</span><br><span class="line">lattice <span class="built_in">hex</span> <span class="number">0.10</span></span><br><span class="line">region box block <span class="number">0</span> <span class="number">20</span> <span class="number">0</span> <span class="number">10</span> -<span class="number">0.1</span> <span class="number">0.1</span></span><br><span class="line">create_box <span class="number">1</span> box</span><br><span class="line">create_atoms <span class="number">1</span> box</span><br><span class="line">mass <span class="number">1</span> <span class="number">1.0</span></span><br><span class="line">velocity <span class="built_in">all</span> create <span class="number">2.5</span> <span class="number">87287</span></span><br><span class="line">pair_style lj/cut <span class="number">2.5</span></span><br><span class="line">pair_coeff <span class="number">1</span> <span class="number">1</span> <span class="number">1.0</span> <span class="number">1.0</span> <span class="number">2.5</span></span><br><span class="line">neighbor <span class="number">0.3</span> <span class="built_in">bin</span></span><br><span class="line">neigh_modify every <span class="number">20</span> delay <span class="number">0</span> check no</span><br><span class="line">fix <span class="number">1</span> <span class="built_in">all</span> nve</span><br><span class="line">dump <span class="number">1</span> <span class="built_in">all</span> custom <span class="number">10</span> gasstat01.lammpstrj <span class="built_in">id</span> <span class="built_in">type</span> x y z vx vy vz thermo <span class="number">100</span></span><br><span class="line">run <span class="number">50000</span></span><br></pre></td></tr></table></figure>
<h2 id="概率">概率</h2>
<h3 id="统计实验">统计实验</h3>
<p>一项统计实验是具有多个可能结果或事件的尝试。实验的结果称为结果或事件，所有可能结果的集合称为样本空间。</p>
<p>许多物理系统，如气体，是相互关联的，因为在两次连续测量之间，系统的状态可能并未完全改变。</p>
<h3 id="生成随机数字">生成随机数字</h3>
<p>我们可以通过使用Python中的伪随机数生成器进行一次数值统计实验。我们生成一个介于1和6之间的随机数：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.random.randint(<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以进行4次这样的实验</span></span><br><span class="line">np.random.randint(<span class="number">0</span>,<span class="number">6</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="测量发生的频率">测量发生的频率</h3>
<p>首先，让我们来测量某个特定结果出现的频率，也就是绘制直方图。</p>
<h3 id="频率与概率">频率与概率</h3>
<p>频率是对过程内在性质的一种估计——即结果出现的概率。当我们进行无限多次实验时，我们可以将概率定义为频率。</p>
<h3 id="概率的性质">概率的性质</h3>
<p>归一化：所有结果出现的概率和为1。</p>
<p>当任何两个结果x无法同时发生，且求和覆盖了所有可能的结果x时，这被称为概率的归一化条件。
在概率论和统计学中，这个概念是用来确保概率模型正确表示了所有可能事件的完整性和互斥性。</p>
<p>补集规则：我们总可以把一个实验的所有可能结果分成两部分，即结果A发生和结果A不发生。这两者必有一个会发生，但不能同时发生。</p>
<p>此处，原文是讲了一些概率的基础，略。</p>
<h2 id="期望值与方差">期望值与方差</h2>
<p>此处，原文是讲了一些概率的基础，略。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://g-d-zhou.github.io/year/12/21/C-FundamentalsPart1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Dr. Zhou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="格物轩">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 格物轩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/year/12/21/C-FundamentalsPart1/" class="post-title-link" itemprop="url">C++ 学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-21 20:16:26" itemprop="dateCreated datePublished" datetime="2023-12-21T20:16:26+08:00">2023-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-02 09:42:41" itemprop="dateModified" datetime="2024-01-02T09:42:41+08:00">2024-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E4%B8%8E%E4%BB%BF%E7%9C%9F%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">数值分析与仿真基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="简单程序设计">简单程序设计</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 针对命令空间的指令</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, World!\n&quot;</span>&lt;&lt;endl; <span class="comment">//endl 表示换行符</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Welcome to C++ 1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if 实现选择语句</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">bool</span> isLeapYear;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter the year: &quot;</span>;</span><br><span class="line">    cin&gt;&gt;year; <span class="comment">//将提取符作用在流类对象cin上，键盘输入</span></span><br><span class="line">    isLeapYear = ((year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span>) || (year%<span class="number">400</span> == <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isLeapYear)</span><br><span class="line">        cout&lt;&lt;year&lt;&lt;<span class="string">&quot; is a leap year&quot;</span>&lt;&lt;endl; <span class="comment">// endl 插入换行符，并刷新流</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;year&lt;&lt;<span class="string">&quot; is not a leap year&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 嵌套的if语句</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter x and y:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x!=y)</span><br><span class="line">        <span class="keyword">if</span> (x&gt;y)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;x&gt;y&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;x&lt;y&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;x=y&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://g-d-zhou.github.io/year/12/21/AsSimple-as-itGets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Dr. Zhou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="格物轩">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 格物轩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/year/12/21/AsSimple-as-itGets/" class="post-title-link" itemprop="url">尽可能简单的示例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-12-21 15:49:30 / 修改时间：15:50:44" itemprop="dateCreated datePublished" datetime="2023-12-21T15:49:30+08:00">2023-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E4%B8%8E%E4%BB%BF%E7%9C%9F%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">数值分析与仿真基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a
target="_blank" rel="noopener" href="https://mooseframework.inl.gov/getting_started/examples_and_tutorials/examples/ex01_inputfile.html">Example
1 : As Simple as it Gets</a></p>
<h2 id="问题陈述">问题陈述</h2>
<p>该例子描述了创建基本输入文件以及利用MOOSE解决问题所需的六个部分。</p>
<p>考虑三维域<span
class="math inline">\(\Omega\)</span>中的稳态扩散方程：</p>
<p><span class="math display">\[\begin{equation}\label{M-1}
-\nabla \cdot \nabla u = 0 \in \Omega
\end{equation}\]</span></p>
<p>底部<span class="math inline">\(u=1\)</span>，顶部<span
class="math inline">\(u=0\)</span>，其余边界则是<span
class="math inline">\(\nabla u \cdot \hat{n}=0\)</span>。</p>
<p>该方程的弱形式，用内部相乘符号表示为：<span
class="math inline">\(\nabla \phi_i , \nabla u_h = 0 \ \forall \
\phi_i\)</span>，其中<span
class="math inline">\(\phi_i\)</span>是测试函数，<span
class="math inline">\(u_h\)</span>是有限元的解。</p>
<h2 id="输入文件">输入文件</h2>
<p>基本的输入文件包含六部分：</p>
<ul>
<li><p>网格</p></li>
<li><p>变量</p></li>
<li><p>内核(kernels)</p></li>
<li><p>边界条件(BCs)</p></li>
<li><p>Executioner</p></li>
<li><p>输出</p></li>
</ul>
<h2 id="网格">网格</h2>
<p>此处使用的是预生成的网格文件，如何生成后续教程会讲。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Mesh]</span><br><span class="line">  file = <span class="string">&#x27;mug.e&#x27;</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<h2 id="变量">变量</h2>
<p>对于这个简单的问题，只有一个变量，“扩散”，which represents u from the
continuous problem。 扩散变量近似是线性拉格朗日形状函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Variables]</span><br><span class="line">  [./diffused]</span><br><span class="line">    order = FIRST</span><br><span class="line">    family = LAGRANGE</span><br><span class="line">  [../]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<h2 id="内核">内核</h2>
<p>问题陈述的弱形式is represented by
扩散内核对象。一般而言，用户使用的是基于MOOSE的客制化内核，但MOOSE已经有定义好的扩散内核。
为了使用特定的内核，需要在输入文件里定义一个sub-section，标记为"diff"
(这是由用户任意定义的名字)，这将利用扩散内核，并对之前定义的变量"diffused"起作用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Kernels]</span><br><span class="line">  [./diff]</span><br><span class="line">    type = Diffusion</span><br><span class="line">    variable = diffused</span><br><span class="line">  [../]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<h2 id="边界条件">边界条件</h2>
<p>边界条件的定义类似于内核。对于这个问题，需要两个狄利克雷边界条件。在输入文件中，两个边界条件分别使用MOOSE提供的DirichletBC对象指定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[BCs]</span><br><span class="line">  [./bottom]</span><br><span class="line">    # 用户选择的任意名字</span><br><span class="line">    type = DirichletBC</span><br><span class="line">    variable = diffused</span><br><span class="line">    boundary = <span class="string">&#x27;bottom&#x27;</span> # 这必须匹配网格文件中的边界命名</span><br><span class="line">    value = <span class="number">1</span></span><br><span class="line">  [../]</span><br><span class="line"></span><br><span class="line">  [./top]</span><br><span class="line">    <span class="meta"># arbitrary user-chosen name</span></span><br><span class="line">    type = DirichletBC</span><br><span class="line">    variable = diffused</span><br><span class="line">    boundary = <span class="string">&#x27;top&#x27;</span> # 这必须匹配网格文件中的边界命名</span><br><span class="line">    value = <span class="number">0</span></span><br><span class="line">  [../]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>请注意，这个问题（左侧和右侧）的诺伊曼边界条件是隐含满足的，我们没有必要定义。然而，对于非零诺伊曼或其他边界条件，许多内置对象由MOOSE提供（例如NeumannBC）。您还可以创建从MOOSE中的现有对象派生的自定义边界条件。</p>
<h2 id="executioner">Executioner</h2>
<p>要解决的问题类型和解决方法在执行者块中定义。这个问题是稳态的，将使用稳态执行器，并将使用默认解决方法Preconditioned
Jacobain Free Newton Krylov。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Executioner]</span><br><span class="line">  type = Steady</span><br><span class="line">  solve_type = <span class="string">&#x27;PJFNK&#x27;</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<h2 id="输出">输出</h2>
<p>有两种输出的类型：输出到屏幕上(控制台)以及输出到Exodus II
文件(exodus)。
设定“file_base”参数是可选的，在本例中，它强制命名输出文件“out.e”
("e"是使用Exodus II格式的扩展名)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Outputs]</span><br><span class="line">  execute_on = <span class="string">&#x27;timestep_end&#x27;</span></span><br><span class="line">  exodus = <span class="literal">true</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<h2 id="运行该问题">运行该问题</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/projects/moose/examples/ex01_inputfile</span><br><span class="line">make -j8</span><br><span class="line">./ex01-opt -i ex01.i</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/index/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/index/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/index/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Dr. Zhou</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<!-- <br /> -->
<!-- Dr. Zhou从事科研工作的时间 -->
<span id="timeDate">载入天数...</span>
<!-- <span id="times">载入时分秒...</span> -->
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("08/02/2016 8:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
	years = (now - grt ) / 1000 / 60 / 60 / 24 / 365; ynum = Math.floor(years);
        days = (now - grt ) / 1000 / 60 / 60 / 24 - (365*ynum) ; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum)- (365*24*ynum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum)- (60*365*24*ynum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000- (60*60*365*24*ynum) - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); 
        if(String(snum).length ==1 ){snum = "0" + snum;}
        // var times = document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
        document.getElementById("timeDate").innerHTML = "Dr. Zhou 正式从事科研工作： "+ynum+" 年 " +dnum+" 天 "+hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/G-D-Zhou" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
