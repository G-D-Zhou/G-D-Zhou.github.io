<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo-32X32.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo-32X32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo-32X32.png">
  <link rel="mask-icon" href="/images/logo-32X32.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"g-d-zhou.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="&quot;Plasma Simulations by Example&quot;一书的学习笔记。 简介 模拟描述：等离子体被限制在一个接地的box内部，该Box接地且壁具有反射性。模拟运用静电PIC方法，并且是全动力学的。 这意味着离子和电子都被当作粒子来处理。虽然该模拟并没有那么令人兴奋，但它实际上会导致有趣的振荡现象。 还能够构建后续所有代码使用的基础框架。 模拟设置 模拟区域如下图所示：边长为0.2 m的立方">
<meta property="og:type" content="article">
<meta property="og:title" content="接地BOX">
<meta property="og:url" content="https://g-d-zhou.github.io/year/05/19/groundBox/index.html">
<meta property="og:site_name" content="格物轩">
<meta property="og:description" content="&quot;Plasma Simulations by Example&quot;一书的学习笔记。 简介 模拟描述：等离子体被限制在一个接地的box内部，该Box接地且壁具有反射性。模拟运用静电PIC方法，并且是全动力学的。 这意味着离子和电子都被当作粒子来处理。虽然该模拟并没有那么令人兴奋，但它实际上会导致有趣的振荡现象。 还能够构建后续所有代码使用的基础框架。 模拟设置 模拟区域如下图所示：边长为0.2 m的立方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://g-d-zhou.github.io/images/Lubos/latexImage_b85e56823794ae5c05376022819e5d8a.png">
<meta property="og:image" content="https://g-d-zhou.github.io/images/Lubos/latexImage_ec713bea4b512c23a2bce33df2f22a70.png">
<meta property="og:image" content="https://g-d-zhou.github.io/images/Visualization_of_the_initial_domain_in_Paraview.png">
<meta property="article:published_time" content="2024-05-19T11:44:20.000Z">
<meta property="article:modified_time" content="2024-08-30T03:42:07.000Z">
<meta property="article:author" content="Dr. Zhou">
<meta property="article:tag" content="通过示例讲解等离子体模拟">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://g-d-zhou.github.io/images/Lubos/latexImage_b85e56823794ae5c05376022819e5d8a.png">


<link rel="canonical" href="https://g-d-zhou.github.io/year/05/19/groundBox/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://g-d-zhou.github.io/year/05/19/groundBox/","path":"year/05/19/groundBox/","title":"接地BOX"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>接地BOX | 格物轩</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">格物轩</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学习、笔记与分享</p>
      <img class="custom-logo-image" src="/images/logo.png" alt="格物轩">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.</span> <span class="nav-text">模拟设置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%9D%E4%BB%A3%E7%A0%81"><span class="nav-number">2.1.</span> <span class="nav-text">赝代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#world%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.</span> <span class="nav-text">World对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0constructor"><span class="nav-number">3.1.</span> <span class="nav-text">构造函数(constructor)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.2.</span> <span class="nav-text">声明与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.</span> <span class="nav-text">多个文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="nav-number">3.4.</span> <span class="nav-text">头文件保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%96%BD"><span class="nav-number">3.5.</span> <span class="nav-text">实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E6%A0%BC%E5%88%86%E8%BE%A8%E7%8E%87"><span class="nav-number">3.6.</span> <span class="nav-text">网格分辨率</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.</span> <span class="nav-text">场对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="nav-number">4.1.</span> <span class="nav-text">存储分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#c"><span class="nav-number">4.1.1.</span> <span class="nav-text">C++</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#python"><span class="nav-number">4.1.2.</span> <span class="nav-text">python</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#julia"><span class="nav-number">4.1.3.</span> <span class="nav-text">Julia</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#operator-overloading"><span class="nav-number">4.2.</span> <span class="nav-text">Operator overloading</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E7%89%88"><span class="nav-number">4.3.</span> <span class="nav-text">模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">移动和复制构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#additional-operators"><span class="nav-number">4.5.</span> <span class="nav-text">Additional Operators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84python%E5%AE%9E%E7%8E%B0step1"><span class="nav-number">4.6.</span> <span class="nav-text">代码的Python实现：step1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA"><span class="nav-number">4.7.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#three-component-vectors"><span class="nav-number">4.8.</span> <span class="nav-text">Three-Component Vectors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91world%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9C%BA"><span class="nav-number">4.9.</span> <span class="nav-text">向World中添加场</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-number">4.10.</span> <span class="nav-text">初始化输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="nav-number">4.11.</span> <span class="nav-text">可视化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84python%E5%AE%9E%E7%8E%B0step2"><span class="nav-number">4.12.</span> <span class="nav-text">代码的Python实现：step2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#world-%E7%B1%BB"><span class="nav-number">4.12.1.</span> <span class="nav-text">World 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#output%E7%B1%BB"><span class="nav-number">4.12.2.</span> <span class="nav-text">Output类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%A3%E7%A0%81"><span class="nav-number">4.12.3.</span> <span class="nav-text">主代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%BF%E6%B1%82%E8%A7%A3%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">势求解器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B5%E5%9C%BA"><span class="nav-number">6.</span> <span class="nav-text">电场</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B2%92%E5%AD%90"><span class="nav-number">7.</span> <span class="nav-text">粒子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BD%E5%85%A5%E7%B2%92%E5%AD%90"><span class="nav-number">7.1.</span> <span class="nav-text">载入粒子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">随机数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%B0%84%E7%B2%92%E5%AD%90%E5%88%B0%E7%BD%91%E6%A0%BC%E6%8F%92%E5%80%BC"><span class="nav-number">7.3.</span> <span class="nav-text">散射：粒子到网格插值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B5%E8%8D%B7%E5%AF%86%E5%BA%A6"><span class="nav-number">8.</span> <span class="nav-text">电荷密度</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dr. Zhou"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Dr. Zhou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://g-d-zhou.github.io/year/05/19/groundBox/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Dr. Zhou">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="格物轩">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="接地BOX | 格物轩">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          接地BOX
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-19 19:44:20" itemprop="dateCreated datePublished" datetime="2024-05-19T19:44:20+08:00">2024-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-30 11:42:07" itemprop="dateModified" datetime="2024-08-30T11:42:07+08:00">2024-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%BD%8E%E6%B8%A9%E7%AD%89%E7%A6%BB%E5%AD%90%E4%BD%93%E7%90%86%E8%AE%BA%E4%B8%8E%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">低温等离子体理论与应用</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>"Plasma Simulations by Example"一书的学习笔记。</p>
<h2 id="简介">简介</h2>
<p>模拟描述：等离子体被限制在一个接地的box内部，该Box接地且壁具有反射性。模拟运用静电PIC方法，并且是全动力学的。
这意味着离子和电子都被当作粒子来处理。虽然该模拟并没有那么令人兴奋，但它实际上会导致有趣的振荡现象。
还能够构建后续所有代码使用的基础框架。</p>
<h2 id="模拟设置">模拟设置</h2>
<p>模拟区域如下图所示：边长为0.2 m的立方体盒子，其空间范围从(-0.1, -0.1,
0)延伸到(0.1, 0.1, 0.2)。 区域被划分为一个<span
class="math inline">\(21\times 21\times
21\)</span>的均匀笛卡尔网格。模拟区域中初始均匀离子密度<span
class="math inline">\(n_i = 10^11 m^{-3}\)</span>。
电子密度与离子相同，但电子只占据<span
class="math inline">\([-0.1,0)\times[-0.1,0)\times[0,0.1)\)</span>，也就是说：
<span class="math display">\[\begin{equation}
    n_e(\vec{x})=\left\{\begin{array}{ll}n_i&amp;\quad;\vec{x}\in[\vec{x}_0,\vec{x}_c)\\0&amp;\quad;\mathrm{otherwise}\end{array}\right.
\end{equation}\]</span></p>
<img src="/images/Lubos/latexImage_b85e56823794ae5c05376022819e5d8a.png" class="" width="400" title="Figure 2.1: Computational domain for the plasma in a box example. Electrons initially occupy only the shaded region.">
<p>这个区域在图中用灰色框表示。这种设定明显是不稳定的。剩下的七个八分之一区域充满了净正电荷。可以预料，电子会试图进入这些区域以减少局部电荷分离。在这样做的过程中，它们会overshoot离子。在无限广阔的领域中，电子最终会返回，因为它们被困在一个类似于《<a href="/year/01/11/plasmaFundamentals/" title="等离子体模拟基础">等离子体模拟基础</a>》所研究的势阱中。我们通过使壁具有反射性来近似这种行为。
0 V的Dirichlet边界条件被设定在所有边界上。</p>
<h3 id="赝代码">赝代码</h3>
<p>代码是分块编写的。作者喜欢从一个仅有基本框架的应用程序开始，
这个框架包含了稍后要实现的功能hook。然后这些hook会逐一得到充实。初始的代码可能类似于如下所示：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *args[])</span></span>&#123;</span><br><span class="line">    <span class="function">World <span class="title">world</span> <span class="params">(/∗ . . . ∗/)</span></span>;   <span class="comment">// 初始化计算域</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Species <span class="title">ions</span> <span class="params">(<span class="comment">/*...*/</span> )</span></span>;    <span class="comment">// 初始化离子secies</span></span><br><span class="line">    <span class="function">Species <span class="title">electrons</span> <span class="params">(<span class="comment">/*...*/</span> )</span></span>;  <span class="comment">// 初始化电子secies</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SolvePotential</span>();   <span class="comment">// 得到初始化的电势</span></span><br><span class="line">    <span class="built_in">ComputeElectricField</span>();  <span class="comment">// 差分电势</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">GenerateParticles</span>();  <span class="comment">// 生成初始粒子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">for</span> (ts=<span class="number">0</span>; ts&lt;num_ts; ts++)&#123;</span><br><span class="line">        <span class="built_in">ComputeChargeDensity</span>();  <span class="comment">// 计算电荷密度</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">SolvePotential</span>();   <span class="comment">// 求解电势</span></span><br><span class="line">        <span class="built_in">ComputeElectricField</span>();  <span class="comment">// 计算电场</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">IntegrateVelocity</span>();  <span class="comment">// 更新粒子速度</span></span><br><span class="line">        <span class="built_in">IntegratePosition</span>();  <span class="comment">// 更新粒子位置</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">RunTimeDiagnostics</span>();   <span class="comment">// 输出一些诊断信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OutputResults</span>();   <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// normal exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们首先定义一个名为World的变量，它封装了关于计算域的信息。接着，我们创建对象来存储离子和电子种类的数据。
这个对象属于Species类型，它存储了所有粒子共有的信息，比如它们的质量或电荷。
它还存储每个粒子的位置和速度。接下来，我们计算初始电场。这个电场对于Leapfrog方法中回溯粒子速度是必需的。
然后我们加载粒子。代码随后进入主循环。通常，我们会为预设的步数 num_ts
运行模拟。每一步都包括首先更新粒子的速度。 <span
class="math display">\[\begin{equation}
    \frac{d\vec{v}}{dt}=\frac
qm\left(\vec{E}+\vec{v}\times\vec{B}\right)
\end{equation}\]</span> 在没有磁场的情况下，这会简化为： <span
class="math display">\[\begin{equation}
    \frac{d\vec{v}}{dt}=\frac qm\vec{E}
\end{equation}\]</span></p>
<p>粒子的位置根据： <span class="math display">\[\begin{equation}
    \frac{d\vec{x}}{dt}=\vec{v}
\end{equation}\]</span></p>
<p>这些新位置随后被用来通过插值计算电荷密度<span
class="math inline">\(\rho\)</span>，将其位置映射到网格上。然后求解泊松方程:
<span class="math display">\[\begin{equation}
    \nabla^2\phi=-\frac\rho{\epsilon_0}
\end{equation}\]</span></p>
<p>电场是通过差分电势获得的： <span
class="math display">\[\begin{equation}
    \vec{E}=-\nabla\phi
\end{equation}\]</span></p>
<p>最后，我们添加了一些屏幕和文件诊断工具，以揭示模拟的进展状况。就是这样！循环会持续迭代，直到达到所需的时间步数。</p>
<h2 id="world对象">World对象</h2>
<p>首先，需要建立一个用于存储网格几何形状和基于节点值的容器。这个例子中使用的笛卡尔网格如下图所示。
由于其规则的结构，只需要九个量就能完全描述这个网格：原点的三个浮点值<span
class="math inline">\(x_0\)</span>、<span
class="math inline">\(y_0\)</span>、<span
class="math inline">\(z_0\)</span>；在<span
class="math inline">\(x\)</span>、<span
class="math inline">\(y\)</span>和<span
class="math inline">\(z\)</span>方向上的单元间距三个值：<span
class="math inline">\(\Delta x\)</span>、<span
class="math inline">\(\Delta y\)</span>和<span
class="math inline">\(\Delta z\)</span>；以及节点计数<span
class="math inline">\(ni\)</span>、<span
class="math inline">\(nj\)</span>和<span
class="math inline">\(nk\)</span>。以向量形式表示为<span
class="math inline">\(\vec{x}_0\)</span>、<span
class="math inline">\(\Delta\vec{h}\)</span>以及<span
class="math inline">\(\vec{nn}\)</span>。这些信息被存储在一个名为World的对象中。一个简单的版本是：</p>
<img src="/images/Lubos/latexImage_ec713bea4b512c23a2bce33df2f22a70.png" class="" width="400" title="Figure 2.2: Cartesian mesh used in this example.">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">World</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> x0[<span class="number">3</span>];   <span class="comment">// 网格原点</span></span><br><span class="line">    <span class="type">double</span> dh[<span class="number">3</span>];   <span class="comment">// cell spacing in x, y, z</span></span><br><span class="line">    <span class="type">int</span> nn[<span class="number">3</span>];     <span class="comment">// number of cells in x, y, z</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种数据结构需要外部代码直接操作数组。例如， <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    World world;</span><br><span class="line">    world.nn[<span class="number">0</span>] = <span class="number">21</span>;   <span class="comment">// 设置节点数</span></span><br><span class="line">    world.nn[<span class="number">1</span>] = <span class="number">21</span>;</span><br><span class="line">    world.nn[<span class="number">2</span>] = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">    world.x0[<span class="number">0</span>] = <span class="number">-0.1</span>; <span class="comment">// set origin</span></span><br><span class="line">    world.x0[<span class="number">1</span>] = <span class="number">-0.1</span>;</span><br><span class="line">    world.x0[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    world.dh[<span class="number">0</span>] = <span class="number">0.01</span>; <span class="comment">// set mesh spacing</span></span><br><span class="line">    world.dh[<span class="number">1</span>] = <span class="number">0.01</span>;</span><br><span class="line">    world.dh[<span class="number">2</span>] = <span class="number">0.01</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="构造函数constructor">构造函数(constructor)</h3>
<p>这种"C"风格的方法并不理想，因为它没有提供任何安全检查。
一旦相关数组初始化后，主函数中没有任何可以阻止修改变量(holding网格数量)的代码。这可能会导致内存损坏。C++提供了两种控制数据访问的工具。
首先，我们可以将类的成员定义为私有或受保护的，这阻止了类外部的任何代码访问它们。
或者，我们可以定义一个称为构造函数的特殊函数，每当对象初始化时都会自动调用。
它被定义为一个与类名相同且没有返回类型的函数。构造器使得我们可以初始化常量字段。这些成员可以在类外部读取，但一旦设置，它们的值就不能改变。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">World</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">    World(<span class="type">int</span> ni, <span class="type">int</span> nj, <span class="type">int</span> nk);  <span class="comment">// constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置网格跨度，同时重新计算单元间距</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setExtents</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> z1, <span class="type">double</span> x2, <span class="type">double</span> y2, <span class="type">double</span> z2)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> nn[<span class="number">3</span>];     <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ni, nj, nk;  <span class="comment">// number of nodes in individual variables</span></span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    <span class="type">double</span> x0[<span class="number">3</span>];   <span class="comment">// 网格原点</span></span><br><span class="line">    <span class="type">double</span> dh[<span class="number">3</span>];   <span class="comment">// cell spacing in x, y, z</span></span><br><span class="line">    <span class="type">double</span> xm[<span class="number">3</span>];   <span class="comment">// 网格最大值</span></span><br><span class="line">    <span class="type">double</span> xc[<span class="number">3</span>];   <span class="comment">// 网格中心</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<div class="note "><p>protected 访问修饰符控制类成员的访问权限，位于 protected
下面的内容具有以下特性：</p>
<p>类内：可以在类的内部访问，如类的成员函数和友元函数。
派生类：可以在继承该类的派生类中访问。
外部访问：不能直接通过类的实例访问（与 private 类似）。</p>
</div>
<p>除了构造函数之外，我们还添加了一些额外的变量。其中包括“max
bound”，这是原点在对角线另一端相对应的点：<span
class="math inline">\(\vec{x_m} = \vec{x_0} +\Delta \vec{h}\cdot
(\vec{nn}-1)\)</span>。我们还添加了网格中心<span
class="math inline">\(\vec{x_c}=(\vec{x_0}+\vec{x_m})/2\)</span>。
非恒定数据被移动到一个受保护的区域，以防止外部访问。成员函数<code>setExtents</code>设置了网格的边界框，并且也计算了单元格的大小。主函数的调用现在如下所示。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">World <span class="title">world</span><span class="params">(<span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line">    world.<span class="built_in">setExtents</span>(<span class="number">-0.1</span>, <span class="number">-0.1</span>, <span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="声明与实现">声明与实现</h3>
<p>至今我们只声明了类函数，但尚未实现它们。这可以通过在声明时提供函数体来完成，对于应该内联的小型函数来说，这确实是正确的选择。内联消除了与函数调用相关的开销。但是直接在类定义中包含代码有一些缺点。首先，或许算是一个小缺点，它会使代码更加杂乱。第二个原因与构建过程有关。C++通过三个步骤生成应用程序。首先，预处理器检查以#开头的特殊宏。其中一个，#include，允许我们导入另一个文件的内容。接下来，编译器生成实际的机器代码。为了调用函数或实例化类，编译器需要知道对象原型。原型告诉编译器函数期望的参数类型和返回类型是什么。
相似的信息由如上面所示的类声明提供。它允许编译器在实际上不知道成员函数具体做什么的情况下，构建和使用类型为World的对象。最后，链接器会查找函数体并确保它们在需要时可用。</p>
<h3 id="多个文件">多个文件</h3>
<p>我们可以将程序拆分为多个文件，比如Main.cpp、Output.cpp、Solver.cpp、Species.cpp和World.cpp。这些文件随后可以通过构建过程包含进来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -O2 Main.cpp Output.cpp Solver.cpp Species.cpp World.cpp -o ch2</span><br></pre></td></tr></table></figure>
<div class="note "><p>-O2
是优化选项中的一个，表示中等程度优化。其作用是启用一系列优化，以提升生成的可执行程序的性能，而不会显著增加编译时间。在大多数情况下，这个优化级别可以显著提高程序性能，而且不会出现重大的代码错误或临时异常。详细来说，-O2启用的优化包括但不限于：</p>
<ul>
<li>消除公共子表达式：检测和删除表达式中可以重复使用的部分，减少冗余计算。</li>
<li>删除死代码：去掉程序中不会被执行的代码。</li>
<li>代码内联：将小函数的代码直接插入调用处，以减少函数调用开销。</li>
<li>减少函数调用开销：通过转化一些递归为迭代、内联扩展等手段。</li>
<li>回合优化：多次遍历和优化代码的特定部分，以获取更高的性能提升。</li>
</ul>
</div>
<p>如果所有的.cpp文件均在一个文件夹，则可写为： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ *.cpp -o ch2</span><br></pre></td></tr></table></figure>
这个指令会编译并链接这五个文件，生成一个可执行程序ch2。另一种选择是，我们可以通过添加-c标志来编译文件，但不进行链接。
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -c Main.cpp Output.cpp Solver.cpp Species.cpp World.cpp </span><br></pre></td></tr></table></figure> 也可以： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -c *.cpp</span><br></pre></td></tr></table></figure></p>
<p>这个调用的输出则是五个对象文件：Main.o, Output.o, Solver.o, Species.o
和 World.o。然后我们将它们链接起来： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ Main.o Output.o Solver.o Species.o World.o -o ch2 </span><br></pre></td></tr></table></figure>
这与最初的编译和链接命令相同，只是现在输入文件是.o的对象文件。</p>
<p>假设我们只修改了在Main.cpp中定义的主要循环代码，其他四个文件无需重新编译。我们可以使用构建工具来重新构建这个应用：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -c Main.cpp</span><br><span class="line">$ g++ *.o -o ch2</span><br></pre></td></tr></table></figure></p>
<p>这虽然对于在这里开发的小型程序可能只是微不足道的时间节省，
但对于生产应用来说，有时从零开始编译可能需要花费数小时。make工具被用来通过自动确定哪些文件需要重新构建来自动化这一过程。
通过将函数体与其定义分离，我们减少了需要重新编译的代码量。我们在World.h头文件中编写World的定义，并在World.cpp源文件中包含适当的实现。其他需要使用World对象的文件则通过如下方法使用：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;World.h&quot;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这些函数在World.cpp中的代码改变时无需重新编译。函数实现是通过在函数名称前加上类的名字来指定的。例如，
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">World::setExtents</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2, <span class="type">double</span> z2)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可能需要将函数定义与其实现分开的另一个原因是，假设我们有两个类A和B，每个类都需要调用另一个类的功能：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;    <span class="comment">// B是后面要定义的类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(B &amp;b)</span></span>&#123;b.<span class="built_in">doSomething</span>();&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(A &amp;a)</span></span>&#123;a.<span class="built_in">doSomething</span>();&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    a.<span class="built_in">run</span>(b);</span><br><span class="line">    b.<span class="built_in">run</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>这段代码无法编译，因为当编译器运行A类中的(B
&amp;b)函数时，它还不知道B类有一个名为doSomething()的成员方法。尽管在第1行使用前向声明（class
B）告知编译器B是一个类，但这种情况依然存在。交换类的顺序并无助于解决问题，因为两个类互相依赖。但通过将实现与定义分开，我们可以使代码成功编译。我们甚至不需要使用多个文件:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;        <span class="comment">// B是后面要定义的类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(B &amp;b)</span></span>&#123;b.<span class="built_in">doSomething</span>();&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(A &amp;a)</span></span>&#123;a.<span class="built_in">doSomething</span>();&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::run</span><span class="params">(B &amp;b)</span></span>&#123;b.<span class="built_in">doSomething</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::run</span><span class="params">(A &amp;a)</span></span>&#123;a.<span class="built_in">doSomething</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    a.<span class="built_in">run</span>(b);</span><br><span class="line">    b.<span class="built_in">run</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子可能显得有些人为编造，但实际上在实践中确实会出现。在我们的例子中，创建物种对象时需要一个世界参照。然而，我们也在世界函数中使用物种来计算电荷密度。为了避免这种循环引用，这个函数的主体不得不被移出头文件。</p>
<h3 id="头文件保护">头文件保护</h3>
<p>最后，因为头文件可以包含其他头文件，有可能不经意间同一个文件被多次包含。这可能导致编译错误。为了防止这种情况，我们在头文件中使用头文件保护（header
guard）来包裹内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WORLD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WORLD_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">World</span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这个构造利用预处理器来检查当前编译单元中是否已经定义了宏_WORLD_H。如果没有定义，我们就定义它，然后包含文件内容。否则，不包含任何内容。即使在打印的片段中未显示，这个构造也会用在所有示例的头文件中。</p>
<h3 id="实施">实施</h3>
<p>考虑到这一点，我们继续实现World类。我们在World.cpp中添加以下代码：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constructor</span></span><br><span class="line">World::<span class="built_in">World</span>(<span class="type">int</span> ni, <span class="type">int</span> nj, <span class="type">int</span> nk) : ni&#123;ni&#125;, nj&#123;nj&#125;, nk&#123;nk&#125;, nn&#123;ni, nj, nk&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置网格扩展并计算单元格间距</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">World::setExtents</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> z1, <span class="type">double</span> x2, <span class="type">double</span> y2, <span class="type">double</span> z2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置起点(xmin)</span></span><br><span class="line">    x0[<span class="number">0</span>] = x1; x0[<span class="number">1</span>] = y1; x0[<span class="number">2</span>] = z1;</span><br><span class="line">    <span class="comment">// 「对角线 - 反对角线 (xmax)」</span></span><br><span class="line">    xm[<span class="number">0</span>] = x2; xm[<span class="number">1</span>] = y2; xm[<span class="number">2</span>] = z2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过将长度除以单元格数量计算间距</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        dh[i] = (xm[i] - x0[i])/(nn[i]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算中心</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        xc[i] = <span class="number">0.5</span>*(x0[i]+xm[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造函数通过初始化列表来设置类的常量成员。
大括号前的变量是类的成员，而里面的部分则是赋予它的值。
这些通常作为构造函数的参数。允许类成员和参数使用相同的名字。
然而，所有类都包含一个特殊的指针称为this，可以用来显式地引用类的成员。
通过这种方式使用<code>this-&gt;ni=ni;</code>可以作为将类成员设置为与局部变量（或函数参数）相同值的另一种方法，前提是这两个变量同名。
由于构造函数除了初始化数据之外没有其他操作，所以我们保持其body为空。</p>
<p><code>setExtents</code> 函数首先为<span
class="math inline">\(\vec{x}_0\)</span> 和 <span
class="math inline">\(\vec{x}_m\)</span>向量设置值。这种初始化也可以作为构造函数的一部分，但是会导致函数参数过多。将调用分开使得代码更易于阅读，至少在我看来是这样。下一步，我们计算网格间距:
<span class="math display">\[\begin{equation}
    \Delta x=\frac{x_m-x_0}{n_i-1}
\end{equation}\]</span></p>
<p>这里，<span
class="math inline">\(n_i\)</span>表示沿x方向的节点数量，<span
class="math inline">\(n_i - 1\)</span>则是相应的单元格计数。
我们还设置了网格质心，<span class="math inline">\(\vec{x}c = (\vec{x}_m
+
\vec{x}_0)/2\)</span>。质心仅仅用于加载电子群体。最后，我们调用一个函数来计算节点体积。这个函数尚未实现。</p>
<h3 id="网格分辨率">网格分辨率</h3>
<p>在继续之前，我们应该指出cell间距不能完全随意设定。等离子体在比德拜长度更小的尺度上才不呈中性:
<span class="math display">\[\begin{equation}
    \lambda_D=\sqrt{\frac{\epsilon_0k_BT_e}{n_eq_e^2}}
\end{equation}\]</span> 其中，<span
class="math inline">\(k_B\)</span>是玻尔兹曼常量。该方程忽略了离子贡献，但由于<span
class="math inline">\(T_i \ll T_e\)</span>，通常我们会忽略它。
既然我们关注的是模拟电子和离子的混合，就需要解决局部电荷分离的问题。
因此，我们需要cell体积小于德拜球的体积: <span
class="math display">\[\begin{equation}
    (\Delta x\Delta y\Delta z)&lt;\frac43\pi\lambda_D^3
\end{equation}\]</span> 或者，通常会要求: <span
class="math display">\[\begin{equation}
    \max(\Delta x,\Delta y,\Delta z)&lt;\lambda_D
\end{equation}\]</span></p>
<p>在我们的示例中，模拟前计算德拜长度并非易事，因为离子和电子都是冷加载的，<span
class="math inline">\(T_e = T_i = 0\)</span>。
然而，如后续章节(“结果”)所示，电子的总系统动能被限制在<span
class="math inline">\(KE &lt; 2\times 10^{-11}\)</span> J。
考虑到该系统模拟了<span
class="math inline">\(10^8\)</span>个电子，我们可以计算出每个电子的动能为<span
class="math inline">\(2\times 10^{-19}\)</span> J。
对于麦克斯韦速度分布，我们也有<span class="math inline">\(KE =
(3/2)kT\)</span>。因此，如果我们假定电子是麦克斯韦分布的，$T_e $ K。
通常以电子伏特来表示温度，1 eV <span
class="math inline">\(=(q/k_B)\approx 11604.5\)</span> K。因此，$T_e =
0.83 $ eV。 再加上<span class="math inline">\(n_e =
10^{11}\)</span>，我们有<span class="math inline">\(\lambda_D =
0.0214\)</span> m。对于<span class="math inline">\(20\times 20\times
20\)</span>的网格， <span class="math inline">\(\Delta
x=(x_m-x_0)/n_i=(0.2\text{m})/20=0.01\text{m}\)</span>
我们的网格足够精细，能够解析德拜长度。如果有疑问，可以通过在不同网格分辨率下运行模拟并比较结果来进行网格收敛性研究。此外，根据我的经验，除非满足网格分辨率要求，否则高斯-赛德尔泊松求解器无法收敛。场求解器的发散是需要更细网格的一个好指示器。</p>
<h2 id="场对象">场对象</h2>
<p>我们现在已经完全定义了网格几何形状，但是这个网格中不包含任何数据。
在第一章中，我们使用了std::vector来存储一维数组，包含ni个条目。遗憾的是，C++标准库中并没有与之对应的三维容器，所以我们需要创建自己的数据结构。我们将这个对象称为Field。这一部分将详细讲述实现的细节。接下来的内容可能会稍显枯燥，所以你可以自由地跳过这一节。如果你选择跳过，只需了解Field存储三维双精度数据。我们还实现了FieldI，用于存储整数，以及Field3，用于存储三元向量。
沿着这条路，我们还定义了一个用于存储三元组浮点数和整型数的容器 double3
和 int3。 这些对象使用操作符重载来支持常见的数学运算。例如，不这样实现：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a[<span class="number">3</span>], b[<span class="number">3</span>], c[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    c[i] = a[<span class="number">3</span>] + <span class="number">5</span>*b[i];   <span class="comment">//在循环中计算每一个维度</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以简单写为： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double3 a, b;</span><br><span class="line">double3 c = a+<span class="number">5</span>*b;  <span class="comment">// use overloaded * 以及 + 算符</span></span><br></pre></td></tr></table></figure></p>
<p>同样地，我们可以在整个3D场中执行操作，例如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field a, b;</span><br><span class="line">Field c = a + <span class="number">5</span>*b;  \\  every c[i][j][k] = a[i][j][k] + <span class="number">5</span>*b[i][j][k]</span><br></pre></td></tr></table></figure></p>
<h3 id="存储分配">存储分配</h3>
<h4 id="c">C++</h4>
<p>Field容器的主要目的是存储网格节点或cell中心数据。我们希望能够访问<span
class="math inline">\(\phi\)</span>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Field <span class="title">phi</span><span class="params">(ni, nj, nk)</span></span>;  <span class="comment">// initialize memory for ni*nj*nk values</span></span><br><span class="line">phi[i][j][k] = some_value</span><br></pre></td></tr></table></figure>
<p>C++与其他语言，如Java不同，它不原生支持多维数组的分配。这类数组通常是通过创建指针数组来近似的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> **v = <span class="keyword">new</span> <span class="type">double</span>*[<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>分配一个包含五个双精度数据指针的数组。每个条目，比如v[3]，是一个指针，可以指向任意的内存位置。
我们令： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[<span class="number">3</span>] = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p>现在，v[3] 指向一个包含10个双精度浮点数的数组。我们通过 v[3][0] 到
v[3][9] 来访问这些值。
分配三维数据也类似。我们首先创建一个指向指针的数组。然后，每个条目被设置为指向一个指向双精度浮点数的指针数组，每个这样的指针又分配给一个双精度浮点数的数组。看起来是这样的：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Field.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span>&#123;</span></span><br><span class="line">    pubic:</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    Field (<span class="type">int</span> ni, <span class="type">int</span> nj, <span class="type">int</span> nk) : ni&#123;ni&#125;, nj&#123;nj&#125;, nk&#123;nk&#125;&#123;</span><br><span class="line">        data = new <span class="type">double</span>**[ni];    <span class="comment">// ni pointers to pointers</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ni; i++)&#123;</span><br><span class="line">            data[i] = new <span class="type">double</span>*[nj];  <span class="comment">// nj pointers to doubles</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nj; j++)</span><br><span class="line">                data[i][j] = new <span class="type">double</span> [nk];   <span class="comment">// nk double</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// destructor，释放内存in reverse order</span></span><br><span class="line">    ~Field()&#123;</span><br><span class="line">        <span class="keyword">if</span> (data==nullptr) <span class="keyword">return</span>;  <span class="comment">// 返回如果分配了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>；i&lt;ni; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nj; j++)&#123;   <span class="comment">// 释放内存in reverse order</span></span><br><span class="line">                delete data[i][j]; </span><br><span class="line">                &#125;</span><br><span class="line">            delete data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        delete[]    data;</span><br><span class="line">        data = nullptr; <span class="comment">// mark as free</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ni, nj, nk;   <span class="comment">// number of nodes</span></span><br><span class="line">    protected:</span><br><span class="line">        <span class="type">double</span> ***data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>析构函数是一种特殊函数，在对象的作用域结束时会自动调用。我们用它来释放内存。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Field <span class="title">phi</span><span class="params">(<span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>)</span></span>;  <span class="comment">// calls Field constructor</span></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">// Field destructor called here automatically</span></span><br></pre></td></tr></table></figure></p>
<h4 id="python">python</h4>
<p>对于python而言，内存管理由垃圾收集器处理，通常不需要手动释放内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Field</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ni, nj, nk</span>):</span><br><span class="line">        self.ni = ni</span><br><span class="line">        self.nj = nj</span><br><span class="line">        self.nk = nk</span><br><span class="line">        <span class="comment"># Initialize the 3D array using numpy</span></span><br><span class="line">        self.data = np.zeros((ni, nj, nk), dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># 测试用例</span></span><br><span class="line">f = Field(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(f.data)</span><br></pre></td></tr></table></figure>
<h4 id="julia">Julia</h4>
<p>在 Julia
中，我们不需要显式地管理内存，垃圾收集器会自动处理内存释放。因此，不需要定义析构函数，类似
Python 的内存管理。 <figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> FieldModule</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Field</span><br><span class="line">    ni::<span class="built_in">Int</span></span><br><span class="line">    nj::<span class="built_in">Int</span></span><br><span class="line">    nk::<span class="built_in">Int</span></span><br><span class="line">    data::<span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construction function</span></span><br><span class="line">    <span class="keyword">function</span> Field(ni::<span class="built_in">Int</span>, nj::<span class="built_in">Int</span>, nk::<span class="built_in">Int</span>)</span><br><span class="line">        data = zeros(<span class="built_in">Float64</span>, ni, nj, nk)</span><br><span class="line">        <span class="keyword">return</span> new(ni, nj, nk, data)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="comment"># modul</span></span><br></pre></td></tr></table></figure> <figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> .FieldModule</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试用例</span></span><br><span class="line">field = FieldModule.Field(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">println(<span class="string">&quot;数据内容：&quot;</span>)</span><br><span class="line">println(field.data)</span><br></pre></td></tr></table></figure></p>
<h3 id="operator-overloading">Operator overloading</h3>
<p>目前，没有直接访问存储在Field对象中的数据的方法。一种选择是将内部的double类型数据成员***data移动到公共区域。之后我们可以用phi.data[i][j][k]来访问数据。这种方式可能会比较繁琐。幸运的是，C++允许我们通过运算符重载定义自定义操作符。
几乎所有的运算符都可以重载，包括数组访问的方括号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Field</span>&#123;</span><br><span class="line">    <span class="comment">// overload the array access operator []</span></span><br><span class="line">    <span class="type">double</span>** <span class="keyword">operator</span> [](<span class="type">int</span> i)&#123;</span><br><span class="line">        <span class="keyword">return</span> data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="type">double</span> ***data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以重载赋值操作符，允许将所有字段条目设置为常量值。这在以下代码片段中展示：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Field&amp; <span class="keyword">operator</span>=(<span class="type">double</span> s)&#123; <span class="comment">// assignment operator</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ni; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nj; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;nk;k++)</span><br><span class="line">                data[i][j][k] = s;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">// 返回参照自身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个函数仅仅遍历所有数据条目，并将它们设置为给定的标量值。为了通用性，我们通过解引用this指针返回当前Field实例的引用。这样可以链式执行多个操作。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Field <span class="title">phi</span><span class="params">(<span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line">phi = <span class="number">0</span>;    <span class="comment">// 初始化所有的值为0</span></span><br><span class="line">phi[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>] = <span class="number">1.0</span>;     <span class="comment">// 使用重载的操作符来设置数据</span></span><br></pre></td></tr></table></figure>
原始数据的清理很重要，因为C++在创建变量时不会自动初始化它们。由于这个步骤对所有动态分配的数据都是必要的，我们在构造函数中添加了对该函数的调用：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constructor</span></span><br><span class="line"><span class="built_in">Field</span> (<span class="type">int</span> ni, <span class="type">int</span> nj, <span class="type">int</span> nk): ni&#123;ni&#125;, nj&#123;nj&#125;, nk&#123;nk&#125;&#123;</span><br><span class="line">    <span class="comment">/* 内存分配代码来自上方 */</span></span><br><span class="line">    (*<span class="keyword">this</span>) = <span class="number">0</span>;    <span class="comment">// 明确地使用赋值运算符</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
另外，我们也可以直接调用操作符。操作符其实就是具有特殊名称的成员函数：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Field (<span class="type">int</span> ni, <span class="type">int</span> nj, <span class="type">int</span> nk) : ni&#123;ni&#125;, nj&#123;nj&#125;, nk&#123;nk&#125;&#123;</span><br><span class="line">    <span class="comment">/* 内存分配代码 */</span></span><br><span class="line">    operator = (<span class="number">0</span>); <span class="comment">// 调用重载操作符=为函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="模版">模版</h3>
<p>Field 对象目前被固定为处理双精度浮点数数据。
尽管在大多数情况下是如此，但有时我们需要存储不同类型的数据。这些包括用整数标记节点类型，以及用于表示速度和电磁场的(x,
y, z)向量。 C++ 允许我们使用模板将 Field
定义为一种通用容器。这个通用版本被重命名为 Field_，其内容如下。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field_</span>&#123;</span></span><br><span class="line">    public:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        Field_ (<span class="type">int</span> ni, <span class="type">int</span> nj, <span class="type">int</span> nk):    ni&#123;ni&#125;, nj&#123;nj&#125;, nk&#123;nk&#125;&#123;</span><br><span class="line">            data = new T**[ni]；    <span class="comment">// ni pointers to pointers of type T</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ni; i++)&#123;</span><br><span class="line">                data[i] = new T*[nj];   <span class="comment">// 分配指针nj到T</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nj; j++)&#123;</span><br><span class="line">                    data[i][j] = new T[nk]; <span class="comment">// 分配T类型的nk对象</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            (*this)=<span class="number">0</span>;  <span class="comment">// clear data</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">        ~Field_()&#123;</span><br><span class="line">            <span class="comment">/* 和之前的代码一样 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据访问操作</span></span><br><span class="line">        T** operator[]  (<span class="type">int</span> i) &#123; <span class="keyword">return</span> data[i];&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overload赋值操作符</span></span><br><span class="line">        Field_&lt;T&gt;&amp; operator= (T s)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ni; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nj; j++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;nk; k++)</span><br><span class="line">                        data[i][j][k] = s;</span><br><span class="line">            <span class="keyword">return</span> *this;       <span class="comment">// return reference to self</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> ni, nj,nk;    <span class="comment">// 节点数</span></span><br><span class="line">    </span><br><span class="line">    protected:</span><br><span class="line">        T ***data;      <span class="comment">// pointer of type T</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 类定义前缀有模板<typename T>参数。
这指示编译器将T视为一个由用户在创建对象时指定的泛型类型。所有之前直接写死为double类型的地方都被替换为T类型。现在我们可以将一个三维数组声明为Field_<double>。类似地，可以使用Field_<int>来实例化一个整数数组。不断地写出模板参数可能会让人感到厌倦。
我们通过使用关键字“using”来为这些类型定义“别名”，以此来解决这个问题。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Field = Field_&lt;<span class="type">double</span>&gt;;   <span class="comment">// field of doubles</span></span><br><span class="line"><span class="keyword">using</span> FiedlI = Field_&lt;<span class="type">int</span>&gt;;     <span class="comment">// field of integers</span></span><br></pre></td></tr></table></figure>
现在我们可以使用Field和FieldI来指代这两种类型。模板替换在编译时发生，因此编译器需要访问依赖于模板参数的所有代码。实际上，这意味着模板函数需要在头文件中完整实现。</p>
<h3 id="移动和复制构造函数">移动和复制构造函数</h3>
<p>为了完整性，我们也应该定义两种特殊的构造函数，允许Field对象被复制和移动。第一种是拷贝构造函数，它通过逐个元素复制另一个Field对象来实现深拷贝。移动构造函数则“窃取”来自另一个对象的数据。它用于从函数中返回临时对象，否则这些对象需要被复制。这两种构造函数的代码如下。拷贝构造函数通过初始化列表调用标准构造函数来分配内存，然后逐个设置元素。
这一过程使用了重载的()运算符来读取另一个字段的数据。[]运算符支持对数据进行读/写访问，因为它返回对象的引用。它不适用于常量成员，因为可以通过引用改变值。()运算符通过返回存储的值提供只读访问数据的方式。而移动构造函数仅设置节点计数，并“窃取”数据，使我们的数据指针指向其他字段持有的数据。通过将其设置为nullptr，使其他字段的数据指针失效。
这阻止了析构函数尝试释放内存。赋值运算符也被重载以支持移动操作。&amp;&amp;
符号表示另一个是临时对象的引用。这些对象，也被称为
r-values，当从函数返回局部变量时会遇到。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Field</span>&#123;</span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">Field_</span>(<span class="type">const</span> Field_ &amp;other):</span><br><span class="line">    Field_&#123;other .ni, other .nj, other .nk&#125;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ni; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;nj; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;nk; k++)</span><br><span class="line">                    data[i][j][k] = <span class="built_in">other</span>(i, j, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Field_</span>(Field_ &amp;&amp;other):</span><br><span class="line">        ni&#123;other.ni&#125;, nj&#123;other.nj&#125;, nk&#123;other.nk&#125;&#123;</span><br><span class="line">            <span class="keyword">if</span> (data) ~<span class="built_in">Field_</span>();    <span class="comment">// 处理分配数据</span></span><br><span class="line">            data = other.data;  <span class="comment">// 拿取数据</span></span><br><span class="line">            other.data = <span class="literal">nullptr</span>;   <span class="comment">// 无效化</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动标记操作</span></span><br><span class="line">        Field_&amp; <span class="keyword">operator</span> = (Field_ &amp;&amp;f)&#123;</span><br><span class="line">            <span class="keyword">if</span> (data) ~<span class="built_in">Field_</span>();    <span class="comment">// 释放数据</span></span><br><span class="line">            data = f.data;</span><br><span class="line">            f.data=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只读访问数据 data[i][j][k]</span></span><br><span class="line">        <span class="built_in">operator</span>() (<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k) <span class="type">const</span> &#123;<span class="keyword">return</span> data[i][j][k];&#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="additional-operators">Additional Operators</h3>
<p>我们现在定义一些后续会派上用场的额外函数。首先是一个元素级除法运算符，</p>
<p>我们同样为复合加法定义了一个类似的运算符。</p>
<p>接下来，我们编写两个运算符，用于按标量缩放场。</p>
<h3 id="代码的python实现step1">代码的Python实现：step1</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### World类</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">World</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ni:<span class="built_in">int</span>, nj:<span class="built_in">int</span>, nk:<span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># //constructor</span></span><br><span class="line">        self.ni = np.zeros(ni)</span><br><span class="line">        self.nj = np.zeros(nj)</span><br><span class="line">        self.nk = np.zeros(nk)</span><br><span class="line">        self.nn = np.array([ni,nj,nk])</span><br><span class="line">        self.x0 = np.zeros(<span class="number">3</span>)   <span class="comment"># mesh origin</span></span><br><span class="line">        self.dh = np.zeros(<span class="number">3</span>)   <span class="comment"># cell spacing</span></span><br><span class="line">        self.xm = np.zeros(<span class="number">3</span>)   <span class="comment"># mesh max bound</span></span><br><span class="line">        self.xc = np.zeros(<span class="number">3</span>)   <span class="comment"># domain centroid</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">computeNodeVolumes</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;/*to be implemented*/&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># sets mesh extents and computes cell spacing</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setExtents</span>(<span class="params">self, x1:<span class="built_in">float</span>,  y1:<span class="built_in">float</span>, z1:<span class="built_in">float</span>, x2:<span class="built_in">float</span>, y2:<span class="built_in">float</span>, z2:<span class="built_in">float</span></span>):</span><br><span class="line">        <span class="comment"># /*set origin*/ #</span></span><br><span class="line">        self.x0[<span class="number">0</span>] = x1</span><br><span class="line">        self.x0[<span class="number">1</span>] = y1</span><br><span class="line">        self.x0[<span class="number">2</span>] = z1</span><br><span class="line"></span><br><span class="line">        <span class="comment"># /*opposite corner*/ #</span></span><br><span class="line">        self.xm[<span class="number">0</span>] = x2</span><br><span class="line">        self.xm[<span class="number">1</span>] = y2</span><br><span class="line">        self.xm[<span class="number">2</span>] = z2</span><br><span class="line"></span><br><span class="line">        <span class="comment"># /*compute spacing by dividing length by number of cells*/ #</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            self.dh[i] = (self.xm[i] - self.x0[i]) / (self.nn[i]-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># /*compute centroid*/ #</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            self.xc[i] = (self.x0[i] + self.xm[i]) / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># /*recompute node volumes*/ #</span></span><br><span class="line">        self.computeNodeVolumes()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### 主代码</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定您想要添加为模块导入路径的目录</span></span><br><span class="line">pathClasses = <span class="string">&quot;path/to/ch2/snippets/steps1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定路径到sys.path</span></span><br><span class="line"><span class="keyword">if</span> pathClasses <span class="keyword">not</span> <span class="keyword">in</span> sys.path:</span><br><span class="line">    sys.path.append(pathClasses)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> World <span class="keyword">import</span> World</span><br><span class="line"></span><br><span class="line">world = World(<span class="number">21</span>,<span class="number">21</span>,<span class="number">21</span>)</span><br><span class="line">world.setExtents(-<span class="number">0.1</span>,-<span class="number">0.1</span>,-<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">phi = np.zeros([<span class="number">21</span>,<span class="number">21</span>,<span class="number">21</span>])</span><br><span class="line">phi[<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="输出">输出</h3>
<h3 id="three-component-vectors">Three-Component Vectors</h3>
<h3 id="向world中添加场">向World中添加场</h3>
<h3 id="初始化输出">初始化输出</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Output &#123;</span><br><span class="line">	<span class="comment">/*writes mesh data to a VTK image file*/</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fields</span><span class="params">(World &amp;world)</span></span>;	</span><br><span class="line">&#125; <span class="comment">// 包含在.h文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*saves output in VTK format*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Output::fields</span><span class="params">(World &amp;world)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stringstream name;</span><br><span class="line">	name&lt;&lt;<span class="string">&quot;fields.vti&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*open output file*/</span></span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(name.str())</span></span>;</span><br><span class="line">   	<span class="keyword">if</span> (!out.<span class="built_in">is_open</span>()) &#123;cerr&lt;&lt;<span class="string">&quot;Could not open &quot;</span>&lt;&lt;name.<span class="built_in">str</span>()&lt;&lt;endl;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*ImageData is vtk format for structured Cartesian meshes*/</span></span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;VTKFile type=\&quot;ImageData\&quot;&gt;\n&quot;</span>;</span><br><span class="line">	double3 x0 = world.<span class="built_in">getX0</span>();</span><br><span class="line">	double3 dh = world.<span class="built_in">getDh</span>();</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;ImageData Origin=\&quot;&quot;</span>&lt;&lt;x0[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;x0[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;x0[<span class="number">2</span>]&lt;&lt;<span class="string">&quot;\&quot; &quot;</span>;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;Spacing=\&quot;&quot;</span>&lt;&lt;dh[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dh[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dh[<span class="number">2</span>]&lt;&lt;<span class="string">&quot;\&quot; &quot;</span>;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;WholeExtent=\&quot;0 &quot;</span>&lt;&lt;world.ni<span class="number">-1</span>&lt;&lt;<span class="string">&quot; 0 &quot;</span>&lt;&lt;world.nj<span class="number">-1</span>&lt;&lt;<span class="string">&quot; 0 &quot;</span>&lt;&lt;world.nk<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\&quot;&gt;\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*output data stored on nodes (point data)*/</span></span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;PointData&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*potential, scalar*/</span></span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;DataArray Name=\&quot;NodeVol\&quot; NumberOfComponents=\&quot;1\&quot; format=\&quot;ascii\&quot; type=\&quot;Float64\&quot;&gt;\n&quot;</span>;</span><br><span class="line">	out&lt;&lt;world.node_vol;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;/DataArray&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*potential, scalar*/</span></span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;DataArray Name=\&quot;phi\&quot; NumberOfComponents=\&quot;1\&quot; format=\&quot;ascii\&quot; type=\&quot;Float64\&quot;&gt;\n&quot;</span>;</span><br><span class="line">	out&lt;&lt;world.phi;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;/DataArray&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*charge density, scalar*/</span></span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;DataArray Name=\&quot;rho\&quot; NumberOfComponents=\&quot;1\&quot; format=\&quot;ascii\&quot; type=\&quot;Float64\&quot;&gt;\n&quot;</span>;</span><br><span class="line">	out&lt;&lt;world.rho;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;/DataArray&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*electric field, 3 component vector*/</span></span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;DataArray Name=\&quot;ef\&quot; NumberOfComponents=\&quot;3\&quot; format=\&quot;ascii\&quot; type=\&quot;Float64\&quot;&gt;\n&quot;</span>;</span><br><span class="line">	out&lt;&lt;world.ef;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;/DataArray&gt;\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*close out tags*/</span></span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;/PointData&gt;\n&quot;</span>;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;/ImageData&gt;\n&quot;</span>;</span><br><span class="line">	out&lt;&lt;<span class="string">&quot;&lt;/VTKFile&gt;\n&quot;</span>;</span><br><span class="line"> 	out.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可视化">可视化</h3>
<p>就目前而言，我可能更关切的是用Python实现，暂时还不考虑性能问题。因此上述部分C++代码讲解跳过。</p>
<h3 id="代码的python实现step2">代码的Python实现：step2</h3>
<h4 id="world-类">World 类</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">World</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ni:<span class="built_in">int</span>, nj:<span class="built_in">int</span>, nk:<span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># //constructor</span></span><br><span class="line">        self.ni = ni</span><br><span class="line">        self.nj = nj</span><br><span class="line">        self.nk = nk</span><br><span class="line">        self.nn = np.array([ni,nj,nk])  <span class="comment"># number of nodes  </span></span><br><span class="line"></span><br><span class="line">        self.phi = np.zeros([ni, nj, nk])</span><br><span class="line">        self.rho = np.zeros([ni, nj, nk])</span><br><span class="line">        self.node_vol = np.zeros([ni, nj, nk])</span><br><span class="line">        self.ef = np.zeros([<span class="number">3</span>, ni, nj, nk,])</span><br><span class="line"></span><br><span class="line">        self.x0 = np.zeros(<span class="number">3</span>)   <span class="comment"># mesh origin</span></span><br><span class="line">        self.dh = np.zeros(<span class="number">3</span>)   <span class="comment"># cell spacing</span></span><br><span class="line">        self.xm = np.zeros(<span class="number">3</span>)   <span class="comment"># mesh max bound</span></span><br><span class="line">        self.xc = np.zeros(<span class="number">3</span>)   <span class="comment"># domain centroid</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setExtents</span>(<span class="params">self, _x0, _xm</span>):</span><br><span class="line">        <span class="comment"># /*set origin*/</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            self.x0[i] = _x0[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># /*opposite corner*/</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            self.xm[i] = _xm[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># /*compute spacing by dividing length by number of cells*/</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            self.dh[i] = (self.xm[i]-self.x0[i])/(self.nn[i]-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment">#//compute centroid</span></span><br><span class="line">            self.xc[i] = <span class="number">0.5</span>*(self.x0[i]+self.xm[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getX0</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.x0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getXm</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.xm</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getXc</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.xc</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getDh</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.dh</span><br></pre></td></tr></table></figure>
<h4 id="output类">Output类</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ReshapeForVTK</span>(<span class="params">arr, ni, nj, nk</span>):</span><br><span class="line">    arrNew = np.zeros([nk,ni*nj])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(nk):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(nj):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ni):</span><br><span class="line">                arrNew[k,i*k] = arr[i,j,k]</span><br><span class="line">    <span class="keyword">return</span> arrNew</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ReshapeForVTK3d</span>(<span class="params">arr, ni, nj, nk</span>):</span><br><span class="line">    arrNew = np.zeros([nk,ni*nj*<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(nk):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(nj):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ni):</span><br><span class="line">                <span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                    arrNew[k,i*k*f] = arr[f,i,j,k]</span><br><span class="line">    <span class="keyword">return</span> arrNew</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Output</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fields</span>(<span class="params">self, world</span>):</span><br><span class="line">        filename = <span class="string">&quot;/Users/zhouguangdi/Documents/data_for_software/Python/等离子体/通过例子学习等离子体模拟/ch2/snippets/step2/fields.vti&quot;</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> out:</span><br><span class="line">                <span class="comment"># ImageData is vtk format for structured Cartesian meshes</span></span><br><span class="line">                out.write(<span class="string">&#x27;&lt;VTKFile type=&quot;ImageData&quot;&gt;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                x0 = world.getX0()</span><br><span class="line">                dh = world.getDh()</span><br><span class="line"></span><br><span class="line">                origin_str = <span class="string">f&quot;<span class="subst">&#123;x0[<span class="number">0</span>]&#125;</span> <span class="subst">&#123;x0[<span class="number">1</span>]&#125;</span> <span class="subst">&#123;x0[<span class="number">2</span>]&#125;</span>&quot;</span></span><br><span class="line">                spacing_str = <span class="string">f&quot;<span class="subst">&#123;dh[<span class="number">0</span>]&#125;</span> <span class="subst">&#123;dh[<span class="number">1</span>]&#125;</span> <span class="subst">&#123;dh[<span class="number">2</span>]&#125;</span>&quot;</span></span><br><span class="line">                extent_str = <span class="string">f&quot;0 <span class="subst">&#123;world.ni-<span class="number">1</span>&#125;</span> 0 <span class="subst">&#123;world.nj-<span class="number">1</span>&#125;</span> 0 <span class="subst">&#123;world.nk-<span class="number">1</span>&#125;</span>&quot;</span></span><br><span class="line">                </span><br><span class="line">                out.write(<span class="string">f&#x27;&lt;ImageData Origin=&quot;<span class="subst">&#123;origin_str&#125;</span>&quot; Spacing=&quot;<span class="subst">&#123;spacing_str&#125;</span>&quot; WholeExtent=&quot;<span class="subst">&#123;extent_str&#125;</span>&quot;&gt;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Output data stored on nodes (point data)</span></span><br><span class="line">                out.write(<span class="string">&quot;&lt;PointData&gt;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Node volume</span></span><br><span class="line">                out.write(<span class="string">&#x27;&lt;DataArray Name=&quot;NodeVol&quot; NumberOfComponents=&quot;1&quot; format=&quot;ascii&quot; type=&quot;Float64&quot;&gt;\n&#x27;</span>)</span><br><span class="line">                np.savetxt(out, ReshapeForVTK(world.node_vol, world.ni, world.nj, world.nk))</span><br><span class="line">                out.write(<span class="string">&#x27;&lt;/DataArray&gt;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Potential, scalar</span></span><br><span class="line">                out.write(<span class="string">&#x27;&lt;DataArray Name=&quot;phi&quot; NumberOfComponents=&quot;1&quot; format=&quot;ascii&quot; type=&quot;Float64&quot;&gt;\n&#x27;</span>)</span><br><span class="line">                np.savetxt(out, ReshapeForVTK(world.phi, world.ni, world.nj, world.nk))</span><br><span class="line">                </span><br><span class="line">                out.write(<span class="string">&#x27;&lt;/DataArray&gt;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Charge density, scalar</span></span><br><span class="line">                out.write(<span class="string">&#x27;&lt;DataArray Name=&quot;rho&quot; NumberOfComponents=&quot;1&quot; format=&quot;ascii&quot; type=&quot;Float64&quot;&gt;\n&#x27;</span>)</span><br><span class="line">                np.savetxt(out,ReshapeForVTK(world.rho, world.ni, world.nj, world.nk))</span><br><span class="line">                </span><br><span class="line">                out.write(<span class="string">&#x27;&lt;/DataArray&gt;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Electric field, 3 component vector</span></span><br><span class="line">                out.write(<span class="string">&#x27;&lt;DataArray Name=&quot;ef&quot; NumberOfComponents=&quot;3&quot; format=&quot;ascii&quot; type=&quot;Float64&quot;&gt;\n&#x27;</span>)</span><br><span class="line">                np.savetxt(out, ReshapeForVTK3d(world.ef, world.ni, world.nj, world.nk))</span><br><span class="line">                out.write(<span class="string">&#x27;&lt;/DataArray&gt;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Close out tags</span></span><br><span class="line">                out.write(<span class="string">&quot;&lt;/PointData&gt;\n&quot;</span>)</span><br><span class="line">                out.write(<span class="string">&quot;&lt;/ImageData&gt;\n&quot;</span>)</span><br><span class="line">                out.write(<span class="string">&quot;&lt;/VTKFile&gt;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Output successfully written to <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Could not open <span class="subst">&#123;filename&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="主代码">主代码</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定您想要添加为模块导入路径的目录</span></span><br><span class="line">pathClasses = <span class="string">&quot;path/to/通过例子学习等离子体模拟/ch2/snippets/step2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定路径到sys.path</span></span><br><span class="line"><span class="keyword">if</span> pathClasses <span class="keyword">not</span> <span class="keyword">in</span> sys.path:</span><br><span class="line">    sys.path.append(pathClasses)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> World <span class="keyword">import</span> World</span><br><span class="line"><span class="keyword">from</span> Output <span class="keyword">import</span> Output</span><br><span class="line"></span><br><span class="line">world = World(<span class="number">21</span>,<span class="number">21</span>,<span class="number">21</span>) <span class="comment"># //calls World constructor to create a variable &#x27;world&#x27;</span></span><br><span class="line">world.setExtents([-<span class="number">0.1</span>,-<span class="number">0.1</span>,<span class="number">0</span>],[<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.2</span>]) <span class="comment"># </span></span><br><span class="line"></span><br><span class="line">output = Output()</span><br><span class="line"></span><br><span class="line">output.fields(world)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/images/Visualization_of_the_initial_domain_in_Paraview.png" class="" width="800" title="Figure 2.4: Visualization of the initial domain in Paraview.">
<h2 id="势求解器">势求解器</h2>
<p>上一章节介绍了Gauss-Seidel
算法求解泊松方程。我们从离散化控制方程开始： <span
class="math display">\[\begin{equation}
    \nabla^2\phi=-\rho/\epsilon_0
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
    \begin{aligned}\frac{\phi_{i-1,j,k}-2\phi_{i,j,k}+\phi_{i+1,j,k}}{\Delta^2x}+\frac{\phi_{i,j-1,k}-2\phi_{i,j,k}+\phi_{i,j+1,k}}{\Delta^2y}+\\\frac{\phi_{i,j,k-1}-2\phi_{i,j,k}+\phi_{i,j,k+1}}{\Delta^2z}&amp;=-\rho_i/\epsilon_0\end{aligned}
\end{equation}\]</span></p>
<p>离散基于二阶中心差分。<span class="math inline">\(\Delta^2x=(\Delta
x)^2\)</span>。接下来将所有<span
class="math inline">\(\phi_{i,j,k}\)</span>项都放在等式左侧： <span
class="math display">\[\begin{equation}
    \begin{aligned}\left(\frac{2}{\Delta^2x}+\frac{2}{\Delta^2y}+\frac{2}{\Delta^2z}\right)\phi_{i,j,k}=\rho_i/\epsilon_0+\frac{\phi_{i-1,j,k}+\phi_{i+1,j,k}}{\Delta^2x}+\\\frac{\phi_{i,j-1,k}+\phi_{i,j+1,k}}{\Delta^2y}+\frac{\phi_{i,j,k-1}+\phi_{i,j,k+1}}{\Delta^2z}\end{aligned}
\end{equation}\]</span></p>
<p>最后，为了求解<span
class="math inline">\(\phi_{i,j,k}\)</span>，我们得到一个关于节点i、j、k处电势新估计的方程。
高斯-塞德尔常与连续过松弛法（SOR）结合使用，以加速收敛。最终的方程为
<span class="math display">\[\begin{equation}
    \begin{aligned}\phi_{i,j,k}^*=\left(\rho_i/\epsilon_0+\frac{\phi_{i-1,j,k}+\phi_{i+1,j,k}}{\Delta^2x}+\frac{\phi_{i,j-1,k}+\phi_{i,j+1,k}}{\Delta^2y}+\right.\\\frac{\phi_{i,j,k-1}+\phi_{i,j,k+1}}{\Delta^2z})/\left(\frac{2}{\Delta^2x}+\frac{2}{\Delta^2y}+\frac{2}{\Delta^2z}\right)\end{aligned}
\end{equation}\]</span> 以及 <span
class="math display">\[\begin{equation}
    \phi_{i,j,k}\leftarrow\phi_{i,j,k}+w(\phi_{i,j,k}^*-\phi_{i,j,k})
\end{equation}\]</span> 此处，箭头表明了我们将右侧的值 overwriting <span
class="math inline">\(\phi_{i,j,k}\)</span>的值。上述算法仅在内部节点(中心差分可以被
evaluated)上有效。一般情况下，我们需要添加方程以控制边界。由于此处box
walls被假定为Dirichlet，我们通过将循环限制在内部网格节点上(<span
class="math inline">\(i\in[1,ni-2]\)</span>、<span
class="math inline">\(j\in[1,nj-2]\)</span>以及<span
class="math inline">\(k\in[1,nk-2]\)</span>)以简单的跳过它们(边界？)。求解器被定义为位于
PotentialSolver.h 中的PotentialSolver对象的成员函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PotentialSolver</span>&#123;</span></span><br><span class="line">    public:</span><br><span class="line">        <span class="comment">// 构造函数，为输入设定成员函数</span></span><br><span class="line">        PotentialSolver(World &amp;world, <span class="type">int</span> max_it, <span class="type">double</span> tol):</span><br><span class="line">            world(world), max_solver_it(max_it), tolerance(tol)&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用高斯-塞德尔和SOR算法求解电势</span></span><br><span class="line">        <span class="type">bool</span> <span class="title function_">solve</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算电场 = -梯度(phi)</span></span><br><span class="line">        <span class="type">void</span> <span class="title function_">computeEF</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        protected:</span><br><span class="line">            World &amp;world;</span><br><span class="line">            unsingned max_solver_it;</span><br><span class="line">            <span class="type">double</span> tolerance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>构造函数接受一个对World对象的引用作为参数，我们将其保存为类成员。
这个引用是为了访问phi场和网格几何结构。我们还设置了一些求解器参数：最大迭代次数和容差。实际的高斯-赛德尔算法在PotentialSolver.cpp中的solve函数中实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PotentialSolver::solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Field &amp;phi = world.phi; <span class="comment">// references to avoid writing world.phi</span></span><br><span class="line">    Field &amp;rho = world.rho;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预计算 1/(dx^2)</span></span><br><span class="line">    double3 dh = world.<span class="built_in">getDh</span>();</span><br><span class="line">    <span class="type">double</span> idx2 = <span class="number">1.0</span>/(dh[<span class="number">0</span>]*dh[<span class="number">0</span>]);   <span class="comment">// 1/dx^2</span></span><br><span class="line">    <span class="type">double</span> idy2 = <span class="number">1.0</span>/(dh[<span class="number">1</span>]*dh[<span class="number">1</span>]);   <span class="comment">// 1/dy^2</span></span><br><span class="line">    <span class="type">double</span> idz2 = <span class="number">1.0</span>/(dh[<span class="number">2</span>]*dh[<span class="number">2</span>]);   <span class="comment">// 1/dz^2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> L2=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> converged=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求解电势</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> it=<span class="number">0</span>; it&lt;max_solver_it; it++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;world.ni<span class="number">-1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;world.nj<span class="number">-1</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>; k&lt;world.nk<span class="number">-1</span>; k++)&#123;</span><br><span class="line">                    <span class="comment">// 标准内部开放节点</span></span><br><span class="line">                    <span class="type">double</span> phi_new = (rho[i][j][k]/Const::EPS_0 + </span><br><span class="line">                                        idx2* (phi[i<span class="number">-1</span>][j][k] + phi[i+<span class="number">1</span>][j][k]) +</span><br><span class="line">                                        idy2* (phi[i][j<span class="number">-1</span>][k] + phi[i][j+<span class="number">1</span>][k] )+</span><br><span class="line">                                        idz2* (phi[i][j][k<span class="number">-1</span>] + phi[i][j][k+<span class="number">1</span>])) /</span><br><span class="line">                                        (<span class="number">2</span>*idx2 + <span class="number">2</span>*idy2 + <span class="number">2</span>*idz2);</span><br><span class="line">                    <span class="comment">// SOR</span></span><br><span class="line">                    phi[i][j][k] = phi[i][j][k] + <span class="number">1.4</span>*(phi_new - phi[i][j][k]);                                                    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否守恒</span></span><br><span class="line">        <span class="keyword">if</span> (it%<span class="number">25</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;world.ni<span class="number">-1</span>; i++)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;world.nj<span class="number">-1</span>; j++)</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>; k&lt;world.nk<span class="number">-1</span>; k++)&#123;</span><br><span class="line">                                <span class="type">double</span> R = -phi[i][j][k]*(<span class="number">2</span>*idx2+<span class="number">2</span>*idy2+<span class="number">2</span>*idz2) +</span><br><span class="line">                                            rho[i][j][k]/Const::EPS_0 + </span><br><span class="line">                                            +idx2* (phi[i<span class="number">-1</span>][j][k] + phi[i+<span class="number">1</span>][j][k])</span><br><span class="line">                                            +idy2* (phi[i][j<span class="number">-1</span>][k] + phi[i][j+<span class="number">1</span>][k])</span><br><span class="line">                                            +idz2* (phi[i][j][k<span class="number">-1</span>] + phi[i][j][k+<span class="number">1</span>]);</span><br><span class="line">                                sum += R*R;</span><br><span class="line">                            &#125;</span><br><span class="line">            L2 = <span class="built_in">sqrt</span>(sum/world.ni*world.nj*world.nk);</span><br><span class="line">            <span class="keyword">if</span> (L2&lt;tolerance)&#123;</span><br><span class="line">                converged=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="comment">// 迭代循环</span></span><br><span class="line">    <span class="keyword">if</span> (!converged) cerr&lt;&lt;<span class="string">&quot;GS failed to converge, L2=&quot;</span>&lt;&lt;L2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> converged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先建立对phi和rho的local引用。这一步骤是为了美观，避免每次我们需要访问势能时都必须写出world.phi。
每隔25次迭代，计算残差向量： <span
class="math display">\[\begin{equation}
    \vec{R}=\mathbf{A}\vec{x}-\vec{b}
\end{equation}\]</span></p>
<p>并比较L2范数 <span class="math display">\[\begin{equation}
    \sqrt{\frac{\sum_nR_n^2}n}\leq\epsilon_{tol}
\end{equation}\]</span>
达到某种tolerance。这种收敛检查会跳过边界，因为那里自然满足狄利克雷条件。如果求解器无法达到所需的容忍度，我们会打印错误信息并返回false，表示失败。然后，我们可以重新运行求解器，增加迭代限制次数，或者像我经常做的那样，如果只在最初的几次时间步长中出现非收敛消息时，直接忽略它。物理常数以及其他一些常数的值是通过在World.h中添加的命名空间Const提供的。</p>
<p>由于目前<span
class="math inline">\(\rho\)</span>为零（我们还没有添加任何粒子），上述代码会在所有位置产生<span
class="math inline">\(\phi\)</span>等于0的结果。
这并不十分有趣。仅仅为了确认求解器确实能运行，我们通过在主程序中添加以下技巧，让<span
class="math inline">\(\phi_{i = 0} = 1\)</span>，<span
class="math inline">\(\phi_{k = 0} = 2\)</span>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化domain</span></span><br><span class="line">    <span class="function">World <span class="title">world</span><span class="params">(<span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>)</span></span></span><br><span class="line"><span class="function">    world.<span class="title">setExtents</span><span class="params">(&#123;<span class="number">-0.1</span>, <span class="number">-0.1</span>, <span class="number">0.0</span>&#125;,&#123;<span class="number">0.1</span>，<span class="number">0.1</span>， <span class="number">0.2</span>&#125;)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 设定phi[i=0]=1以测试</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="params">(<span class="type">int</span> j=<span class="number">0</span>; j&lt;world.nn[<span class="number">1</span>]; j++)</span></span></span><br><span class="line"><span class="function">        <span class="title">for</span> <span class="params">(<span class="type">int</span> k=<span class="number">0</span>; k&lt;world.nn[<span class="number">2</span>]; k++)</span></span></span><br><span class="line"><span class="function">            world.phi[0][j][k] </span>= <span class="number">1</span>;   <span class="comment">// phi[i=0]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定phi[k=0]=2以测试</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;world.nn[<span class="number">0</span>]; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;world.nn[<span class="number">1</span>]; j++)</span><br><span class="line">            world.phi[i][j][<span class="number">0</span>] = <span class="number">2</span>; <span class="comment">// phi[k=0] = 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化和求解电势</span></span><br><span class="line">    <span class="function">PotentialSolver <span class="title">solver</span><span class="params">(world, <span class="number">5000</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    solver.<span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存结果</span></span><br><span class="line">    Output::<span class="built_in">fields</span>(world);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="电场">电场</h2>
<p>在ES-PIC模拟中，等离子体势仅仅是一块垫脚石，用于获取电场： <span
class="math display">\[\begin{equation}
    \vec{E}=-\nabla\phi\equiv-\left(\frac{\partial\phi}{\partial
x}\hat{i}+\frac{\partial\phi}{\partial
y}\hat{j}+\frac{\partial\phi}{\partial z}\hat{k}\right)
\end{equation}\]</span>
我们仍使用有限差分方法来重写导数。根据中心差分，我们有： <span
class="math display">\[\begin{equation}
    \begin{aligned}
    \vec{E}=&amp;\left(\frac{\phi_{i-1,j,k}-\phi_{i+1,j,k}}{2\Delta
x}\right)\hat{i}+\left(\frac{\phi_{i,j-1,k}-\phi_{i,j+1,k}}{2\Delta
y}\right)\hat{j}+\\&amp;\left(\frac{\phi_{i,j,k-1}-\phi_{i,j,k+1}}{2\Delta
z}\right)\hat{k}
    \end{aligned}
\end{equation}\]</span>
该差分只适用于内部节点。在边界上，我们使用前一章中研究的单侧二阶精度：
<span class="math display">\[\begin{equation}
    \begin{aligned}
        \left(E_x\right)_{i=0}&amp;
\large=\frac{3\phi_{0,j,k}+4\phi_{1,j,k}-\phi_{2,j,k}}{2\Delta x}  \\
        \left(E_x\right)_{\boldsymbol{i=}n\boldsymbol{i-1}}&amp;
=\frac{-\phi_{ni-3,j,k}+4\phi_{ni-2,j,k}-\phi_{ni-1,j,k}}{2\Delta x}
    \end{aligned}
\end{equation}\]</span></p>
<p>在<span class="math inline">\(y\)</span>和<span
class="math inline">\(z\)</span>面具有相似的方程。这些关系式在computeEF函数中实现。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算电场 = -梯度(phi)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PotentialSolver::computeEF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// reference to phi以避免写world.phi</span></span><br><span class="line">    Field &amp;phi = world.phi;</span><br><span class="line">    double3 dh = world.getDh</span><br><span class="line">    <span class="type">double</span> dx = dh[<span class="number">0</span>]</span><br><span class="line">    <span class="type">double</span> dy = dh[<span class="number">1</span>]</span><br><span class="line">    <span class="type">double</span> dz = dh[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;world.ni; i++)      <span class="comment">// 对整个节点循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;world.nj; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>; k&lt;world.nk; k++)&#123;</span><br><span class="line">                double3 &amp;ef = world.ef[i][j][k]; <span class="comment">// ref to (i,j,k) ef vec3</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// x component, efx</span></span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>)    <span class="comment">// 向前差分</span></span><br><span class="line">                    ef[<span class="number">0</span>] = -(<span class="number">-3</span>*phi[i][j][k] + <span class="number">4</span>*phi[i+<span class="number">1</span>][j][k] - phi[i+<span class="number">2</span>][j][k])/(<span class="number">2</span>*dx);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i==world.ni<span class="number">-1</span>) <span class="comment">// 向后差分</span></span><br><span class="line">                    ef[<span class="number">0</span>] = -(phi[i<span class="number">-2</span>][j][k] - <span class="number">4</span>*phi[i<span class="number">-1</span>][j][k] + <span class="number">3</span>*phi[i][j][k])/(<span class="number">2</span>*dx);</span><br><span class="line">                <span class="keyword">else</span>                    <span class="comment">// 中心差分</span></span><br><span class="line">                    ef[<span class="number">0</span>] = -(phi[i+<span class="number">1</span>][j][k] - phi[i<span class="number">-1</span>][j][k])/(<span class="number">2</span>*dx);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// y component, efy</span></span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span>)</span><br><span class="line">                    ef[<span class="number">1</span>] = -(<span class="number">-3</span>*phi[i][j][k] + <span class="number">4</span>*phi[i][j+<span class="number">1</span>][k] - phi[i][j+<span class="number">2</span>][k])/(<span class="number">2</span>*dy);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j==world.nj<span class="number">-1</span>)</span><br><span class="line">                    ef[<span class="number">1</span>] = -(phi[i][j<span class="number">-2</span>][k] - <span class="number">4</span>*phi[i][j<span class="number">-1</span>][k] + <span class="number">3</span>*phi[i][j][k])/(<span class="number">2</span>*dy);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ef[<span class="number">1</span>] = -(phi[i][j+<span class="number">1</span>][k] - phi[i][j<span class="number">-1</span>][k])/(<span class="number">2</span>*dy);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// z component, efz</span></span><br><span class="line">                <span class="keyword">if</span> (k==<span class="number">0</span>)</span><br><span class="line">                    ef[<span class="number">2</span>] = -(<span class="number">-3</span>*phi[i][j][k] + <span class="number">4</span>*phi[i][j][k+<span class="number">1</span>] - phi[i][j][k+<span class="number">2</span>])/(<span class="number">2</span>*dz);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (k==world.nk<span class="number">-1</span>)</span><br><span class="line">                    ef[<span class="number">2</span>] = -(phi[i][j][k<span class="number">-2</span>] - <span class="number">4</span>*phi[i][j][k<span class="number">-1</span>] + <span class="number">3</span>*phi[i][j][k])/(<span class="number">2</span>*dz);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ef[<span class="number">2</span>] = -(phi[i][j][k+<span class="number">1</span>] - phi[i][j][k<span class="number">-1</span>])/(<span class="number">2</span>*dz);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="粒子">粒子</h2>
<p>下一步，我们需要写载入和移动粒子的代码。作者喜欢通过气体种类分类粒子。
它也简化了计算宏观流动性质的过程，比如粒子数密度和平均流速。我们首先定义一个新的数据容器来存储单个粒子。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Particle</span>&#123;</span><br><span class="line">    <span class="type">double</span> pos[<span class="number">3</span>];  <span class="comment">//  位置</span></span><br><span class="line">    <span class="type">double</span> vel[<span class="number">3</span>]; <span class="comment">// 速度</span></span><br><span class="line">    <span class="type">double</span> mpw; <span class="comment">// 宏观粒子权重</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Particle</span> (<span class="type">double</span> x[<span class="number">3</span>], <span class="type">double</span> v[<span class="number">3</span>], <span class="type">double</span> mpw):    <span class="comment">// 构造函数</span></span><br><span class="line">        pos&#123;x[<span class="number">0</span>],x[<span class="number">1</span>],x[<span class="number">2</span>]&#125;,</span><br><span class="line">        vel&#123;v[<span class="number">0</span>],v[<span class="number">1</span>],v[<span class="number">2</span>]&#125;,</span><br><span class="line">        mpw&#123;mpw&#125;&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个物体存储了定义一个粒子所需的基本信息。具体来说，存储了粒子的位置<span
class="math inline">\(\vec{x}\)</span>和速度<span
class="math inline">\(\vec{v}\)</span>。 我们也存储宏粒子权重<span
class="math inline">\(w_{mp}\)</span>。多数情况下，所有粒子具有相同的权重，而<span
class="math inline">\(w_{mp}\)</span>可以delegated到species级别处理。
我们在这里保留它一般性。</p>
<p>下一步我们定义Species对象。构造函数接受一个字符串参数，表示物种的名称，每个粒子的质量和电荷，以及对World对象的引用。
这个对象用来初始化一个局部变量Field，用于存储数密度。我们还声明了几个稍后将实现的函数。
实际的粒子存储为一个名为particles的vector<Particle>数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Species</span>&#123;</span></span><br><span class="line">    public:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        Species(<span class="built_in">string</span> name, <span class="type">double</span> mass, <span class="type">double</span> charge, World &amp;world):</span><br><span class="line">            name(name), mass(mass), charge(charge), den(world.ni, world.nj, world.nk), world(world)&#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回粒子数量</span></span><br><span class="line">            <span class="type">size_t</span> <span class="title function_">getNp</span><span class="params">()</span> <span class="type">const</span> &#123;<span class="keyword">return</span> particles.size();&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 电场 ef[] 移动所有粒子</span></span><br><span class="line">            <span class="type">void</span> <span class="title function_">advance</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算数密度</span></span><br><span class="line">            <span class="type">void</span> <span class="title function_">computeNumberDensity</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加新粒子</span></span><br><span class="line">            <span class="type">void</span> <span class="title function_">addParticle</span><span class="params">(double3 pos, double3 vel, <span class="type">double</span> mpwt)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 载入在x1-x2 box中具有num_den密度的 num_mp 粒子</span></span><br><span class="line">            <span class="type">void</span> <span class="title function_">loadParticles</span><span class="params">(double3 x1, double3 x2, <span class="type">double</span> num_den, <span class="type">int</span> num_mp)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="built_in">string</span> name;  <span class="comment">// species name</span></span><br><span class="line">            <span class="type">const</span> <span class="type">double</span> mass;  <span class="comment">// particle mass in kg</span></span><br><span class="line">            <span class="type">const</span> <span class="type">double</span> charge;    <span class="comment">// 粒子电荷 in Coulomb</span></span><br><span class="line"></span><br><span class="line">            Field den;  <span class="comment">// 数密度</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">vector</span>&lt;Particle&gt; particles;  <span class="comment">// 存储粒子的数组</span></span><br><span class="line"></span><br><span class="line">    protected:</span><br><span class="line">        World &amp;world;  <span class="comment">// 指向World对象的引用</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>离子和电子species通过实例化Species类型的变量以添加到模拟中。我们存储这些对象
within another vector。 该方法允许我们自动化后续的操作 that 包括循环整个
flying materials。
标准库vector中的向量支持自动调整大小。但是调整大小涉及到复制（或移动）之前存储的数据，因此，如果我们提前知道需要存储多少项，预先使用reserve命令分配足够的空间对我们有利：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Species.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* World初始化 ... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设定粒子species</span></span><br><span class="line">    vector&lt;Species&gt; species;</span><br><span class="line">    species.<span class="built_in">reserve</span>(<span class="number">2</span>); <span class="comment">// 预先分配两种物种的空间</span></span><br><span class="line">    species.<span class="built_in">push_back</span>(<span class="built_in">Species</span>(<span class="string">&quot;O+&quot;</span>, <span class="number">16</span>*AMU, QE, world));  <span class="comment">// AMU 单位原子质量</span></span><br><span class="line">    species.<span class="built_in">push_back</span>(<span class="built_in">Species</span>(<span class="string">&quot;e-&quot;</span>, Me, <span class="number">-1</span>*QE, world));     <span class="comment">// 电子质量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="载入粒子">载入粒子</h3>
<p>随后通过加载粒子来初始化populations。我们感兴趣的是加载粒子以使得在特定bounding
box中获得物种数密度。 对于离子，该bounding
box的尺寸与计算域相同，而对于电子来说，它只包含选定的八分之一区域。
由于数密度是单位体积粒子数量，那么具有数密度<span
class="math inline">\(n\)</span>体积<span
class="math inline">\(V\)</span>的box中包含<span
class="math inline">\(N_{real}=nV\)</span>个物理离子或电子。
这个数量的真实粒子由<span
class="math inline">\(N_{sim}\)</span>个模拟宏粒子表示，因此每个粒子的权重为<span
class="math inline">\(w_{mp} = N_{real}/N_{sim}\)</span>。 此处, <span
class="math inline">\(N_{sim}\)</span> (或<span
class="math inline">\(M\)</span>使用我们之前语法)是用户输入的。
这个计算过程如下所示。一旦我们确定了权重，我们就使用循环来采样<span
class="math inline">\(N_{sim}\)</span>个粒子的位置和速度。这个采样的具体细节目前忽略不计。
在添加粒子之前，我们通过调用reserve预留足够空间来存放num_mp个粒子。这样可以避免当向量需要调整大小时，之前插入的数据需要移动或复制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadParticles</span><span class="params">(double3 x1, double3 x2, <span class="type">double</span> num_den, <span class="type">int</span> num_mp)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> box_vol = (x2[<span class="number">0</span>] - x1[<span class="number">0</span>])*(x2[<span class="number">1</span>] - x1[<span class="number">1</span>])*(x2[<span class="number">2</span>]-x1[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">double</span> num_real = num_den*box_vol;</span><br><span class="line">    <span class="type">double</span> mpw = num_sim/num_real;  <span class="comment">// 宏粒子权重</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为粒子预先分配内存</span></span><br><span class="line">    particles.<span class="built_in">reserve</span>(num_mp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环添加粒子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>; p&lt;num_sim; p++)&#123;</span><br><span class="line">        <span class="comment">/* 采样位置和速度 */</span></span><br><span class="line">        <span class="comment">/* 添加粒子 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机数">随机数</h3>
<p>一种明显的采样位置方法是选择兴趣区域内的一个随机点。我们可以通过下面的方式来生成在<span
class="math inline">\([x_1, x_2)\)</span>范围内的随机数： <span
class="math display">\[\begin{equation}
    \begin{aligned}x=x_1+\mathcal{R}(x_2-x_1)\quad&amp;\in[0,1)\end{aligned}
\end{equation}\]</span> 其中<span
class="math inline">\(\mathcal{R}\)</span>是随机数。随机数是通过称为随机数生成器或RNG的函数生成的。
重要的是要认识到，随机数生成器通常并不会生成真正的随机数。相反，它们会从一个足够长的序列中连续返回数值，这个序列长度使得对于一般观察者来说，这些数字看起来确实像是随机的。这个序列的长度——即在数字开始重复之前可以采样的唯一数值的数量——被称为周期。使用具有大周期的生成器是至关重要的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// World.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rnd</span>&#123;</span>  <span class="comment">//  用于抽样随机数字的对象</span></span><br><span class="line">    public:</span><br><span class="line">        <span class="comment">//  构造器：设置初始随机种子和分布限制</span></span><br><span class="line">        Rnd(): mt_gen&#123;<span class="built_in">std</span>::random_device()()&#125;, rnd_dist&#123;<span class="number">0</span>, <span class="number">1.0</span>&#125;&#123;&#125;</span><br><span class="line">        <span class="type">double</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">()</span>&#123;<span class="keyword">return</span> rnd_dist(mt_gen);&#125;</span><br><span class="line"></span><br><span class="line">    protected:</span><br><span class="line">        <span class="built_in">std</span>::mt19937 mt_gen;  <span class="comment">//  随机数生成器</span></span><br><span class="line">        <span class="built_in">std</span>::uniform_real_distribution&lt;<span class="type">double</span>&gt; rnd_dist;  <span class="comment">//  分布</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> Rnd rnd;  <span class="comment">//  类型名为Rnd的对象称为rnd，在某处已定义。</span></span><br></pre></td></tr></table></figure>
<p>构造函数通过创建random_device对象的实例并从中采样一个值来设置初始seed。
如果我们想要使用相同的一组随机数重复模拟，我们将用mt_gen{0}（或者某个其他固定值）替换这种初始化方式。
然后，在World.cpp中，我们创建了一个名为rnd的Rnd类型的实例。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rnd rnd;    <span class="comment">// 创建一个Rnd对象的实例</span></span><br></pre></td></tr></table></figure>
一个随机数可以通过rnd()来进行采样。这个call利用了重载的()操作以从均匀的[0,1)分布中返回双精度随机数。
这些作为函数行为的自定义对象被称为functors。我们现在可以实现粒子加载循环的主体部分：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Species::loadPatticlesBox</span><span class="params">(double3 x1, double3 x2, <span class="type">double</span> num_den, <span class="type">int</span> num_mp)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* same code as above */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load particles on an 相等间距网格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p=<span class="number">0</span>; p&lt;num_mp; p++)&#123;</span><br><span class="line">        <span class="comment">// sample random position</span></span><br><span class="line">        double3 pos;</span><br><span class="line">        pos[<span class="number">0</span>] = x1[<span class="number">0</span>] + <span class="built_in">rnd</span>()*(x2[<span class="number">0</span>] - x1[<span class="number">0</span>]);</span><br><span class="line">        pos[<span class="number">1</span>] = x1[<span class="number">1</span>] + <span class="built_in">rnd</span>()*(x2[<span class="number">1</span>] - x1[<span class="number">1</span>]);</span><br><span class="line">        pos[<span class="number">2</span>] = x1[<span class="number">2</span>] + <span class="built_in">rnd</span>()*(x2[<span class="number">2</span>] - x1[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set initial velocity</span></span><br><span class="line">        double3 vel &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;  <span class="comment">// 静止粒子</span></span><br><span class="line">        vel[<span class="number">0</span>] = <span class="built_in">rnd</span>()*v_max[<span class="number">0</span>];    <span class="comment">// 将一个新粒子添加到数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>addParticle</code>
函数简单地向粒子向量中添加一个新的条目， <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Species::addParticle</span><span class="params">(double3 pos, double3 vel, double3 mpw)</span></span>&#123;</span><br><span class="line">    particles.<span class="built_in">emplace_back</span>(pos, vel, mpw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
最后，我们在主程序中添加对粒子加载器的调用。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定粒子种类</span></span><br><span class="line">    vector&lt;Species&gt; species;</span><br><span class="line">    species.<span class="built_in">push_back</span>(<span class="built_in">Species</span>(<span class="string">&quot;O+&quot;</span>, <span class="number">16</span>*AMU, QE, world));</span><br><span class="line">    species.<span class="built_in">push_back</span>(<span class="built_in">Species</span>(<span class="string">&quot;e-&quot;</span>, ME, <span class="number">-1</span>*QE, world));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> np_ions = <span class="number">80000</span>;    <span class="comment">//  模拟离子数量</span></span><br><span class="line">    <span class="type">int</span> np_eles = <span class="number">10000</span>;    <span class="comment">//  模拟电子数量</span></span><br><span class="line">    species[<span class="number">0</span>].<span class="built_in">loadParticlesBox</span>(world.<span class="built_in">getX0</span>(), world.<span class="built_in">getXm</span>(), <span class="number">1e11</span>, np_ions);    <span class="comment">//  加载离子</span></span><br><span class="line">    species[<span class="number">1</span>].<span class="built_in">loadParticlesBox</span>(world.<span class="built_in">getX0</span>(), world.<span class="built_in">getXc</span>(), <span class="number">1e11</span>, np_eles);    <span class="comment">//  加载电子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用范围样式循环打印粒子计数</span></span><br><span class="line">    <span class="keyword">for</span> (Species &amp;sp:species)</span><br><span class="line">        cout&lt;&lt;sp.name&lt;&lt;<span class="string">&quot; has &quot;</span>&lt;&lt;sp.<span class="built_in">getNp</span>()&lt;&lt;<span class="string">&quot; particle&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
请注意，离子在<span class="math inline">\([\vec{x}_0,
\vec{x}_m)\)</span> 区域内创建，而电子则在更小的<span
class="math inline">\([\vec{x}_0, \vec{x}_c)\)</span>
区域中创建，其<span class="math inline">\(\vec{x}_c\)</span>是质心。
这段代码是在C++语言中较新添加的一种叫做范围基础循环（range-based for
loop）中调用的。这种语法使用迭代器对象来推进当前的索引。
这是一种更为简洁的书写方式: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;Species&gt;::iterator iter = species.<span class="built_in">begin</span>(); iter!= species.<span class="built_in">end</span>(); ++iter)&#123;</span><br><span class="line">    Species &amp;sp = *iter;    <span class="comment">// 元素在当前迭代位置</span></span><br><span class="line">    <span class="comment">/* use sp here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 节点体积</p>
<p>此时，无法检查加载是否按预期进行。虽然我们可以在其中添加一个输出函数，生成粒子位置的散点图，但我们将此留到下一章。
相反，我们从粒子数据计算数密度。数密度是指在小区域内粒子的数量除以该区域的体积。单元大小控制着我们可以解析的空间细节程度。
由于我们感兴趣于计算节点中心的量，所以我们定义了一个以节点为中心的、大小与单元相等的控制体积。这意味着每个体积延伸至相邻单元的质心。</p>
<p>在一个笛卡尔网格中，每个单元体的体积为 <span
class="math inline">\(V=\Delta x \Delta y \Delta
z\)</span>。节点的体积与cell相同，至少在远离边界的内部区域是这样。
在边界面，节点体积减半。这些节点索引要么是0，要么是ni-1, nj-1,
nk-1。边上的节点，若其有两个零或ni - 1, nj - 1, 或nk -
1的索引，它们的体积会减少四分之一。最后，位于角落的节点体积会减少八分之一。换句话说，每增加一个边界索引，节点体积就减少二分之一。
这项计算由World类中的一个名为computeNodeVolumes的函数执行，每当世界范围发生变化时，它就会被调用。该函数的声明被添加到World类的受保护区块中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算节点体积，在整数节点上dx*dy*dz</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">World::computeNodeVolumes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ni; i++)&#123;   <span class="comment">// 循环整个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;ni; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;nk; k++)&#123;</span><br><span class="line">                <span class="type">double</span> V= dh[<span class="number">0</span>]*dh[<span class="number">1</span>]*dh[<span class="number">2</span>];    <span class="comment">// 标准体积</span></span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span> || i=ni<span class="number">-1</span>) V*=<span class="number">0.5</span>;    <span class="comment">// 边界体积</span></span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span> || j==nj<span class="number">-1</span>) V*=<span class="number">0.5</span>;</span><br><span class="line">                <span class="keyword">if</span> (k==<span class="number">0</span> || k==nk<span class="number">-1</span>) V*=<span class="number">0.5</span>;</span><br><span class="line">                node_vol[i][j][k] = V;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在setExtents中call该函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">World::setExtents</span><span class="params">(double3 _x0, double3 _xm)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="built_in">computeNodeVolumes</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="散射粒子到网格插值">散射：粒子到网格插值</h3>
<p>一种计算数密度的方法是统计每个控制体积内的粒子数量。这种零阶方法不被推荐，因为它不会导致粒子在cell间穿行时密度的平滑变化。
我们使用一种被称为scatter的方法，它是之前提的gather方法的反过程。它使我们能够将particle-based
data内插到计算网格中。
数据scattered到八个（在三维中）节点上，这些节点构成包含粒子的cell。由于节点在单元之间共享，这种内插确保了周围单元也“感知”到粒子。</p>
<p>scatter算法的第一步是确定粒子属于哪一个cell。这对于笛卡尔坐标系来说非常简单，因为节点位置的方程可以解析地求逆。
我们有： <span class="math display">\[\begin{equation}
    l_i=(x-x_0)/\Delta x\\
    l_j=(y-y_0)/\Delta y\\
    l_k=(z-z_0)/\Delta z
\end{equation}\]</span></p>
<p>这些索引是浮点数。整数部分对应于节点索引，而小数部分则是相对于正i、j或k方向上相邻节点的归一化距离。
我们实现在一个名为XtoL的函数中进行这项计算。这个函数直接在World.h头文件中实现，以便编译器可以进行内联处理。我们还将该函数标记为const，以表明它不会修改类的数据。这个注解可以带来额外的优化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">World</span>&#123;</span></span><br><span class="line">    double3 <span class="title function_">XtoL</span><span class="params">(double3 x)</span> <span class="type">const</span>&#123;</span><br><span class="line">        double3 lc;</span><br><span class="line">        lc[<span class="number">0</span>] = (x[<span class="number">0</span>] - x0[<span class="number">0</span>])/dh[<span class="number">0</span>];</span><br><span class="line">        lc[<span class="number">1</span>] = (x[<span class="number">1</span>] - x0[<span class="number">1</span>])/dh[<span class="number">1</span>];</span><br><span class="line">        lc[<span class="number">2</span>] = (x[<span class="number">2</span>] - x0[<span class="number">2</span>])/dh[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> lc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>
<p>我们接着使用整数转换int(<span
class="math inline">\(l_i\)</span>)来获取节点索引。使用粒子位置，cell
可以被划分为八个八分之一。
其normalized体积被用来确定粒子数据分配到每个8节点的比例。数据deposited在“对角线相对(diagonally-opposed)”方向。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Field::scatter</span><span class="params">(double3 lc, <span class="type">double</span> value)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 确保我们在domain内</span></span><br><span class="line">    <span class="keyword">if</span> (lc[<span class="number">0</span>]&lt;<span class="number">0</span> || lc[<span class="number">0</span>]&gt;=nx<span class="number">-1</span> || lc[<span class="number">1</span>]&lt;<span class="number">0</span> || lc[<span class="number">1</span>]&gt;=ny<span class="number">-1</span> || lc[<span class="number">2</span>]&lt;<span class="number">0</span> || lc[<span class="number">2</span>]&gt;=nz<span class="number">-1</span>) <span class="keyword">return</span>; <span class="comment">// 如果上述任一条件为真（即任一坐标超出边界），则执行 return，退出当前函数。这意味着代码不会继续执行后面的逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算cell索引和分数距离</span></span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)lc[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> j = (<span class="type">int</span>)lc[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> k = (<span class="type">int</span>)lc[<span class="number">2</span>];</span><br><span class="line">    <span class="type">double</span> di = lc[<span class="number">0</span>] - i;</span><br><span class="line">    <span class="type">double</span> dj = lc[<span class="number">1</span>] - j;</span><br><span class="line">    <span class="type">double</span> dk = lc[<span class="number">2</span>] - k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deposit 分数值到8个周围的节点</span></span><br><span class="line">    data[i][j][k] += (<span class="number">1</span>-di)*(<span class="number">1</span>-dj)*(<span class="number">1</span>-dk)*value;</span><br><span class="line">    data[i+<span class="number">1</span>][j][k] += di*(<span class="number">1</span>-dj)*(<span class="number">1</span>-dk)*value;</span><br><span class="line">    data[i+<span class="number">1</span>][j+<span class="number">1</span>][k] += di*dj*(<span class="number">1</span>-dk)*value;</span><br><span class="line">    data[i][j+<span class="number">1</span>][k] += (<span class="number">1</span>-di)*dj*(<span class="number">1</span>-dk)*value;</span><br><span class="line">    data[i][j][k+<span class="number">1</span>] += (<span class="number">1</span>-di)*(<span class="number">1</span>-dj)*dk*value;</span><br><span class="line">    data[i+<span class="number">1</span>][j][k+<span class="number">1</span>] += di*(<span class="number">1</span>-dj)*dk*value;</span><br><span class="line">    data[i+<span class="number">1</span>][j+<span class="number">1</span>][k+<span class="number">1</span>] += di*dj*dk*value;</span><br><span class="line">    data[i][j+<span class="number">1</span>][k+<span class="number">1</span>] += (<span class="number">1</span>-di)*dj*dk*value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 数密度</p>
<p>现在将computeNumberDensity函数添加到Species类中： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Species::computeNumberDensity</span><span class="params">()</span></span>&#123;</span><br><span class="line">    den = <span class="number">0</span>;    <span class="comment">// 设定所有值为零</span></span><br><span class="line">    <span class="keyword">for</span> (Particle &amp;part:particles)&#123; <span class="comment">// loop over particles</span></span><br><span class="line">        double3 lc = world.<span class="built_in">XtoL</span>(part.pos); <span class="comment">// 得到逻辑坐标</span></span><br><span class="line">        den.<span class="built_in">scatter</span>(lc, part.mpwt); <span class="comment">// deposit weight</span></span><br><span class="line">    &#125;</span><br><span class="line">    den /= world.node_vol;      <span class="comment">// divide by node volume</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数首先通过使用2.4.2节中介绍的重载赋值运算符，将所有数值设为零，从而清空数据。
接着，我们遍历所有粒子。计算逻辑坐标，并利用它将宏粒子的质量分散到网格中。分散过程是累加的，因此在这一步之前需要清空场。
在粒子循环完成后，den
对象包含了被插值到网格节点上的真实粒子数量。但由于我们关心的是密度，我们需要将这些计数除以节点体积。
在这里，我们使用了重载的 /=
运算符。如果在不支持运算符重载的编程语言中开发代码（或者你只是不喜欢它们），你可以定义一个名为
divideByField 的函数来执行这种逐元素的除法操作。</p>
<p>我们还修改了Output::fields函数，使其接收第二个参数，即物种向量的reference。我们遍历成员，并将密度场作为名为nd.O+和nd.e-的数据数组输出。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Output::fields</span><span class="params">(World &amp;world, vector&lt;Species&gt; &amp;species)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="comment">// species数密度</span></span><br><span class="line">    <span class="keyword">for</span> (Species &amp;sp:species)&#123;</span><br><span class="line">        out&lt;&lt;<span class="string">&quot;&lt;DataArray Name=\&quot;nd.&quot;</span>&lt;&lt;sp.name&lt;&lt;<span class="string">&quot;\&quot;</span></span><br><span class="line"><span class="string">            NumberOfComponents = \&quot;1\&quot; format=\&quot;ascii\&quot;</span></span><br><span class="line"><span class="string">            type=\&quot;Float64\&quot;&gt;\n&quot;</span>;</span><br><span class="line">        out&lt;&lt;sp.den;</span><br><span class="line">        out&lt;&lt;<span class="string">&quot;&lt;/DataArray&gt;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="电荷密度">电荷密度</h2>
<p>有了粒子数密度，就可以计算电荷密度了。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%80%9A%E8%BF%87%E7%A4%BA%E4%BE%8B%E8%AE%B2%E8%A7%A3%E7%AD%89%E7%A6%BB%E5%AD%90%E4%BD%93%E6%A8%A1%E6%8B%9F/" rel="tag"># 通过示例讲解等离子体模拟</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/year/04/20/blenderPython/" rel="prev" title="Blender Python脚本">
                  <i class="fa fa-chevron-left"></i> Blender Python脚本
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/year/07/15/crystalStructure/" rel="next" title="晶体学简介">
                  晶体学简介 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Dr. Zhou</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<!-- <br /> -->
<!-- Dr. Zhou从事科研工作的时间 -->
<span id="timeDate">载入天数...</span>
<!-- <span id="times">载入时分秒...</span> -->
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("08/02/2016 8:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
	years = (now - grt ) / 1000 / 60 / 60 / 24 / 365; ynum = Math.floor(years);
        days = (now - grt ) / 1000 / 60 / 60 / 24 - (365*ynum) ; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum)- (365*24*ynum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum)- (60*365*24*ynum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000- (60*60*365*24*ynum) - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); 
        if(String(snum).length ==1 ){snum = "0" + snum;}
        // var times = document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
        document.getElementById("timeDate").innerHTML = "Dr. Zhou 正式从事科研工作： "+ynum+" 年 " +dnum+" 天 "+hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/G-D-Zhou" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
